<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lamport Clocks and Eventual Consistency | CS 416 Study Guide</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>Lamport Clocks and Eventual Consistency</h1>
            <p>CS 416 Study Guide - Topic 05</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="01-byzantine-fault-tolerance.html">Byzantine Fault Tolerance</a></li>
                <li><a href="02-sequential-consistency.html">Sequential Consistency</a></li>
                <li><a href="03-causal-consistency.html">Causal Consistency</a></li>
                <li><a href="04-file-sync-vector-time.html">File Sync & Vector Time</a></li>
                <li><a href="05-lamport-clocks-eventual.html">Lamport Clocks</a></li>
                <li><a href="06-mutual-exclusion.html">Mutual Exclusion</a></li>
                <li><a href="07-distributed-snapshots.html">Distributed Snapshots</a></li>
                <li><a href="08-chord-dht.html">Chord DHT</a></li>
                <li><a href="09-bitcoin.html">Bitcoin</a></li>
                <li><a href="10-practice-questions.html">Practice Questions</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="overview">
            <h2>Overview</h2>
            <p>Welcome to your guide on Lamport Clocks and Eventual Consistency! These are fundamental concepts in distributed systems that help us understand how to order events and manage data across multiple machines when we can't rely on perfect synchronization.</p>

            <div class="callout-info">
                <strong>Think of it this way:</strong> Imagine trying to coordinate a group project where everyone works independently, messages get delayed, and there's no single clock everyone agrees on. How do you figure out what happened first? How do you ensure everyone eventually has the same final document? That's what we're solving here!
            </div>
        </section>

        <section id="the-problem">
            <h2>Part 1: The Problem - Why Do We Need Lamport Clocks?</h2>

            <h3>The Wall-Clock Problem</h3>
            <p>In a distributed system, you might think: "Why not just use wall-clock time to order events?"</p>

            <div class="callout-warning">
                <strong>The issue:</strong> Different computers have different clocks, and those clocks drift! Even with clock synchronization protocols (like NTP), you can't guarantee perfect synchronization across all nodes.
            </div>

            <p><strong>Example Problem:</strong></p>
            <ul>
                <li>Node A's clock says 10:00:01.500</li>
                <li>Node B's clock says 10:00:01.498 (slightly behind)</li>
                <li>Event on Node B happens physically AFTER event on Node A</li>
                <li>But B's timestamp (10:00:01.498) is LESS than A's timestamp (10:00:01.500)</li>
                <li>Wrong ordering!</li>
            </ul>

            <div class="visualization-container" style="background: white; border: 2px solid var(--secondary-color); border-radius: 10px; padding: 2rem; margin: 2rem 0;">
                <h3 style="color: var(--secondary-color); margin-top: 0;">üìä Visualization: Clock Drift Problem</h3>
                <div id="clockDriftViz" style="margin: 20px 0;">
                    <div style="display: flex; gap: 40px; margin-bottom: 20px;">
                        <div style="flex: 1;">
                            <h4 style="color: var(--primary-color); font-size: 1.1em;">Physical Timeline (Real Time)</h4>
                            <svg id="physicalTimeline" width="100%" height="200" style="border: 1px solid #ddd; border-radius: 5px;"></svg>
                        </div>
                        <div style="flex: 1;">
                            <h4 style="color: var(--primary-color); font-size: 1.1em;">Timestamp Timeline (Clocks)</h4>
                            <svg id="timestampTimeline" width="100%" height="200" style="border: 1px solid #ddd; border-radius: 5px;"></svg>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button id="animateDrift" style="background: var(--secondary-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1em;">
                            Animate Clock Drift
                        </button>
                    </div>
                    <div id="driftExplanation" style="margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 5px; display: none;">
                        <strong>Problem:</strong> Node A's event happens at real time 1.0s (clock shows 10:00:01.500),
                        Node B's event happens at real time 1.2s (clock shows 10:00:01.498).
                        <span style="color: var(--accent-color); font-weight: bold;">Despite B happening AFTER A in real time, B's timestamp is EARLIER!</span>
                    </div>
                </div>
                <script>
                    (function() {
                        const physicalSvg = document.getElementById('physicalTimeline');
                        const timestampSvg = document.getElementById('timestampTimeline');
                        const animateBtn = document.getElementById('animateDrift');
                        const explanation = document.getElementById('driftExplanation');

                        function drawTimeline(svg, title) {
                            const width = svg.clientWidth;
                            const height = 200;
                            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

                            // Draw timeline axis
                            const axisY = height / 2;
                            svg.innerHTML = `
                                <line x1="50" y1="${axisY}" x2="${width - 50}" y2="${axisY}"
                                      stroke="#bdc3c7" stroke-width="2"/>
                                <polygon points="${width-50},${axisY} ${width-60},${axisY-5} ${width-60},${axisY+5}"
                                         fill="#bdc3c7"/>
                            `;
                        }

                        function animateClockDrift() {
                            const width = physicalSvg.clientWidth;
                            const height = 200;
                            const axisY = height / 2;

                            // Clear previous animations
                            drawTimeline(physicalSvg);
                            drawTimeline(timestampSvg);

                            // Physical timeline: A at 1.0s, B at 1.2s
                            const aPhysicalX = 150;
                            const bPhysicalX = 200;

                            // Timestamp timeline: A at 1.500, B at 1.498 (B comes first!)
                            const aTimestampX = 210;
                            const bTimestampX = 190;

                            // Draw Node A event
                            setTimeout(() => {
                                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                circle.setAttribute('cx', aPhysicalX);
                                circle.setAttribute('cy', axisY - 40);
                                circle.setAttribute('r', '15');
                                circle.setAttribute('fill', '#3498db');
                                circle.setAttribute('stroke', '#2c3e50');
                                circle.setAttribute('stroke-width', '2');
                                physicalSvg.appendChild(circle);

                                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                text.setAttribute('x', aPhysicalX);
                                text.setAttribute('y', axisY - 35);
                                text.setAttribute('text-anchor', 'middle');
                                text.setAttribute('fill', 'white');
                                text.setAttribute('font-weight', 'bold');
                                text.textContent = 'A';
                                physicalSvg.appendChild(text);

                                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                label.setAttribute('x', aPhysicalX);
                                label.setAttribute('y', axisY - 60);
                                label.setAttribute('text-anchor', 'middle');
                                label.setAttribute('font-size', '12');
                                label.textContent = 'Node A (t=1.0s)';
                                physicalSvg.appendChild(label);

                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', aPhysicalX);
                                line.setAttribute('y1', axisY - 25);
                                line.setAttribute('x2', aPhysicalX);
                                line.setAttribute('y2', axisY);
                                line.setAttribute('stroke', '#3498db');
                                line.setAttribute('stroke-dasharray', '3,3');
                                physicalSvg.appendChild(line);
                            }, 500);

                            // Draw Node B event
                            setTimeout(() => {
                                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                circle.setAttribute('cx', bPhysicalX);
                                circle.setAttribute('cy', axisY + 40);
                                circle.setAttribute('r', '15');
                                circle.setAttribute('fill', '#e74c3c');
                                circle.setAttribute('stroke', '#2c3e50');
                                circle.setAttribute('stroke-width', '2');
                                physicalSvg.appendChild(circle);

                                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                text.setAttribute('x', bPhysicalX);
                                text.setAttribute('y', axisY + 45);
                                text.setAttribute('text-anchor', 'middle');
                                text.setAttribute('fill', 'white');
                                text.setAttribute('font-weight', 'bold');
                                text.textContent = 'B';
                                physicalSvg.appendChild(text);

                                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                label.setAttribute('x', bPhysicalX);
                                label.setAttribute('y', axisY + 70);
                                label.setAttribute('text-anchor', 'middle');
                                label.setAttribute('font-size', '12');
                                label.textContent = 'Node B (t=1.2s)';
                                physicalSvg.appendChild(label);

                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', bPhysicalX);
                                line.setAttribute('y1', axisY + 25);
                                line.setAttribute('x2', bPhysicalX);
                                line.setAttribute('y2', axisY);
                                line.setAttribute('stroke', '#e74c3c');
                                line.setAttribute('stroke-dasharray', '3,3');
                                physicalSvg.appendChild(line);
                            }, 1000);

                            // Draw timestamps (B before A!)
                            setTimeout(() => {
                                // Node B timestamp (comes first)
                                const circleB = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                circleB.setAttribute('cx', bTimestampX);
                                circleB.setAttribute('cy', axisY + 40);
                                circleB.setAttribute('r', '15');
                                circleB.setAttribute('fill', '#e74c3c');
                                circleB.setAttribute('stroke', '#2c3e50');
                                circleB.setAttribute('stroke-width', '2');
                                timestampSvg.appendChild(circleB);

                                const textB = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                textB.setAttribute('x', bTimestampX);
                                textB.setAttribute('y', axisY + 45);
                                textB.setAttribute('text-anchor', 'middle');
                                textB.setAttribute('fill', 'white');
                                textB.setAttribute('font-weight', 'bold');
                                textB.textContent = 'B';
                                timestampSvg.appendChild(textB);

                                const labelB = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                labelB.setAttribute('x', bTimestampX);
                                labelB.setAttribute('y', axisY + 70);
                                labelB.setAttribute('text-anchor', 'middle');
                                labelB.setAttribute('font-size', '12');
                                labelB.textContent = '10:00:01.498';
                                timestampSvg.appendChild(labelB);

                                const lineB = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                lineB.setAttribute('x1', bTimestampX);
                                lineB.setAttribute('y1', axisY + 25);
                                lineB.setAttribute('x2', bTimestampX);
                                lineB.setAttribute('y2', axisY);
                                lineB.setAttribute('stroke', '#e74c3c');
                                lineB.setAttribute('stroke-dasharray', '3,3');
                                timestampSvg.appendChild(lineB);
                            }, 1500);

                            setTimeout(() => {
                                // Node A timestamp (comes after)
                                const circleA = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                circleA.setAttribute('cx', aTimestampX);
                                circleA.setAttribute('cy', axisY - 40);
                                circleA.setAttribute('r', '15');
                                circleA.setAttribute('fill', '#3498db');
                                circleA.setAttribute('stroke', '#2c3e50');
                                circleA.setAttribute('stroke-width', '2');
                                timestampSvg.appendChild(circleA);

                                const textA = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                textA.setAttribute('x', aTimestampX);
                                textA.setAttribute('y', axisY - 35);
                                textA.setAttribute('text-anchor', 'middle');
                                textA.setAttribute('fill', 'white');
                                textA.setAttribute('font-weight', 'bold');
                                textA.textContent = 'A';
                                timestampSvg.appendChild(textA);

                                const labelA = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                labelA.setAttribute('x', aTimestampX);
                                labelA.setAttribute('y', axisY - 60);
                                labelA.setAttribute('text-anchor', 'middle');
                                labelA.setAttribute('font-size', '12');
                                labelA.textContent = '10:00:01.500';
                                timestampSvg.appendChild(labelA);

                                const lineA = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                lineA.setAttribute('x1', aTimestampX);
                                lineA.setAttribute('y1', axisY - 25);
                                lineA.setAttribute('x2', aTimestampX);
                                lineA.setAttribute('y2', axisY);
                                lineA.setAttribute('stroke', '#3498db');
                                lineA.setAttribute('stroke-dasharray', '3,3');
                                timestampSvg.appendChild(lineA);

                                // Show explanation
                                explanation.style.display = 'block';
                            }, 2000);
                        }

                        drawTimeline(physicalSvg);
                        drawTimeline(timestampSvg);
                        animateBtn.addEventListener('click', animateClockDrift);

                        // Auto-animate once on page load
                        setTimeout(animateClockDrift, 500);
                    })();
                </script>
            </div>

            <h3>What We Actually Care About: Causality</h3>
            <p>Instead of real-time ordering, we care about <strong>causal ordering</strong> - which events could have influenced other events.</p>

            <h4>The "Happened-Before" Relation (‚Üí)</h4>
            <p>Event <code>a</code> happened-before event <code>b</code> (written as <code>a ‚Üí b</code>) if:</p>
            <ol>
                <li><strong>Same process:</strong> <code>a</code> and <code>b</code> occur on the same node, and <code>a</code> occurs before <code>b</code> in program order</li>
                <li><strong>Message sending:</strong> <code>a</code> is sending a message, and <code>b</code> is receiving that same message</li>
                <li><strong>Transitivity:</strong> If <code>a ‚Üí b</code> and <code>b ‚Üí c</code>, then <code>a ‚Üí c</code></li>
            </ol>

            <h4>Concurrent Events (||)</h4>
            <p>If neither <code>a ‚Üí b</code> nor <code>b ‚Üí a</code>, then <code>a</code> and <code>b</code> are concurrent (written as <code>a || b</code>). They happened independently and couldn't have influenced each other.</p>

            <div class="visualization-container" style="background: white; border: 2px solid var(--secondary-color); border-radius: 10px; padding: 2rem; margin: 2rem 0;">
                <h3 style="color: var(--secondary-color); margin-top: 0;">üìä Visualization: Happened-Before Relation</h3>
                <div style="margin: 20px 0;">
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">
                        <button class="scenario-btn" data-scenario="same" style="background: var(--secondary-color); color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">
                            Same Process
                        </button>
                        <button class="scenario-btn" data-scenario="message" style="background: var(--secondary-color); color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">
                            Send/Receive
                        </button>
                        <button class="scenario-btn" data-scenario="transitive" style="background: var(--secondary-color); color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">
                            Transitive
                        </button>
                        <button class="scenario-btn" data-scenario="concurrent" style="background: var(--secondary-color); color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">
                            Concurrent
                        </button>
                    </div>
                    <svg id="happenedBeforeSvg" width="100%" height="350" style="border: 1px solid #ddd; border-radius: 5px;"></svg>
                    <div id="happenedBeforeExplanation" style="margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 5px;">
                        <strong>Click events to explore relationships!</strong>
                    </div>
                </div>
                <script>
                    (function() {
                        const svg = document.getElementById('happenedBeforeSvg');
                        const explanation = document.getElementById('happenedBeforeExplanation');
                        const buttons = document.querySelectorAll('.scenario-btn');
                        let selectedEvent = null;

                        const scenarios = {
                            same: {
                                title: 'Same Process: a ‚Üí b ‚Üí c',
                                nodes: [
                                    {id: 'a', x: 150, y: 175, label: 'a', process: 'P1'},
                                    {id: 'b', x: 300, y: 175, label: 'b', process: 'P1'},
                                    {id: 'c', x: 450, y: 175, label: 'c', process: 'P1'}
                                ],
                                edges: [
                                    {from: 'a', to: 'b', type: 'causal'},
                                    {from: 'b', to: 'c', type: 'causal'}
                                ],
                                explanation: 'Events on the same process are ordered by program execution. a ‚Üí b ‚Üí c because they happen sequentially on Process P1.'
                            },
                            message: {
                                title: 'Send/Receive: send(m) ‚Üí receive(m)',
                                nodes: [
                                    {id: 'a', x: 150, y: 100, label: 'a', process: 'P1'},
                                    {id: 'send', x: 300, y: 100, label: 'send(m)', process: 'P1'},
                                    {id: 'recv', x: 300, y: 250, label: 'recv(m)', process: 'P2'},
                                    {id: 'b', x: 450, y: 250, label: 'b', process: 'P2'}
                                ],
                                edges: [
                                    {from: 'a', to: 'send', type: 'causal'},
                                    {from: 'send', to: 'recv', type: 'message'},
                                    {from: 'recv', to: 'b', type: 'causal'}
                                ],
                                explanation: 'Message sending creates a happened-before relation. send(m) ‚Üí receive(m) because you must send before receiving.'
                            },
                            transitive: {
                                title: 'Transitive: a ‚Üí b, b ‚Üí c, therefore a ‚Üí c',
                                nodes: [
                                    {id: 'a', x: 100, y: 100, label: 'a', process: 'P1'},
                                    {id: 'b', x: 250, y: 100, label: 'send', process: 'P1'},
                                    {id: 'c', x: 250, y: 200, label: 'recv', process: 'P2'},
                                    {id: 'd', x: 400, y: 200, label: 'send', process: 'P2'},
                                    {id: 'e', x: 400, y: 300, label: 'recv', process: 'P3'},
                                    {id: 'f', x: 550, y: 300, label: 'f', process: 'P3'}
                                ],
                                edges: [
                                    {from: 'a', to: 'b', type: 'causal'},
                                    {from: 'b', to: 'c', type: 'message'},
                                    {from: 'c', to: 'd', type: 'causal'},
                                    {from: 'd', to: 'e', type: 'message'},
                                    {from: 'e', to: 'f', type: 'causal'},
                                    {from: 'a', to: 'f', type: 'transitive'}
                                ],
                                explanation: 'By transitivity: a ‚Üí b ‚Üí c ‚Üí d ‚Üí e ‚Üí f, therefore a ‚Üí f. Causality chains through multiple hops.'
                            },
                            concurrent: {
                                title: 'Concurrent Events: a || b (neither a ‚Üí b nor b ‚Üí a)',
                                nodes: [
                                    {id: 'a', x: 200, y: 100, label: 'a', process: 'P1'},
                                    {id: 'b', x: 350, y: 100, label: 'b', process: 'P1'},
                                    {id: 'x', x: 200, y: 250, label: 'x', process: 'P2'},
                                    {id: 'y', x: 350, y: 250, label: 'y', process: 'P2'}
                                ],
                                edges: [
                                    {from: 'a', to: 'b', type: 'causal'},
                                    {from: 'x', to: 'y', type: 'causal'}
                                ],
                                explanation: 'Events a,b on P1 and x,y on P2 are concurrent (||) because there\'s no communication between processes. They couldn\'t have influenced each other.'
                            }
                        };

                        function drawScenario(scenarioKey) {
                            const scenario = scenarios[scenarioKey];
                            const width = svg.clientWidth;
                            const height = 350;
                            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                            svg.innerHTML = '';

                            // Draw process lines
                            const processes = [...new Set(scenario.nodes.map(n => n.process))];
                            processes.forEach((proc, i) => {
                                const y = 100 + i * 150;
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', 50);
                                line.setAttribute('y1', y);
                                line.setAttribute('x2', width - 50);
                                line.setAttribute('y2', y);
                                line.setAttribute('stroke', '#bdc3c7');
                                line.setAttribute('stroke-width', '2');
                                line.setAttribute('stroke-dasharray', '5,5');
                                svg.appendChild(line);

                                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                text.setAttribute('x', 20);
                                text.setAttribute('y', y + 5);
                                text.setAttribute('font-size', '14');
                                text.setAttribute('fill', '#7f8c8d');
                                text.textContent = proc;
                                svg.appendChild(text);
                            });

                            // Draw edges
                            scenario.edges.forEach(edge => {
                                const from = scenario.nodes.find(n => n.id === edge.from);
                                const to = scenario.nodes.find(n => n.id === edge.to);

                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', from.x);
                                line.setAttribute('y1', from.y);
                                line.setAttribute('x2', to.x);
                                line.setAttribute('y2', to.y);

                                if (edge.type === 'message') {
                                    line.setAttribute('stroke', '#e74c3c');
                                    line.setAttribute('stroke-width', '3');
                                    line.setAttribute('marker-end', 'url(#arrowMessage)');
                                } else if (edge.type === 'transitive') {
                                    line.setAttribute('stroke', '#9b59b6');
                                    line.setAttribute('stroke-width', '2');
                                    line.setAttribute('stroke-dasharray', '5,5');
                                    line.setAttribute('marker-end', 'url(#arrowTransitive)');
                                } else {
                                    line.setAttribute('stroke', '#27ae60');
                                    line.setAttribute('stroke-width', '2');
                                    line.setAttribute('marker-end', 'url(#arrowCausal)');
                                }
                                svg.appendChild(line);
                            });

                            // Draw arrow markers
                            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                            defs.innerHTML = `
                                <marker id="arrowCausal" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#27ae60" />
                                </marker>
                                <marker id="arrowMessage" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#e74c3c" />
                                </marker>
                                <marker id="arrowTransitive" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#9b59b6" />
                                </marker>
                            `;
                            svg.insertBefore(defs, svg.firstChild);

                            // Draw nodes
                            scenario.nodes.forEach(node => {
                                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                                g.style.cursor = 'pointer';
                                g.addEventListener('click', () => {
                                    selectedEvent = node.id;
                                    showRelationships(scenarioKey, node.id);
                                });

                                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                circle.setAttribute('cx', node.x);
                                circle.setAttribute('cy', node.y);
                                circle.setAttribute('r', '20');
                                circle.setAttribute('fill', '#3498db');
                                circle.setAttribute('stroke', '#2c3e50');
                                circle.setAttribute('stroke-width', '2');
                                g.appendChild(circle);

                                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                text.setAttribute('x', node.x);
                                text.setAttribute('y', node.y + 5);
                                text.setAttribute('text-anchor', 'middle');
                                text.setAttribute('fill', 'white');
                                text.setAttribute('font-weight', 'bold');
                                text.setAttribute('font-size', '14');
                                text.textContent = node.label;
                                g.appendChild(text);

                                svg.appendChild(g);
                            });

                            explanation.innerHTML = `<strong>${scenario.title}</strong><br>${scenario.explanation}`;
                        }

                        function showRelationships(scenarioKey, eventId) {
                            const scenario = scenarios[scenarioKey];
                            const node = scenario.nodes.find(n => n.id === eventId);

                            // Find all events this one happened-before
                            const happensBefore = [];
                            const happensAfter = [];
                            const concurrent = [];

                            scenario.nodes.forEach(other => {
                                if (other.id === eventId) return;

                                if (hasPath(scenarioKey, eventId, other.id)) {
                                    happensBefore.push(other.label);
                                } else if (hasPath(scenarioKey, other.id, eventId)) {
                                    happensAfter.push(other.label);
                                } else {
                                    concurrent.push(other.label);
                                }
                            });

                            let msg = `<strong>Event "${node.label}" relationships:</strong><br>`;
                            if (happensBefore.length > 0) {
                                msg += `<span style="color: #27ae60;">‚Üí Happened-before: ${happensBefore.join(', ')}</span><br>`;
                            }
                            if (happensAfter.length > 0) {
                                msg += `<span style="color: #3498db;">‚Üê Happened-after: ${happensAfter.join(', ')}</span><br>`;
                            }
                            if (concurrent.length > 0) {
                                msg += `<span style="color: #e74c3c;">|| Concurrent with: ${concurrent.join(', ')}</span>`;
                            }

                            explanation.innerHTML = msg;
                        }

                        function hasPath(scenarioKey, from, to, visited = new Set()) {
                            if (from === to) return true;
                            if (visited.has(from)) return false;
                            visited.add(from);

                            const scenario = scenarios[scenarioKey];
                            const edges = scenario.edges.filter(e => e.from === from);

                            for (let edge of edges) {
                                if (hasPath(scenarioKey, edge.to, to, visited)) {
                                    return true;
                                }
                            }
                            return false;
                        }

                        buttons.forEach(btn => {
                            btn.addEventListener('click', () => {
                                buttons.forEach(b => b.style.opacity = '0.7');
                                btn.style.opacity = '1';
                                drawScenario(btn.dataset.scenario);
                            });
                        });

                        // Initial scenario
                        drawScenario('same');
                        buttons[0].style.opacity = '1';
                    })();
                </script>
            </div>
        </section>

        <section id="lamport-clocks">
            <h2>Part 2: Lamport Clocks (Scalar Clocks)</h2>

            <h3>The Big Idea</h3>
            <div class="callout-success">
                <p><strong>Lamport clocks give us a simple way to assign timestamps that respect causality.</strong></p>
                <p>If event <code>a</code> happened-before event <code>b</code>, then Lamport's timestamp of <code>a</code> will be less than <code>b</code>'s timestamp.</p>
            </div>

            <div class="callout-warning">
                <strong>Important:</strong> The reverse is NOT true! If timestamp(a) &lt; timestamp(b), we can't conclude that <code>a ‚Üí b</code>. They might be concurrent.
            </div>

            <h3>The Algorithm (4 Simple Rules)</h3>

            <div class="callout-info">
                <p><strong>Rule 1: Each node has its own counter</strong></p>
                <ul>
                    <li>Each node N<sub>i</sub> maintains a scalar clock C<sub>i</sub></li>
                    <li>Initially, C<sub>i</sub> = 0</li>
                </ul>
            </div>

            <div class="callout-info">
                <p><strong>Rule 2: Increment on every event</strong></p>
                <ul>
                    <li>Whenever a new event occurs on node N<sub>i</sub>, increment C<sub>i</sub> by 1</li>
                    <li>Events include: local operations, sending a message, receiving a message</li>
                </ul>
            </div>

            <div class="callout-info">
                <p><strong>Rule 3: Timestamp outgoing messages</strong></p>
                <ul>
                    <li>When node N<sub>i</sub> sends message m at time C<sub>i</sub>, attach timestamp T<sub>m</sub> = C<sub>i</sub> to the message</li>
                </ul>
            </div>

            <div class="callout-info">
                <p><strong>Rule 4: Update on receiving messages</strong></p>
                <ul>
                    <li>When node N<sub>j</sub> receives message m with timestamp T<sub>m</sub>:</li>
                    <li>Set C<sub>j</sub> = max(C<sub>j</sub>, T<sub>m</sub> + 1)</li>
                    <li>Then increment for the receive event (which is already included in the +1)</li>
                </ul>
            </div>

            <div class="callout-warning">
                <strong>Why T<sub>m</sub> + 1 and not just T<sub>m</sub>?</strong><br>
                Because the receive event must happen AFTER the send event. If we just used T<sub>m</sub>, we'd have the same timestamp for both, which violates causality.
            </div>

            <h3>Visual Example</h3>
            <pre><code>N1:  1 ----2----3----4----5----
         msg1‚Üì            ‚Üìmsg2
N2:  1----2----5----6----7----8----
                   ‚Üëmsg3
N3:  1----2----3----8----9----10---11---12---</code></pre>

            <div class="visualization-container" style="background: white; border: 2px solid var(--secondary-color); border-radius: 10px; padding: 2rem; margin: 2rem 0;">
                <h3 style="color: var(--secondary-color); margin-top: 0;">üìä Visualization: Lamport Clock Algorithm</h3>
                <div style="margin: 20px 0;">
                    <svg id="lamportClockSvg" width="100%" height="400" style="border: 1px solid #ddd; border-radius: 5px; margin-bottom: 20px;"></svg>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 15px;">
                        <button id="lamportRestart" style="background: var(--accent-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            ‚Üª Restart
                        </button>
                        <button id="lamportPrev" style="background: var(--warning-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            ‚Üê Previous
                        </button>
                        <button id="lamportNext" style="background: var(--success-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            Next ‚Üí
                        </button>
                        <button id="lamportAuto" style="background: var(--secondary-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            ‚ñ∂ Auto Play
                        </button>
                    </div>
                    <div id="lamportExplanation" style="padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 5px; min-height: 60px;">
                        <strong>Step 0:</strong> Initial state. All clocks start at 0. Click "Next" to begin!
                    </div>
                </div>
                <script>
                    (function() {
                        const svg = document.getElementById('lamportClockSvg');
                        const explanation = document.getElementById('lamportExplanation');
                        const restartBtn = document.getElementById('lamportRestart');
                        const prevBtn = document.getElementById('lamportPrev');
                        const nextBtn = document.getElementById('lamportNext');
                        const autoBtn = document.getElementById('lamportAuto');

                        let currentStep = 0;
                        let autoPlayInterval = null;

                        const steps = [
                            { desc: 'Initial state. All clocks start at 0.', rule: 'Init', events: [] },
                            { desc: 'N1: Event a occurs. C‚ÇÅ = 0 + 1 = 1', rule: 'Increment', events: [{node: 1, label: 'a', clock: 1, x: 100}] },
                            { desc: 'N2: Event x occurs. C‚ÇÇ = 0 + 1 = 1', rule: 'Increment', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 2, label: 'x', clock: 1, x: 100}] },
                            { desc: 'N1: Event b occurs. C‚ÇÅ = 1 + 1 = 2', rule: 'Increment', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 1, label: 'b', clock: 2, x: 200}, {node: 2, label: 'x', clock: 1, x: 100}] },
                            { desc: 'N1: Send message to N2. C‚ÇÅ = 2 + 1 = 3, message carries T=3', rule: 'Send', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 1, label: 'b', clock: 2, x: 200}, {node: 1, label: 'send', clock: 3, x: 300}, {node: 2, label: 'x', clock: 1, x: 100}], message: {from: 1, to: 2, timestamp: 3, fromX: 300, toX: 350} },
                            { desc: 'N2: Receive message with T=3. C‚ÇÇ = max(1, 3+1) = 4', rule: 'Receive (max)', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 1, label: 'b', clock: 2, x: 200}, {node: 1, label: 'send', clock: 3, x: 300}, {node: 2, label: 'x', clock: 1, x: 100}, {node: 2, label: 'recv', clock: 4, x: 350}], message: {from: 1, to: 2, timestamp: 3, fromX: 300, toX: 350, received: true} },
                            { desc: 'N1: Event e occurs. C‚ÇÅ = 3 + 1 = 4', rule: 'Increment', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 1, label: 'b', clock: 2, x: 200}, {node: 1, label: 'send', clock: 3, x: 300}, {node: 1, label: 'e', clock: 4, x: 400}, {node: 2, label: 'x', clock: 1, x: 100}, {node: 2, label: 'recv', clock: 4, x: 350}], message: {from: 1, to: 2, timestamp: 3, fromX: 300, toX: 350, received: true} },
                            { desc: 'N2: Event y occurs. C‚ÇÇ = 4 + 1 = 5', rule: 'Increment', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 1, label: 'b', clock: 2, x: 200}, {node: 1, label: 'send', clock: 3, x: 300}, {node: 1, label: 'e', clock: 4, x: 400}, {node: 2, label: 'x', clock: 1, x: 100}, {node: 2, label: 'recv', clock: 4, x: 350}, {node: 2, label: 'y', clock: 5, x: 450}], message: {from: 1, to: 2, timestamp: 3, fromX: 300, toX: 350, received: true} },
                            { desc: 'N2: Send message to N3. C‚ÇÇ = 5 + 1 = 6, message carries T=6', rule: 'Send', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 1, label: 'b', clock: 2, x: 200}, {node: 1, label: 'send', clock: 3, x: 300}, {node: 1, label: 'e', clock: 4, x: 400}, {node: 2, label: 'x', clock: 1, x: 100}, {node: 2, label: 'recv', clock: 4, x: 350}, {node: 2, label: 'y', clock: 5, x: 450}, {node: 2, label: 'send', clock: 6, x: 550}], message: {from: 1, to: 2, timestamp: 3, fromX: 300, toX: 350, received: true}, message2: {from: 2, to: 3, timestamp: 6, fromX: 550, toX: 400} },
                            { desc: 'N3: Events p, q, r occur. C‚ÇÉ = 1, 2, 3', rule: 'Increment', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 1, label: 'b', clock: 2, x: 200}, {node: 1, label: 'send', clock: 3, x: 300}, {node: 1, label: 'e', clock: 4, x: 400}, {node: 2, label: 'x', clock: 1, x: 100}, {node: 2, label: 'recv', clock: 4, x: 350}, {node: 2, label: 'y', clock: 5, x: 450}, {node: 2, label: 'send', clock: 6, x: 550}, {node: 3, label: 'p', clock: 1, x: 100}, {node: 3, label: 'q', clock: 2, x: 200}, {node: 3, label: 'r', clock: 3, x: 300}], message: {from: 1, to: 2, timestamp: 3, fromX: 300, toX: 350, received: true}, message2: {from: 2, to: 3, timestamp: 6, fromX: 550, toX: 400} },
                            { desc: 'N3: Receive message with T=6. C‚ÇÉ = max(3, 6+1) = 7', rule: 'Receive (max)', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 1, label: 'b', clock: 2, x: 200}, {node: 1, label: 'send', clock: 3, x: 300}, {node: 1, label: 'e', clock: 4, x: 400}, {node: 2, label: 'x', clock: 1, x: 100}, {node: 2, label: 'recv', clock: 4, x: 350}, {node: 2, label: 'y', clock: 5, x: 450}, {node: 2, label: 'send', clock: 6, x: 550}, {node: 3, label: 'p', clock: 1, x: 100}, {node: 3, label: 'q', clock: 2, x: 200}, {node: 3, label: 'r', clock: 3, x: 300}, {node: 3, label: 'recv', clock: 7, x: 400}], message: {from: 1, to: 2, timestamp: 3, fromX: 300, toX: 350, received: true}, message2: {from: 2, to: 3, timestamp: 6, fromX: 550, toX: 400, received: true} },
                            { desc: 'N3: Event s occurs. C‚ÇÉ = 7 + 1 = 8. Complete!', rule: 'Increment', events: [{node: 1, label: 'a', clock: 1, x: 100}, {node: 1, label: 'b', clock: 2, x: 200}, {node: 1, label: 'send', clock: 3, x: 300}, {node: 1, label: 'e', clock: 4, x: 400}, {node: 2, label: 'x', clock: 1, x: 100}, {node: 2, label: 'recv', clock: 4, x: 350}, {node: 2, label: 'y', clock: 5, x: 450}, {node: 2, label: 'send', clock: 6, x: 550}, {node: 3, label: 'p', clock: 1, x: 100}, {node: 3, label: 'q', clock: 2, x: 200}, {node: 3, label: 'r', clock: 3, x: 300}, {node: 3, label: 'recv', clock: 7, x: 400}, {node: 3, label: 's', clock: 8, x: 500}], message: {from: 1, to: 2, timestamp: 3, fromX: 300, toX: 350, received: true}, message2: {from: 2, to: 3, timestamp: 6, fromX: 550, toX: 400, received: true} }
                        ];

                        function drawStep(step) {
                            const width = svg.clientWidth;
                            const height = 400;
                            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                            svg.innerHTML = '';

                            const nodeY = { 1: 100, 2: 200, 3: 300 };
                            const nodeColors = { 1: '#3498db', 2: '#e74c3c', 3: '#27ae60' };

                            // Draw process lines
                            [1, 2, 3].forEach(nodeNum => {
                                const y = nodeY[nodeNum];
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', 50);
                                line.setAttribute('y1', y);
                                line.setAttribute('x2', width - 50);
                                line.setAttribute('y2', y);
                                line.setAttribute('stroke', '#bdc3c7');
                                line.setAttribute('stroke-width', '2');
                                svg.appendChild(line);

                                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                label.setAttribute('x', 20);
                                label.setAttribute('y', y + 5);
                                label.setAttribute('font-size', '16');
                                label.setAttribute('font-weight', 'bold');
                                label.setAttribute('fill', nodeColors[nodeNum]);
                                label.textContent = `N${nodeNum}`;
                                svg.appendChild(label);
                            });

                            const stepData = steps[step];

                            // Draw messages
                            if (stepData.message) {
                                const msg = stepData.message;
                                const fromY = nodeY[msg.from];
                                const toY = nodeY[msg.to];

                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', msg.fromX);
                                line.setAttribute('y1', fromY);
                                line.setAttribute('x2', msg.toX);
                                line.setAttribute('y2', toY);
                                line.setAttribute('stroke', msg.received ? '#7f8c8d' : '#f39c12');
                                line.setAttribute('stroke-width', '3');
                                line.setAttribute('marker-end', 'url(#msgArrow)');
                                svg.appendChild(line);

                                const msgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                msgLabel.setAttribute('x', (msg.fromX + msg.toX) / 2);
                                msgLabel.setAttribute('y', (fromY + toY) / 2 - 10);
                                msgLabel.setAttribute('font-size', '12');
                                msgLabel.setAttribute('fill', '#f39c12');
                                msgLabel.setAttribute('font-weight', 'bold');
                                msgLabel.textContent = `T=${msg.timestamp}`;
                                svg.appendChild(msgLabel);
                            }

                            if (stepData.message2) {
                                const msg = stepData.message2;
                                const fromY = nodeY[msg.from];
                                const toY = nodeY[msg.to];

                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', msg.fromX);
                                line.setAttribute('y1', fromY);
                                line.setAttribute('x2', msg.toX);
                                line.setAttribute('y2', toY);
                                line.setAttribute('stroke', msg.received ? '#7f8c8d' : '#f39c12');
                                line.setAttribute('stroke-width', '3');
                                line.setAttribute('marker-end', 'url(#msgArrow)');
                                svg.appendChild(line);

                                const msgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                msgLabel.setAttribute('x', (msg.fromX + msg.toX) / 2);
                                msgLabel.setAttribute('y', (fromY + toY) / 2 - 10);
                                msgLabel.setAttribute('font-size', '12');
                                msgLabel.setAttribute('fill', '#f39c12');
                                msgLabel.setAttribute('font-weight', 'bold');
                                msgLabel.textContent = `T=${msg.timestamp}`;
                                svg.appendChild(msgLabel);
                            }

                            // Draw arrow marker
                            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                            defs.innerHTML = `
                                <marker id="msgArrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#f39c12" />
                                </marker>
                            `;
                            svg.insertBefore(defs, svg.firstChild);

                            // Draw events
                            stepData.events.forEach((event, idx) => {
                                const y = nodeY[event.node];
                                const isLatest = idx === stepData.events.length - 1;

                                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                circle.setAttribute('cx', event.x);
                                circle.setAttribute('cy', y);
                                circle.setAttribute('r', isLatest ? '18' : '15');
                                circle.setAttribute('fill', nodeColors[event.node]);
                                circle.setAttribute('stroke', isLatest ? '#f39c12' : '#2c3e50');
                                circle.setAttribute('stroke-width', isLatest ? '4' : '2');
                                svg.appendChild(circle);

                                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                text.setAttribute('x', event.x);
                                text.setAttribute('y', y - 25);
                                text.setAttribute('text-anchor', 'middle');
                                text.setAttribute('font-size', '12');
                                text.setAttribute('fill', '#2c3e50');
                                text.textContent = event.label;
                                svg.appendChild(text);

                                const clockText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                clockText.setAttribute('x', event.x);
                                clockText.setAttribute('y', y + 30);
                                clockText.setAttribute('text-anchor', 'middle');
                                clockText.setAttribute('font-size', '14');
                                clockText.setAttribute('font-weight', 'bold');
                                clockText.setAttribute('fill', nodeColors[event.node]);
                                clockText.textContent = event.clock;
                                svg.appendChild(clockText);
                            });

                            explanation.innerHTML = `<strong>Step ${step}/${steps.length - 1}</strong> - <span style="color: var(--secondary-color);">[${stepData.rule}]</span><br>${stepData.desc}`;
                        }

                        function nextStep() {
                            if (currentStep < steps.length - 1) {
                                currentStep++;
                                drawStep(currentStep);
                            }
                        }

                        function prevStep() {
                            if (currentStep > 0) {
                                currentStep--;
                                drawStep(currentStep);
                            }
                        }

                        function restart() {
                            currentStep = 0;
                            drawStep(currentStep);
                            if (autoPlayInterval) {
                                clearInterval(autoPlayInterval);
                                autoPlayInterval = null;
                                autoBtn.textContent = '‚ñ∂ Auto Play';
                            }
                        }

                        function toggleAutoPlay() {
                            if (autoPlayInterval) {
                                clearInterval(autoPlayInterval);
                                autoPlayInterval = null;
                                autoBtn.textContent = '‚ñ∂ Auto Play';
                            } else {
                                autoBtn.textContent = '‚è∏ Pause';
                                autoPlayInterval = setInterval(() => {
                                    if (currentStep < steps.length - 1) {
                                        nextStep();
                                    } else {
                                        clearInterval(autoPlayInterval);
                                        autoPlayInterval = null;
                                        autoBtn.textContent = '‚ñ∂ Auto Play';
                                    }
                                }, 1500);
                            }
                        }

                        restartBtn.addEventListener('click', restart);
                        prevBtn.addEventListener('click', prevStep);
                        nextBtn.addEventListener('click', nextStep);
                        autoBtn.addEventListener('click', toggleAutoPlay);

                        drawStep(currentStep);
                    })();
                </script>
            </div>

            <h3>Step-by-Step Example</h3>
            <pre><code>N1:  a(1) ‚Üí b(2) ‚Üí send_msg_to_N2(3) ‚Üí e(4) ‚Üí f(5)
                    ‚Üì
N2:  x(1) ‚Üí receive_msg(4) ‚Üí y(5) ‚Üí send_msg_to_N3(6)
                                      ‚Üì
N3:  p(1) ‚Üí q(2) ‚Üí r(3) ‚Üí receive_msg(7) ‚Üí s(8)</code></pre>

            <p><strong>Explanation:</strong></p>

            <p><strong>N1's events:</strong></p>
            <ul>
                <li>a: C<sub>1</sub> = 1</li>
                <li>b: C<sub>1</sub> = 2</li>
                <li>send message to N2: C<sub>1</sub> = 3 (message carries timestamp 3)</li>
                <li>e: C<sub>1</sub> = 4</li>
                <li>f: C<sub>1</sub> = 5</li>
            </ul>

            <p><strong>N2's events:</strong></p>
            <ul>
                <li>x: C<sub>2</sub> = 1</li>
                <li>receive message from N1 (with T=3): C<sub>2</sub> = max(1, 3+1) = 4</li>
                <li>y: C<sub>2</sub> = 5</li>
                <li>send message to N3: C<sub>2</sub> = 6 (message carries timestamp 6)</li>
            </ul>

            <p><strong>N3's events:</strong></p>
            <ul>
                <li>p: C<sub>3</sub> = 1</li>
                <li>q: C<sub>3</sub> = 2</li>
                <li>r: C<sub>3</sub> = 3</li>
                <li>receive message from N2 (with T=6): C<sub>3</sub> = max(3, 6+1) = 7</li>
                <li>s: C<sub>3</sub> = 8</li>
            </ul>

            <h3>Creating Total Order from Lamport Clocks</h3>
            <p>Lamport clocks give us partial order (respecting causality). To create a total order (needed for some algorithms), we break ties using node IDs:</p>

            <p><strong>Notation: timestamp.nodeID</strong></p>
            <p>Total order: 1.1 ‚Üí 1.2 ‚Üí 1.3 ‚Üí 2.1 ‚Üí 2.2 ‚Üí 3.1 ‚Üí 3.2 ‚Üí 3.3 ‚Üí 4.1 ‚Üí 4.2 ‚Üí ...</p>
            <p>This gives us a complete ordering where if two events have the same timestamp, we order by node ID.</p>
        </section>

        <section id="lamport-vs-vector">
            <h2>Part 3: Lamport Clocks vs Vector Clocks</h2>
            <p>This is a common exam question! Let's nail down the differences.</p>

            <h3>Vector Clocks - Quick Refresher</h3>
            <p>Vector clocks maintain an array/vector of counters, one per node in the system.</p>

            <p><strong>Example:</strong> In a 3-node system:</p>
            <ul>
                <li>N1 maintains: [C<sub>1</sub>, C<sub>2</sub>, C<sub>3</sub>] = [5, 3, 2]</li>
                <li>"I've seen 5 events from N1 (me), 3 from N2, and 2 from N3"</li>
            </ul>

            <h3>The Critical Difference</h3>

            <div class="callout-info">
                <p><strong>Lamport Clocks:</strong></p>
                <ul>
                    <li><code>a ‚Üí b</code> ‚üπ <code>T(a) &lt; T(b)</code> ‚úì (If a happened-before b, then a's timestamp is less)</li>
                    <li><code>T(a) &lt; T(b)</code> ‚üπ <code>a ‚Üí b</code> OR <code>a || b</code> ‚úó (Can't determine causality from timestamps alone)</li>
                </ul>
            </div>

            <div class="callout-success">
                <p><strong>Vector Clocks:</strong></p>
                <ul>
                    <li><code>a ‚Üí b</code> ‚ü∫ <code>V(a) &lt; V(b)</code> ‚úì (Bidirectional implication!)</li>
                    <li>Can detect both causality AND concurrency</li>
                </ul>
            </div>

            <div class="callout-warning">
                <strong>Memory Aid:</strong> "Lamport is one-way, Vector is two-way"
            </div>

            <div class="visualization-container" style="background: white; border: 2px solid var(--secondary-color); border-radius: 10px; padding: 2rem; margin: 2rem 0;">
                <h3 style="color: var(--secondary-color); margin-top: 0;">üìä Visualization: Lamport vs Vector Clocks Comparison</h3>
                <div style="margin: 20px 0;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <h4 style="color: var(--primary-color); text-align: center;">Lamport Clocks (Scalar)</h4>
                            <svg id="lamportCompSvg" width="100%" height="300" style="border: 1px solid #ddd; border-radius: 5px;"></svg>
                        </div>
                        <div>
                            <h4 style="color: var(--primary-color); text-align: center;">Vector Clocks</h4>
                            <svg id="vectorCompSvg" width="100%" height="300" style="border: 1px solid #ddd; border-radius: 5px;"></svg>
                        </div>
                    </div>
                    <div style="text-align: center; margin: 20px 0;">
                        <label style="margin-right: 15px;"><strong>Compare events:</strong></label>
                        <select id="eventCompare" style="padding: 8px; border-radius: 5px; border: 1px solid #bdc3c7; font-size: 1em;">
                            <option value="">Select event pair...</option>
                            <option value="causal1">a ‚Üí c (Causal via message)</option>
                            <option value="concurrent1">b || x (Concurrent - no communication)</option>
                            <option value="causal2">a ‚Üí d (Causal via transitivity)</option>
                        </select>
                    </div>
                    <div id="comparisonExplanation" style="padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 5px;">
                        <strong>Instruction:</strong> Select an event pair above to see how Lamport and Vector clocks handle it differently!
                    </div>
                </div>
                <script>
                    (function() {
                        const lamportSvg = document.getElementById('lamportCompSvg');
                        const vectorSvg = document.getElementById('vectorCompSvg');
                        const eventSelect = document.getElementById('eventCompare');
                        const explanation = document.getElementById('comparisonExplanation');

                        // Event data: same events, different timestamp types
                        const events = {
                            lamport: [
                                {node: 1, label: 'a', x: 100, y: 80, clock: 1},
                                {node: 1, label: 'b', x: 200, y: 80, clock: 2},
                                {node: 1, label: 'send', x: 300, y: 80, clock: 3},
                                {node: 2, label: 'x', x: 100, y: 220, clock: 1},
                                {node: 2, label: 'recv', x: 300, y: 220, clock: 4},
                                {node: 2, label: 'send2', x: 400, y: 220, clock: 5},
                                {node: 3, label: 'y', x: 200, y: 360, clock: 1}, // Concurrent with everything
                                {node: 3, label: 'recv2', x: 400, y: 360, clock: 6}
                            ],
                            vector: [
                                {node: 1, label: 'a', x: 100, y: 80, clock: [1,0,0]},
                                {node: 1, label: 'b', x: 200, y: 80, clock: [2,0,0]},
                                {node: 1, label: 'send', x: 300, y: 80, clock: [3,0,0]},
                                {node: 2, label: 'x', x: 100, y: 220, clock: [0,1,0]},
                                {node: 2, label: 'recv', x: 300, y: 220, clock: [3,2,0]},
                                {node: 2, label: 'send2', x: 400, y: 220, clock: [3,3,0]},
                                {node: 3, label: 'y', x: 200, y: 360, clock: [0,0,1]},
                                {node: 3, label: 'recv2', x: 400, y: 360, clock: [3,3,2]}
                            ]
                        };

                        const messages = [
                            {from: 2, to: 4, fromX: 300, toX: 300, fromY: 80, toY: 220}, // N1 send to N2 recv
                            {from: 5, to: 7, fromX: 400, toX: 400, fromY: 220, toY: 360}  // N2 send to N3 recv
                        ];

                        function drawComparison(svgEl, eventList, isVector) {
                            const width = svgEl.clientWidth;
                            const height = 400;
                            svgEl.setAttribute('viewBox', `0 0 ${width} ${height}`);
                            svgEl.innerHTML = '';

                            const nodeY = {1: 80, 2: 220, 3: 360};
                            const nodeColors = {1: '#3498db', 2: '#e74c3c', 3: '#27ae60'};

                            // Draw process lines
                            [1, 2, 3].forEach(n => {
                                const y = nodeY[n];
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', 50);
                                line.setAttribute('y1', y);
                                line.setAttribute('x2', width - 30);
                                line.setAttribute('y2', y);
                                line.setAttribute('stroke', '#bdc3c7');
                                line.setAttribute('stroke-width', '2');
                                svgEl.appendChild(line);

                                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                label.setAttribute('x', 20);
                                label.setAttribute('y', y + 5);
                                label.setAttribute('font-size', '14');
                                label.setAttribute('font-weight', 'bold');
                                label.setAttribute('fill', nodeColors[n]);
                                label.textContent = `N${n}`;
                                svgEl.appendChild(label);
                            });

                            // Draw messages
                            messages.forEach(msg => {
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', msg.fromX);
                                line.setAttribute('y1', msg.fromY);
                                line.setAttribute('x2', msg.toX);
                                line.setAttribute('y2', msg.toY);
                                line.setAttribute('stroke', '#f39c12');
                                line.setAttribute('stroke-width', '2');
                                line.setAttribute('stroke-dasharray', '5,5');
                                svgEl.appendChild(line);
                            });

                            // Draw events
                            eventList.forEach((event, idx) => {
                                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                circle.setAttribute('cx', event.x);
                                circle.setAttribute('cy', event.y);
                                circle.setAttribute('r', '15');
                                circle.setAttribute('fill', nodeColors[event.node]);
                                circle.setAttribute('stroke', '#2c3e50');
                                circle.setAttribute('stroke-width', '2');
                                circle.setAttribute('data-idx', idx);
                                circle.classList.add('event-circle');
                                svgEl.appendChild(circle);

                                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                text.setAttribute('x', event.x);
                                text.setAttribute('y', event.y - 25);
                                text.setAttribute('text-anchor', 'middle');
                                text.setAttribute('font-size', '12');
                                text.setAttribute('font-weight', 'bold');
                                text.textContent = event.label;
                                svgEl.appendChild(text);

                                const clockText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                clockText.setAttribute('x', event.x);
                                clockText.setAttribute('y', event.y + 30);
                                clockText.setAttribute('text-anchor', 'middle');
                                clockText.setAttribute('font-size', isVector ? '10' : '12');
                                clockText.setAttribute('font-weight', 'bold');
                                clockText.setAttribute('fill', nodeColors[event.node]);
                                clockText.textContent = isVector ? `[${event.clock.join(',')}]` : event.clock;
                                svgEl.appendChild(clockText);
                            });
                        }

                        function highlightComparison(comparison) {
                            // Reset all circles
                            document.querySelectorAll('.event-circle').forEach(c => {
                                c.setAttribute('stroke', '#2c3e50');
                                c.setAttribute('stroke-width', '2');
                            });

                            const comparisons = {
                                causal1: {
                                    lamportIdxs: [0, 4], // a and recv
                                    vectorIdxs: [0, 4],
                                    lamportMsg: "Lamport: T(a)=1 < T(recv)=4. We know either a‚Üírecv OR a||recv, but can't tell which!",
                                    vectorMsg: "Vector: V(a)=[1,0,0] < V(recv)=[3,2,0]. We can definitively say a‚Üírecv (causal)!",
                                    verdict: "Vector clocks WIN: Can confirm causality"
                                },
                                concurrent1: {
                                    lamportIdxs: [1, 3], // b and x
                                    vectorIdxs: [1, 3],
                                    lamportMsg: "Lamport: T(b)=2 > T(x)=1. Suggests b happened after x, but they're actually concurrent!",
                                    vectorMsg: "Vector: V(b)=[2,0,0] and V(x)=[0,1,0]. Neither is less than the other ‚Üí b||x (concurrent)!",
                                    verdict: "Vector clocks WIN: Can detect concurrency"
                                },
                                causal2: {
                                    lamportIdxs: [0, 7], // a and recv2
                                    vectorIdxs: [0, 7],
                                    lamportMsg: "Lamport: T(a)=1 < T(recv2)=6. Could be causal or concurrent - we don't know!",
                                    vectorMsg: "Vector: V(a)=[1,0,0] < V(recv2)=[3,3,2]. Confirms a‚Üírecv2 through transitive causality!",
                                    verdict: "Vector clocks WIN: Can trace causal chains"
                                }
                            };

                            if (!comparison || !comparisons[comparison]) {
                                explanation.innerHTML = '<strong>Instruction:</strong> Select an event pair above to see how Lamport and Vector clocks handle it differently!';
                                return;
                            }

                            const comp = comparisons[comparison];

                            // Highlight in Lamport
                            comp.lamportIdxs.forEach(idx => {
                                const circle = lamportSvg.querySelector(`[data-idx="${idx}"]`);
                                if (circle) {
                                    circle.setAttribute('stroke', '#f39c12');
                                    circle.setAttribute('stroke-width', '4');
                                }
                            });

                            // Highlight in Vector
                            comp.vectorIdxs.forEach(idx => {
                                const circle = vectorSvg.querySelector(`[data-idx="${idx}"]`);
                                if (circle) {
                                    circle.setAttribute('stroke', '#f39c12');
                                    circle.setAttribute('stroke-width', '4');
                                }
                            });

                            explanation.innerHTML = `
                                <div style="margin-bottom: 10px;">
                                    <strong style="color: #3498db;">Lamport Analysis:</strong><br>
                                    ${comp.lamportMsg}
                                </div>
                                <div style="margin-bottom: 10px;">
                                    <strong style="color: #27ae60;">Vector Analysis:</strong><br>
                                    ${comp.vectorMsg}
                                </div>
                                <div style="padding: 10px; background: rgba(39, 174, 96, 0.2); border-radius: 5px; font-weight: bold; color: #27ae60;">
                                    ${comp.verdict}
                                </div>
                            `;
                        }

                        drawComparison(lamportSvg, events.lamport, false);
                        drawComparison(vectorSvg, events.vector, true);

                        eventSelect.addEventListener('change', (e) => {
                            highlightComparison(e.target.value);
                        });
                    })();
                </script>
            </div>

            <h3>When to Use Each?</h3>

            <p><strong>Use Lamport Clocks when:</strong></p>
            <ul>
                <li>You just need to order events</li>
                <li>You don't need to detect concurrency</li>
                <li>You want minimal overhead (single integer vs. entire vector)</li>
                <li>Example: Assigning sequence numbers, mutual exclusion algorithms</li>
            </ul>

            <p><strong>Use Vector Clocks when:</strong></p>
            <ul>
                <li>You need to detect concurrent/conflicting operations</li>
                <li>You're implementing causal consistency</li>
                <li>You need to identify conflicts (like in file synchronization)</li>
                <li>Example: Distributed version control, conflict detection</li>
            </ul>

            <h3>Exam Tip</h3>
            <div class="callout-warning">
                <p><strong>If the question asks "Can we determine if events are concurrent using Lamport clocks?"</strong></p>
                <p>Answer: NO! If T(a) &lt; T(b), we know either <code>a ‚Üí b</code> OR <code>a || b</code>, but we can't tell which.</p>
            </div>
        </section>

        <section id="sequential-consistency">
            <h2>Part 4: Do Lamport Clocks Ensure Sequential Consistency?</h2>

            <div class="callout-warning">
                <strong>Short answer: NO!</strong><br>
                This is a subtle but important point.
            </div>

            <h3>Sequential Consistency Recap</h3>
            <p>Sequential consistency requires:</p>
            <ol>
                <li>All operations appear in some total order</li>
                <li>Operations from each node appear in program order</li>
                <li>ALL nodes see the SAME total order</li>
            </ol>

            <h3>Why Lamport Clocks Aren't Enough</h3>
            <p>Lamport clocks help us create a total order, but they don't ensure all nodes see the SAME order or consistent states.</p>

            <p><strong>Example from Lecture:</strong></p>
            <pre><code>N1: W(x=1)[4.1] ‚Üí R(x) ‚Üí 1[5.1]
N2: W(x=3)[6.2] ‚Üí R(x) ‚Üí 3[7.2]
N3: R(x) ‚Üí 3[8.3]
N4: W(x=2)[1.4] ‚Üí R(x) ‚Üí 0[2.4] ‚Üí W(x=0)[3.4] ‚Üí R(x) ‚Üí 1[9.2]</code></pre>

            <p>Even with Lamport timestamps, N4 reads x=0 when it should potentially see x=1 or x=2 or x=3 depending on execution order. The timestamps alone don't prevent inconsistent reads.</p>

            <div class="callout-info">
                <strong>The key insight:</strong> Lamport clocks tell us a consistent way to ORDER events, but they don't enforce that all nodes APPLY those events in the same order or see consistent values.
            </div>
        </section>

        <section id="eventual-consistency">
            <h2>Part 5: Eventual Consistency</h2>
            <p>Now we're moving from strong consistency models to weaker ones!</p>

            <h3>The Core Idea</h3>
            <div class="callout-success">
                <p><strong>Eventual Consistency Definition:</strong></p>
                <p>Given NO new updates (writes), all clients will eventually see exactly the same state of the system.</p>
                <p><strong>Translation:</strong> "If we stop writing, everything will eventually match up."</p>
            </div>

            <h3>Why Would We Want This?</h3>
            <p>Remember the CAP theorem (covered next)? Sometimes we need to trade consistency for availability and partition tolerance.</p>

            <p><strong>Real-world scenario:</strong></p>
            <ul>
                <li>Social media "likes" counter</li>
                <li>It's OK if different users see slightly different like counts</li>
                <li>But eventually, after everyone's updates propagate, everyone sees the same final count</li>
                <li>This is WAY more important than blocking users when the network has issues</li>
            </ul>

            <h3>What Eventual Consistency Does NOT Guarantee</h3>
            <ol>
                <li><strong>No ordering constraints whatsoever</strong>
                    <ul><li>Different nodes can see updates in different orders</li></ul>
                </li>
                <li><strong>No guarantees during the "convergence period"</strong>
                    <ul>
                        <li>You might read stale data</li>
                        <li>You might read newer data and then older data (going backwards!)</li>
                    </ul>
                </li>
                <li><strong>No guarantees about WHEN convergence happens</strong>
                    <ul><li>Could be milliseconds, could be seconds, could be longer</li></ul>
                </li>
            </ol>

            <h3>Example</h3>
            <pre><code>Initially: x=0, y=0 on all nodes

N1: W(x=1) [1.1] ‚Üí R(x) ‚Üí 1 [5.1] ‚Üí W(y=2) [6.1]

N2: R(x) ‚Üí 0 [10.2] ‚Üí R(y) ‚Üí 2 [9.2] ‚Üí W(y=2) [2.2]

N3: W(y=2) [2.3] ‚Üí R(x) ‚Üí 0 [8.3]</code></pre>

            <p><strong>Notice the weirdness:</strong></p>
            <ul>
                <li>N2 reads y=2 at timestamp 9.2, then reads x=0 at timestamp 10.2</li>
                <li>N3 reads x=0 even though N1 wrote x=1</li>
                <li>Eventually (after all messages propagate and no new writes), everyone will see x=1, y=2</li>
            </ul>

            <div class="callout-info">
                <strong>Memory Aid:</strong> "Eventually Consistent = Eventually Correct (if we stop)"<br>
                The system is like a pot of water being stirred - it's turbulent and chaotic, but once you stop stirring, it settles into a stable state.
            </div>

            <div class="visualization-container" style="background: white; border: 2px solid var(--secondary-color); border-radius: 10px; padding: 2rem; margin: 2rem 0;">
                <h3 style="color: var(--secondary-color); margin-top: 0;">üìä Visualization: Eventual Consistency Convergence</h3>
                <div style="margin: 20px 0;">
                    <div id="eventualConsistencyViz" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px;">
                        <!-- Nodes will be dynamically generated -->
                    </div>
                    <div style="margin: 20px 0;">
                        <label style="display: block; margin-bottom: 10px;"><strong>Time: </strong><span id="timeDisplay">0</span>s</label>
                        <input type="range" id="timeSlider" min="0" max="100" value="0" style="width: 100%; height: 8px; border-radius: 5px; outline: none;">
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button id="playBtn" style="background: var(--success-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            ‚ñ∂ Play
                        </button>
                        <button id="stopWritesBtn" style="background: var(--warning-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            Stop Writes
                        </button>
                        <button id="resetBtn" style="background: var(--accent-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            Reset
                        </button>
                    </div>
                    <div id="eventualExplanation" style="margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 5px;">
                        <strong>Initial state:</strong> All nodes have x=0. Watch how writes propagate and eventually converge!
                    </div>
                </div>
                <script>
                    (function() {
                        const container = document.getElementById('eventualConsistencyViz');
                        const timeSlider = document.getElementById('timeSlider');
                        const timeDisplay = document.getElementById('timeDisplay');
                        const playBtn = document.getElementById('playBtn');
                        const stopWritesBtn = document.getElementById('stopWritesBtn');
                        const resetBtn = document.getElementById('resetBtn');
                        const explanation = document.getElementById('eventualExplanation');

                        let currentTime = 0;
                        let writesEnabled = true;
                        let playInterval = null;

                        // Timeline of events
                        const timeline = [
                            { time: 0, desc: 'Initial state: All nodes have x=0' },
                            { time: 10, node: 1, value: 5, desc: 'Node 1 writes x=5' },
                            { time: 15, node: 3, value: 3, desc: 'Node 3 writes x=3' },
                            { time: 25, propagate: {from: 1, to: 2, value: 5}, desc: 'Node 1‚Üí2: x=5 propagates' },
                            { time: 30, node: 2, value: 7, desc: 'Node 2 writes x=7' },
                            { time: 35, propagate: {from: 3, to: 4, value: 3}, desc: 'Node 3‚Üí4: x=3 propagates' },
                            { time: 40, propagate: {from: 1, to: 3, value: 5}, desc: 'Node 1‚Üí3: x=5 propagates (overwrite!)' },
                            { time: 45, propagate: {from: 2, to: 1, value: 7}, desc: 'Node 2‚Üí1: x=7 propagates' },
                            { time: 50, desc: 'WRITES STOPPED - Convergence begins' },
                            { time: 55, propagate: {from: 2, to: 3, value: 7}, desc: 'Node 2‚Üí3: x=7 propagates' },
                            { time: 60, propagate: {from: 2, to: 4, value: 7}, desc: 'Node 2‚Üí4: x=7 propagates' },
                            { time: 70, desc: 'All nodes converged to x=7!' }
                        ];

                        function initNodes() {
                            container.innerHTML = '';
                            for (let i = 1; i <= 4; i++) {
                                const node = document.createElement('div');
                                node.id = `node${i}`;
                                node.style.cssText = `
                                    padding: 20px;
                                    border-radius: 10px;
                                    border: 3px solid var(--success-color);
                                    background: white;
                                    text-align: center;
                                `;
                                node.innerHTML = `
                                    <div style="font-weight: bold; font-size: 1.2em; margin-bottom: 10px; color: var(--primary-color);">Node ${i}</div>
                                    <div style="font-size: 2em; font-weight: bold; color: var(--success-color);" class="node-value">x = 0</div>
                                `;
                                container.appendChild(node);
                            }
                        }

                        function updateVisualization(time) {
                            currentTime = time;
                            timeDisplay.textContent = time;
                            timeSlider.value = time;

                            // Reset to initial state
                            const state = [0, 0, 0, 0];

                            // Apply all events up to current time
                            timeline.forEach(event => {
                                if (event.time <= time) {
                                    if (event.node) {
                                        state[event.node - 1] = event.value;
                                    } else if (event.propagate) {
                                        state[event.propagate.to - 1] = event.propagate.value;
                                    }
                                }
                            });

                            // Update node displays
                            const allSame = state.every(v => v === state[0]);
                            const finalValue = 7;
                            const allConverged = state.every(v => v === finalValue) && time >= 70;

                            for (let i = 0; i < 4; i++) {
                                const nodeEl = document.getElementById(`node${i + 1}`);
                                const valueEl = nodeEl.querySelector('.node-value');
                                valueEl.textContent = `x = ${state[i]}`;

                                if (allConverged) {
                                    nodeEl.style.borderColor = '#27ae60';
                                    nodeEl.style.background = 'rgba(39, 174, 96, 0.1)';
                                    valueEl.style.color = '#27ae60';
                                } else if (allSame) {
                                    nodeEl.style.borderColor = '#27ae60';
                                    nodeEl.style.background = 'white';
                                    valueEl.style.color = '#27ae60';
                                } else {
                                    nodeEl.style.borderColor = '#f39c12';
                                    nodeEl.style.background = 'rgba(243, 156, 18, 0.1)';
                                    valueEl.style.color = '#f39c12';
                                }
                            }

                            // Update explanation
                            const currentEvent = timeline.filter(e => e.time <= time).pop();
                            if (currentEvent) {
                                let status = '';
                                if (allConverged) {
                                    status = '<span style="color: var(--success-color); font-weight: bold;">‚úì CONVERGED!</span> ';
                                } else if (!allSame) {
                                    status = '<span style="color: var(--warning-color); font-weight: bold;">‚ö† DIVERGENT</span> ';
                                }
                                explanation.innerHTML = `${status}<strong>t=${currentEvent.time}s:</strong> ${currentEvent.desc}`;
                            }
                        }

                        function play() {
                            if (playInterval) {
                                clearInterval(playInterval);
                                playInterval = null;
                                playBtn.textContent = '‚ñ∂ Play';
                            } else {
                                playBtn.textContent = '‚è∏ Pause';
                                playInterval = setInterval(() => {
                                    if (currentTime < 100) {
                                        updateVisualization(currentTime + 1);
                                    } else {
                                        clearInterval(playInterval);
                                        playInterval = null;
                                        playBtn.textContent = '‚ñ∂ Play';
                                    }
                                }, 100);
                            }
                        }

                        function stopWrites() {
                            if (currentTime < 50) {
                                updateVisualization(50);
                                explanation.innerHTML += '<br><span style="color: var(--warning-color);">Writes stopped! Watch convergence accelerate...</span>';
                            }
                        }

                        function reset() {
                            if (playInterval) {
                                clearInterval(playInterval);
                                playInterval = null;
                                playBtn.textContent = '‚ñ∂ Play';
                            }
                            updateVisualization(0);
                        }

                        timeSlider.addEventListener('input', (e) => {
                            updateVisualization(parseInt(e.target.value));
                        });

                        playBtn.addEventListener('click', play);
                        stopWritesBtn.addEventListener('click', stopWrites);
                        resetBtn.addEventListener('click', reset);

                        initNodes();
                        updateVisualization(0);
                    })();
                </script>
            </div>
        </section>

        <section id="cap-theorem">
            <h2>Part 6: CAP Theorem</h2>
            <p>This is one of the most famous results in distributed systems!</p>

            <h3>The Three Properties</h3>

            <div class="callout-info">
                <p><strong>C - Consistency</strong></p>
                <ul>
                    <li>All nodes see the same data at the same time</li>
                    <li>More specifically: every read receives the most recent write</li>
                </ul>
            </div>

            <div class="callout-info">
                <p><strong>A - Availability</strong></p>
                <ul>
                    <li>Every request receives a response (success or failure)</li>
                    <li>The system remains operational even if some nodes fail</li>
                </ul>
            </div>

            <div class="callout-info">
                <p><strong>P - Partition Tolerance</strong></p>
                <ul>
                    <li>The system continues to operate despite network partitions (message loss/delays)</li>
                    <li>Nodes may be temporarily unable to communicate</li>
                </ul>
            </div>

            <h3>The Theorem</h3>
            <div class="callout-warning">
                <strong>You can only have TWO out of three!</strong>
            </div>

            <div class="visualization-container" style="background: white; border: 2px solid var(--secondary-color); border-radius: 10px; padding: 2rem; margin: 2rem 0;">
                <h3 style="color: var(--secondary-color); margin-top: 0;">üìä Visualization: CAP Theorem Triangle</h3>
                <div style="margin: 20px 0;">
                    <svg id="capTriangle" width="100%" height="450" style="display: block; margin: 0 auto;"></svg>
                    <div id="capExplanation" style="margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 5px; min-height: 100px;">
                        <strong>Click on an edge or vertex to explore CAP tradeoffs!</strong>
                        <p style="margin-top: 10px; font-size: 0.95em;">The CAP theorem states you can only choose TWO of the three properties.</p>
                    </div>
                </div>
                <script>
                    (function() {
                        const svg = document.getElementById('capTriangle');
                        const explanation = document.getElementById('capExplanation');

                        const width = svg.clientWidth || 600;
                        const height = 450;
                        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

                        const centerX = width / 2;
                        const centerY = height / 2;
                        const radius = 140;

                        // Triangle vertices
                        const vertices = {
                            C: { x: centerX, y: centerY - radius, label: 'Consistency', color: '#3498db' },
                            A: { x: centerX - radius * Math.cos(Math.PI / 6), y: centerY + radius * Math.sin(Math.PI / 6), label: 'Availability', color: '#27ae60' },
                            P: { x: centerX + radius * Math.cos(Math.PI / 6), y: centerY + radius * Math.sin(Math.PI / 6), label: 'Partition Tolerance', color: '#e74c3c' }
                        };

                        const edges = {
                            CP: {
                                from: 'C', to: 'P',
                                maintained: ['Consistency', 'Partition Tolerance'],
                                sacrificed: 'Availability',
                                examples: 'MongoDB, HBase, Redis',
                                useCase: 'Banking systems - better to reject requests than show inconsistent data during partition',
                                color: '#9b59b6'
                            },
                            AP: {
                                from: 'A', to: 'P',
                                maintained: ['Availability', 'Partition Tolerance'],
                                sacrificed: 'Consistency',
                                examples: 'Cassandra, DynamoDB, CouchDB',
                                useCase: 'Social media feeds - always available, eventual consistency is acceptable',
                                color: '#f39c12'
                            },
                            CA: {
                                from: 'C', to: 'A',
                                maintained: ['Consistency', 'Availability'],
                                sacrificed: 'Partition Tolerance',
                                examples: 'MySQL (single server), PostgreSQL',
                                useCase: 'Single datacenter systems - assumes network never fails (rarely chosen for distributed systems)',
                                color: '#16a085'
                            }
                        };

                        // Draw triangle edges
                        Object.keys(edges).forEach(key => {
                            const edge = edges[key];
                            const from = vertices[edge.from];
                            const to = vertices[edge.to];

                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', from.x);
                            line.setAttribute('y1', from.y);
                            line.setAttribute('x2', to.x);
                            line.setAttribute('y2', to.y);
                            line.setAttribute('stroke', edge.color);
                            line.setAttribute('stroke-width', '6');
                            line.setAttribute('opacity', '0.3');
                            line.style.cursor = 'pointer';
                            line.addEventListener('click', () => showEdgeInfo(key));
                            line.addEventListener('mouseenter', () => {
                                line.setAttribute('stroke-width', '10');
                                line.setAttribute('opacity', '0.7');
                            });
                            line.addEventListener('mouseleave', () => {
                                line.setAttribute('stroke-width', '6');
                                line.setAttribute('opacity', '0.3');
                            });
                            svg.appendChild(line);

                            // Edge label
                            const midX = (from.x + to.x) / 2;
                            const midY = (from.y + to.y) / 2;
                            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            label.setAttribute('x', midX);
                            label.setAttribute('y', midY);
                            label.setAttribute('text-anchor', 'middle');
                            label.setAttribute('font-size', '16');
                            label.setAttribute('font-weight', 'bold');
                            label.setAttribute('fill', edge.color);
                            label.style.cursor = 'pointer';
                            label.textContent = key;
                            label.addEventListener('click', () => showEdgeInfo(key));
                            svg.appendChild(label);
                        });

                        // Draw vertices
                        Object.keys(vertices).forEach(key => {
                            const vertex = vertices[key];

                            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            circle.setAttribute('cx', vertex.x);
                            circle.setAttribute('cy', vertex.y);
                            circle.setAttribute('r', '35');
                            circle.setAttribute('fill', vertex.color);
                            circle.setAttribute('stroke', '#2c3e50');
                            circle.setAttribute('stroke-width', '3');
                            circle.style.cursor = 'pointer';
                            circle.addEventListener('click', () => showVertexInfo(key));
                            svg.appendChild(circle);

                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', vertex.x);
                            text.setAttribute('y', vertex.y + 6);
                            text.setAttribute('text-anchor', 'middle');
                            text.setAttribute('font-size', '24');
                            text.setAttribute('font-weight', 'bold');
                            text.setAttribute('fill', 'white');
                            text.textContent = key;
                            svg.appendChild(text);

                            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            label.setAttribute('x', vertex.x);
                            label.setAttribute('y', vertex.y + (key === 'C' ? -50 : 60));
                            label.setAttribute('text-anchor', 'middle');
                            label.setAttribute('font-size', '14');
                            label.setAttribute('font-weight', 'bold');
                            label.setAttribute('fill', vertex.color);
                            label.textContent = vertex.label;
                            svg.appendChild(label);
                        });

                        function showEdgeInfo(edgeKey) {
                            const edge = edges[edgeKey];
                            explanation.innerHTML = `
                                <div style="border-left: 4px solid ${edge.color}; padding-left: 15px;">
                                    <h4 style="margin: 0 0 10px 0; color: ${edge.color}; font-size: 1.3em;">${edgeKey} System</h4>
                                    <div style="margin-bottom: 10px;">
                                        <strong style="color: var(--success-color);">‚úì Maintained:</strong>
                                        ${edge.maintained.map(m => `<span style="background: rgba(39, 174, 96, 0.2); padding: 3px 8px; border-radius: 3px; margin: 0 3px;">${m}</span>`).join('')}
                                    </div>
                                    <div style="margin-bottom: 10px;">
                                        <strong style="color: var(--accent-color);">‚úó Sacrificed:</strong>
                                        <span style="background: rgba(231, 76, 60, 0.2); padding: 3px 8px; border-radius: 3px;">${edge.sacrificed}</span>
                                    </div>
                                    <div style="margin-bottom: 10px;">
                                        <strong>Examples:</strong> ${edge.examples}
                                    </div>
                                    <div style="background: rgba(52, 152, 219, 0.1); padding: 10px; border-radius: 5px; margin-top: 10px;">
                                        <strong>Use Case:</strong> ${edge.useCase}
                                    </div>
                                </div>
                            `;
                        }

                        function showVertexInfo(vertexKey) {
                            const vertex = vertices[vertexKey];
                            const descriptions = {
                                C: 'All nodes see the same data at the same time. Every read receives the most recent write.',
                                A: 'Every request receives a response (success or failure). The system remains operational even if some nodes fail.',
                                P: 'The system continues to operate despite network partitions (message loss/delays between nodes).'
                            };

                            explanation.innerHTML = `
                                <div style="border-left: 4px solid ${vertex.color}; padding-left: 15px;">
                                    <h4 style="margin: 0 0 10px 0; color: ${vertex.color}; font-size: 1.3em;">${vertex.label}</h4>
                                    <p>${descriptions[vertexKey]}</p>
                                    <p style="margin-top: 10px; font-style: italic; color: #7f8c8d;">
                                        Click on an edge (CP, AP, or CA) to see which systems choose this property combination.
                                    </p>
                                </div>
                            `;
                        }

                        // Add center explanation
                        const centerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        centerText.setAttribute('x', centerX);
                        centerText.setAttribute('y', centerY - 5);
                        centerText.setAttribute('text-anchor', 'middle');
                        centerText.setAttribute('font-size', '14');
                        centerText.setAttribute('fill', '#7f8c8d');
                        centerText.setAttribute('font-weight', 'bold');
                        centerText.textContent = 'Choose';
                        svg.appendChild(centerText);

                        const centerText2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        centerText2.setAttribute('x', centerX);
                        centerText2.setAttribute('y', centerY + 15);
                        centerText2.setAttribute('text-anchor', 'middle');
                        centerText2.setAttribute('font-size', '14');
                        centerText2.setAttribute('fill', '#7f8c8d');
                        centerText2.setAttribute('font-weight', 'bold');
                        centerText2.textContent = 'TWO';
                        svg.appendChild(centerText2);
                    })();
                </script>
            </div>

            <h3>The Three Combinations</h3>

            <div class="callout-info">
                <p><strong>CP (Consistency + Partition Tolerance):</strong></p>
                <ul>
                    <li>When network partition occurs, system stops serving some requests</li>
                    <li>Ensures consistency by refusing to answer if it might give stale data</li>
                    <li>Example: Banking systems - better to reject a transaction than show wrong balance</li>
                    <li><strong>Consistency model:</strong> Sequential consistency</li>
                </ul>
            </div>

            <div class="callout-info">
                <p><strong>AP (Availability + Partition Tolerance):</strong></p>
                <ul>
                    <li>System remains available during partition, but might return stale data</li>
                    <li>Every request gets a response, even if it's not the latest</li>
                    <li>Example: Social media feeds, DNS</li>
                    <li><strong>Consistency model:</strong> Eventual consistency (or causal consistency)</li>
                </ul>
            </div>

            <div class="callout-warning">
                <p><strong>CA (Consistency + Availability):</strong></p>
                <ul>
                    <li>Only works when there are NO partitions</li>
                    <li>All nodes must always be able to communicate</li>
                    <li>Only realistic in single-datacenter setups with reliable networks</li>
                    <li><strong>Consistency model:</strong> Sequential consistency</li>
                    <li><strong>Rarely chosen</strong> because network partitions are inevitable in real distributed systems</li>
                </ul>
            </div>

            <h3>How This Relates to Our Consistency Models</h3>

            <p><strong>Strong/Sequential Consistency:</strong></p>
            <ul>
                <li>Prioritizes consistency over availability</li>
                <li>CP or CA approach</li>
                <li>Requires coordination (blocking, voting, consensus)</li>
            </ul>

            <p><strong>Causal Consistency:</strong></p>
            <ul>
                <li>Middle ground - AP approach</li>
                <li>Allows operations during partition</li>
                <li>Detects and exposes conflicts to users (using vector timestamps)</li>
            </ul>

            <p><strong>Eventual Consistency:</strong></p>
            <ul>
                <li>Fully AP approach</li>
                <li>Maximum availability</li>
                <li>Weakest consistency guarantees</li>
            </ul>

            <h3>Real-World Examples</h3>

            <p><strong>CP Systems:</strong></p>
            <ul>
                <li>Banking/financial systems</li>
                <li>Inventory management (can't sell what you don't have)</li>
                <li>HBase, MongoDB (in some configurations)</li>
            </ul>

            <p><strong>AP Systems:</strong></p>
            <ul>
                <li>Amazon's DynamoDB</li>
                <li>Cassandra</li>
                <li>DNS</li>
                <li>Web caching</li>
            </ul>

            <p><strong>CA Systems:</strong></p>
            <ul>
                <li>Traditional single-server databases (MySQL on one machine)</li>
                <li>Not really distributed systems!</li>
            </ul>

            <h3>Exam Strategy</h3>

            <div class="callout-success">
                <p><strong>When asked "What would you choose for X system?"</strong></p>
                <ol>
                    <li><strong>Identify what matters most:</strong>
                        <ul>
                            <li>Financial data? ‚Üí CP (consistency matters)</li>
                            <li>Social media? ‚Üí AP (availability matters)</li>
                            <li>Single datacenter, critical data? ‚Üí CA (but be careful!)</li>
                        </ul>
                    </li>
                    <li><strong>Consider partition tolerance:</strong>
                        <ul>
                            <li>Real distributed system? You NEED P!</li>
                            <li>So really, you're choosing between CP and AP</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </section>

        <section id="putting-it-together">
            <h2>Part 7: How It All Fits Together</h2>
            <p>Let's connect Lamport clocks and eventual consistency:</p>

            <h3>The Relationship</h3>

            <p><strong>Lamport Clocks:</strong></p>
            <ul>
                <li>Tool for ordering events</li>
                <li>Respects causality (one direction)</li>
                <li>Useful for creating consistent histories</li>
            </ul>

            <p><strong>Eventual Consistency:</strong></p>
            <ul>
                <li>Consistency model (specification of guarantees)</li>
                <li>Very weak - no ordering required during operation</li>
                <li>Only requires convergence when writes stop</li>
            </ul>

            <h3>When Would You Use Lamport Clocks with Eventual Consistency?</h3>

            <p><strong>Scenario:</strong> Distributed database with eventual consistency</p>

            <p><strong>How Lamport clocks help:</strong></p>
            <ol>
                <li><strong>Conflict detection:</strong> If two writes have unrelated Lamport timestamps, we know they're potentially conflicting</li>
                <li><strong>Last-writer-wins:</strong> Simple conflict resolution - highest timestamp wins</li>
                <li><strong>Debug logging:</strong> Helps understand event ordering for troubleshooting</li>
            </ol>

            <p><strong>Example - Shopping Cart:</strong></p>
            <pre><code>User adds item A on their phone: T=5
User adds item B on their laptop: T=3
System uses Lamport clocks to order: B (T=3) then A (T=5)
Final cart: [B, A]</code></pre>

            <p>But note: This isn't causal consistency! The Lamport timestamp might not reflect actual causality. But it gives us a deterministic way to resolve conflicts.</p>

            <div class="visualization-container" style="background: white; border: 2px solid var(--secondary-color); border-radius: 10px; padding: 2rem; margin: 2rem 0;">
                <h3 style="color: var(--secondary-color); margin-top: 0;">üìä Visualization: Lamport Clocks in Eventual Consistency</h3>
                <div style="margin: 20px 0;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div style="border: 2px solid #3498db; border-radius: 10px; padding: 15px; background: rgba(52, 152, 219, 0.05);">
                            <h4 style="color: #3498db; margin: 0 0 10px 0; text-align: center;">üì± Phone</h4>
                            <div id="phoneCart" style="min-height: 100px; font-size: 1.1em;"></div>
                            <div style="margin-top: 10px; font-size: 0.9em; color: #7f8c8d;">
                                Lamport Clock: <span id="phoneClock" style="font-weight: bold; color: #3498db;">0</span>
                            </div>
                        </div>
                        <div style="border: 2px solid #e74c3c; border-radius: 10px; padding: 15px; background: rgba(231, 76, 60, 0.05);">
                            <h4 style="color: #e74c3c; margin: 0 0 10px 0; text-align: center;">üíª Laptop</h4>
                            <div id="laptopCart" style="min-height: 100px; font-size: 1.1em;"></div>
                            <div style="margin-top: 10px; font-size: 0.9em; color: #7f8c8d;">
                                Lamport Clock: <span id="laptopClock" style="font-weight: bold; color: #e74c3c;">0</span>
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 15px;">
                        <button id="addPhoneItem" style="background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            üì± Add Item (Phone)
                        </button>
                        <button id="addLaptopItem" style="background: #e74c3c; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            üíª Add Item (Laptop)
                        </button>
                        <button id="syncDevices" style="background: var(--success-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            üîÑ Sync & Resolve
                        </button>
                        <button id="resetCart" style="background: var(--accent-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            ‚Üª Reset
                        </button>
                    </div>
                    <div id="shoppingExplanation" style="padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 5px;">
                        <strong>Shopping Cart with Eventual Consistency</strong><br>
                        Add items on both devices to create conflicts. Then sync to see last-writer-wins resolution based on Lamport clocks!
                    </div>
                </div>
                <script>
                    (function() {
                        const phoneCartEl = document.getElementById('phoneCart');
                        const laptopCartEl = document.getElementById('laptopCart');
                        const phoneClockEl = document.getElementById('phoneClock');
                        const laptopClockEl = document.getElementById('laptopClock');
                        const explanation = document.getElementById('shoppingExplanation');

                        let phoneClock = 0;
                        let laptopClock = 0;
                        let phoneCart = [];
                        let laptopCart = [];

                        const items = ['üçé Apple', 'üçå Banana', 'ü•ñ Bread', 'ü•õ Milk', 'üçï Pizza', '‚òï Coffee', 'üç™ Cookies', 'ü•ó Salad'];
                        let itemIndex = 0;

                        function updateDisplay() {
                            phoneCartEl.innerHTML = phoneCart.length > 0
                                ? phoneCart.map(item => `<div style="padding: 5px 0; border-bottom: 1px solid #ddd;">${item.name} <span style="float: right; color: #7f8c8d; font-size: 0.85em;">T=${item.timestamp}</span></div>`).join('')
                                : '<div style="color: #7f8c8d; font-style: italic;">Empty cart</div>';

                            laptopCartEl.innerHTML = laptopCart.length > 0
                                ? laptopCart.map(item => `<div style="padding: 5px 0; border-bottom: 1px solid #ddd;">${item.name} <span style="float: right; color: #7f8c8d; font-size: 0.85em;">T=${item.timestamp}</span></div>`).join('')
                                : '<div style="color: #7f8c8d; font-style: italic;">Empty cart</div>';

                            phoneClockEl.textContent = phoneClock;
                            laptopClockEl.textContent = laptopClock;
                        }

                        function addItemPhone() {
                            phoneClock++;
                            const item = { name: items[itemIndex % items.length], timestamp: phoneClock, device: 'phone' };
                            phoneCart.push(item);
                            itemIndex++;
                            updateDisplay();
                            explanation.innerHTML = `<strong style="color: #3498db;">Phone:</strong> Added "${item.name}" with Lamport timestamp T=${item.timestamp}. <span style="color: var(--warning-color);">Not yet synced!</span>`;
                        }

                        function addItemLaptop() {
                            laptopClock++;
                            const item = { name: items[itemIndex % items.length], timestamp: laptopClock, device: 'laptop' };
                            laptopCart.push(item);
                            itemIndex++;
                            updateDisplay();
                            explanation.innerHTML = `<strong style="color: #e74c3c;">Laptop:</strong> Added "${item.name}" with Lamport timestamp T=${item.timestamp}. <span style="color: var(--warning-color);">Not yet synced!</span>`;
                        }

                        function syncDevices() {
                            if (phoneCart.length === 0 && laptopCart.length === 0) {
                                explanation.innerHTML = '<strong>Nothing to sync!</strong> Add items to both devices first.';
                                return;
                            }

                            // Merge carts using last-writer-wins (highest timestamp)
                            const allItems = [...phoneCart, ...laptopCart];

                            // Group by item name
                            const itemMap = new Map();
                            allItems.forEach(item => {
                                if (!itemMap.has(item.name) || itemMap.get(item.name).timestamp < item.timestamp) {
                                    itemMap.set(item.name, item);
                                }
                            });

                            const mergedCart = Array.from(itemMap.values()).sort((a, b) => a.timestamp - b.timestamp);

                            // Update both devices with merged cart
                            phoneCart = [...mergedCart];
                            laptopCart = [...mergedCart];

                            // Update clocks to max
                            const maxClock = Math.max(phoneClock, laptopClock);
                            phoneClock = maxClock;
                            laptopClock = maxClock;

                            updateDisplay();

                            const conflicts = allItems.length - mergedCart.length;
                            if (conflicts > 0) {
                                explanation.innerHTML = `
                                    <strong style="color: var(--success-color);">‚úì Synced!</strong><br>
                                    Resolved ${conflicts} conflict(s) using <strong>Last-Writer-Wins</strong> (highest Lamport timestamp).<br>
                                    Both devices now have the same ${mergedCart.length} item(s). Clocks synchronized to T=${maxClock}.
                                `;
                            } else {
                                explanation.innerHTML = `
                                    <strong style="color: var(--success-color);">‚úì Synced!</strong><br>
                                    No conflicts detected. Both devices merged successfully with ${mergedCart.length} item(s).
                                `;
                            }
                        }

                        function reset() {
                            phoneClock = 0;
                            laptopClock = 0;
                            phoneCart = [];
                            laptopCart = [];
                            itemIndex = 0;
                            updateDisplay();
                            explanation.innerHTML = '<strong>Shopping Cart with Eventual Consistency</strong><br>Add items on both devices to create conflicts. Then sync to see last-writer-wins resolution based on Lamport clocks!';
                        }

                        document.getElementById('addPhoneItem').addEventListener('click', addItemPhone);
                        document.getElementById('addLaptopItem').addEventListener('click', addItemLaptop);
                        document.getElementById('syncDevices').addEventListener('click', syncDevices);
                        document.getElementById('resetCart').addEventListener('click', reset);

                        updateDisplay();
                    })();
                </script>
            </div>
        </section>

        <section id="exam-questions">
            <h2>Part 8: Common Exam Questions and How to Answer Them</h2>

            <h3>Question Type 1: "Given this execution, assign Lamport clock values"</h3>
            <div class="callout-success">
                <p><strong>Strategy:</strong></p>
                <ol>
                    <li>Start all nodes at 0</li>
                    <li>Increment by 1 for each event</li>
                    <li>When sending, tag message with current clock</li>
                    <li>When receiving, set clock = max(current, received + 1)</li>
                    <li>Show work clearly with timestamps labeled</li>
                </ol>
            </div>

            <h3>Question Type 2: "Can this execution satisfy [consistency model]?"</h3>

            <p><strong>For Sequential Consistency:</strong></p>
            <ul>
                <li>Can you find ONE total order where:
                    <ul>
                        <li>All nodes' operations appear in program order?</li>
                        <li>Reads return values from most recent write in that order?</li>
                    </ul>
                </li>
            </ul>

            <p><strong>For Causal Consistency:</strong></p>
            <ul>
                <li>Build vector clocks</li>
                <li>Check if causally related operations are seen in the same order everywhere</li>
                <li>Concurrent operations can be seen in different orders</li>
            </ul>

            <p><strong>For Eventual Consistency:</strong></p>
            <ul>
                <li>If writes stop, do all nodes converge to same state?</li>
                <li>Answer is almost always YES unless there's a fundamental bug</li>
            </ul>

            <h3>Question Type 3: "Compare Lamport vs Vector clocks"</h3>
            <div class="callout-info">
                <p><strong>Structure your answer:</strong></p>
                <ol>
                    <li><strong>Similarity:</strong> Both are logical clocks that respect causality</li>
                    <li><strong>Difference in power:</strong> Vector clocks can detect concurrency, Lamport can't</li>
                    <li><strong>Trade-off:</strong> Lamport = less space/bandwidth, Vector = more information</li>
                    <li><strong>Use case distinction:</strong> Give examples of when you'd use each</li>
                </ol>
            </div>

            <h3>Question Type 4: "CAP theorem application"</h3>
            <div class="callout-success">
                <p><strong>Template:</strong></p>
                <ol>
                    <li>Identify the three properties</li>
                    <li>State which TWO can coexist (pick based on scenario)</li>
                    <li>Explain why the third is sacrificed</li>
                    <li>Give real-world example</li>
                </ol>
            </div>
        </section>

        <section id="memory-aids">
            <h2>Part 9: Memory Aids and Mnemonics</h2>

            <div class="callout-info">
                <h3>Lamport Clock Rules: "I-S-R"</h3>
                <ul>
                    <li><strong>I</strong>ncrement on every event</li>
                    <li><strong>S</strong>end with current timestamp</li>
                    <li><strong>R</strong>eceive: max(mine, theirs + 1)</li>
                </ul>
            </div>

            <div class="callout-info">
                <h3>Happened-Before: "Same, Send, or Sequence"</h3>
                <ul>
                    <li><strong>Same</strong> process, earlier in time</li>
                    <li><strong>Send</strong> ‚Üí Receive relationship</li>
                    <li><strong>Sequence</strong> (transitivity)</li>
                </ul>
            </div>

            <div class="callout-info">
                <h3>CAP Theorem: "Pick Your Poison"</h3>
                <ul>
                    <li><strong>C</strong>onsistency: "Same data everywhere"</li>
                    <li><strong>A</strong>vailability: "Always answering"</li>
                    <li><strong>P</strong>artition tolerance: "Working while split"</li>
                    <li>Remember: Real distributed systems need P, so choose between C and A</li>
                </ul>
            </div>

            <div class="callout-info">
                <h3>Eventual Consistency: "Stop and Settle"</h3>
                <ul>
                    <li><strong>Stop</strong> writing</li>
                    <li><strong>Settle</strong> into consistent state</li>
                    <li><strong>Eventually</strong> everyone agrees</li>
                </ul>
            </div>

            <div class="callout-info">
                <h3>Lamport vs Vector: "One-Way vs Two-Way Street"</h3>
                <ul>
                    <li>Lamport: happened-before ‚Üí smaller timestamp (one direction)</li>
                    <li>Vector: happened-before ‚Üî smaller vector (both directions)</li>
                </ul>
            </div>
        </section>

        <section id="practice-problems">
            <h2>Part 10: Practice Problems</h2>

            <h3>Problem 1: Lamport Clock Calculation</h3>
            <p>Given this execution:</p>
            <pre><code>N1: a ‚Üí b ‚Üí send_m1_to_N2 ‚Üí c
N2: x ‚Üí y ‚Üí receive_m1 ‚Üí send_m2_to_N3 ‚Üí z
N3: p ‚Üí receive_m2 ‚Üí q ‚Üí r</code></pre>

            <p><strong>Assignment:</strong> Label each event with its Lamport timestamp.</p>

            <details>
                <summary><strong>Click to show solution</strong></summary>
                <div class="callout-success">
                    <pre><code>N1: a(1) ‚Üí b(2) ‚Üí send_m1(3) ‚Üí c(4)
                  ‚Üì T=3
N2: x(1) ‚Üí y(2) ‚Üí receive_m1(4) ‚Üí send_m2(5) ‚Üí z(6)
                                  ‚Üì T=5
N3: p(1) ‚Üí receive_m2(6) ‚Üí q(7) ‚Üí r(8)</code></pre>
                </div>
            </details>

            <div class="visualization-container" style="background: white; border: 2px solid var(--secondary-color); border-radius: 10px; padding: 2rem; margin: 2rem 0;">
                <h3 style="color: var(--secondary-color); margin-top: 0;">üìä Visualization: Interactive Lamport Clock Practice</h3>
                <div style="margin: 20px 0;">
                    <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
                        <div>
                            <svg id="practiceSvg" width="100%" height="350" style="border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px;"></svg>
                            <div id="practiceInputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 15px;"></div>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                <button id="checkAnswers" style="background: var(--success-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                                    Check Answers
                                </button>
                                <button id="showSolution" style="background: var(--secondary-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                                    Show Solution
                                </button>
                                <button id="newProblem" style="background: var(--warning-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                                    New Problem
                                </button>
                            </div>
                        </div>
                        <div style="background: rgba(52, 152, 219, 0.1); padding: 15px; border-radius: 5px;">
                            <h4 style="margin: 0 0 10px 0; color: var(--primary-color);">Rules Reference</h4>
                            <ol style="font-size: 0.9em; margin: 0; padding-left: 20px;">
                                <li style="margin-bottom: 8px;">Each node starts at C=0</li>
                                <li style="margin-bottom: 8px;">Increment on every event: C = C + 1</li>
                                <li style="margin-bottom: 8px;">Send with current timestamp</li>
                                <li style="margin-bottom: 8px;">Receive: C = max(C, T_msg + 1)</li>
                            </ol>
                        </div>
                    </div>
                    <div id="practiceExplanation" style="margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 5px;">
                        <strong>Practice Problem:</strong> Calculate the Lamport clock values for each event. Enter your answers and check!
                    </div>
                </div>
                <script>
                    (function() {
                        const svg = document.getElementById('practiceSvg');
                        const inputsContainer = document.getElementById('practiceInputs');
                        const explanation = document.getElementById('practiceExplanation');
                        const checkBtn = document.getElementById('checkAnswers');
                        const solutionBtn = document.getElementById('showSolution');
                        const newBtn = document.getElementById('newProblem');

                        let currentProblem = null;
                        let userAnswers = {};

                        const problems = [
                            {
                                events: [
                                    {node: 1, label: 'a', x: 100, answer: 1},
                                    {node: 1, label: 'b', x: 200, answer: 2},
                                    {node: 1, label: 'send', x: 300, answer: 3, msgTo: 4, msgTimestamp: 3},
                                    {node: 2, label: 'x', x: 100, answer: 1},
                                    {node: 2, label: 'recv', x: 300, answer: 4},
                                    {node: 2, label: 'y', x: 400, answer: 5}
                                ]
                            },
                            {
                                events: [
                                    {node: 1, label: 'p', x: 100, answer: 1},
                                    {node: 1, label: 'send', x: 200, answer: 2, msgTo: 3, msgTimestamp: 2},
                                    {node: 2, label: 'q', x: 150, answer: 1},
                                    {node: 2, label: 'recv', x: 200, answer: 3},
                                    {node: 2, label: 'r', x: 300, answer: 4},
                                    {node: 2, label: 'send', x: 400, answer: 5, msgTo: 6, msgTimestamp: 5},
                                    {node: 3, label: 's', x: 250, answer: 1},
                                    {node: 3, label: 'recv', x: 400, answer: 6}
                                ]
                            },
                            {
                                events: [
                                    {node: 1, label: 'a', x: 120, answer: 1},
                                    {node: 1, label: 'b', x: 240, answer: 2},
                                    {node: 2, label: 'x', x: 100, answer: 1},
                                    {node: 2, label: 'y', x: 200, answer: 2},
                                    {node: 2, label: 'send', x: 300, answer: 3, msgTo: 5, msgTimestamp: 3},
                                    {node: 3, label: 'p', x: 150, answer: 1},
                                    {node: 3, label: 'recv', x: 300, answer: 4},
                                    {node: 3, label: 'q', x: 400, answer: 5}
                                ]
                            }
                        ];

                        function generateProblem() {
                            currentProblem = problems[Math.floor(Math.random() * problems.length)];
                            userAnswers = {};
                            drawProblem(false);
                            createInputs();
                            explanation.innerHTML = '<strong>Practice Problem:</strong> Calculate the Lamport clock values for each event. Enter your answers and check!';
                        }

                        function drawProblem(showAnswers) {
                            const width = svg.clientWidth || 500;
                            const height = 350;
                            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                            svg.innerHTML = '';

                            const nodeY = {1: 100, 2: 200, 3: 300};
                            const nodeColors = {1: '#3498db', 2: '#e74c3c', 3: '#27ae60'};

                            // Draw process lines
                            [1, 2, 3].forEach(n => {
                                const y = nodeY[n];
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', 50);
                                line.setAttribute('y1', y);
                                line.setAttribute('x2', width - 50);
                                line.setAttribute('y2', y);
                                line.setAttribute('stroke', '#bdc3c7');
                                line.setAttribute('stroke-width', '2');
                                svg.appendChild(line);

                                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                label.setAttribute('x', 20);
                                label.setAttribute('y', y + 5);
                                label.setAttribute('font-size', '14');
                                label.setAttribute('font-weight', 'bold');
                                label.setAttribute('fill', nodeColors[n]);
                                label.textContent = `N${n}`;
                                svg.appendChild(label);
                            });

                            // Draw messages
                            currentProblem.events.forEach((event, idx) => {
                                if (event.msgTo !== undefined) {
                                    const fromNode = event.node;
                                    const toNode = currentProblem.events[event.msgTo].node;
                                    const fromY = nodeY[fromNode];
                                    const toY = nodeY[toNode];

                                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                    line.setAttribute('x1', event.x);
                                    line.setAttribute('y1', fromY);
                                    line.setAttribute('x2', currentProblem.events[event.msgTo].x);
                                    line.setAttribute('y2', toY);
                                    line.setAttribute('stroke', '#f39c12');
                                    line.setAttribute('stroke-width', '2');
                                    line.setAttribute('stroke-dasharray', '5,5');
                                    svg.appendChild(line);
                                }
                            });

                            // Draw events
                            currentProblem.events.forEach((event, idx) => {
                                const y = nodeY[event.node];

                                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                circle.setAttribute('cx', event.x);
                                circle.setAttribute('cy', y);
                                circle.setAttribute('r', '15');
                                circle.setAttribute('fill', nodeColors[event.node]);
                                circle.setAttribute('stroke', '#2c3e50');
                                circle.setAttribute('stroke-width', '2');
                                svg.appendChild(circle);

                                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                text.setAttribute('x', event.x);
                                text.setAttribute('y', y - 25);
                                text.setAttribute('text-anchor', 'middle');
                                text.setAttribute('font-size', '12');
                                text.setAttribute('font-weight', 'bold');
                                text.textContent = event.label;
                                svg.appendChild(text);

                                if (showAnswers) {
                                    const answer = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                    answer.setAttribute('x', event.x);
                                    answer.setAttribute('y', y + 30);
                                    answer.setAttribute('text-anchor', 'middle');
                                    answer.setAttribute('font-size', '14');
                                    answer.setAttribute('font-weight', 'bold');
                                    answer.setAttribute('fill', nodeColors[event.node]);
                                    answer.textContent = event.answer;
                                    svg.appendChild(answer);
                                }
                            });
                        }

                        function createInputs() {
                            inputsContainer.innerHTML = '';
                            currentProblem.events.forEach((event, idx) => {
                                const inputDiv = document.createElement('div');
                                inputDiv.style.cssText = 'display: flex; align-items: center; gap: 5px;';
                                inputDiv.innerHTML = `
                                    <label style="font-weight: bold; min-width: 60px;">N${event.node}.${event.label}:</label>
                                    <input type="number" id="input-${idx}" min="0" max="99"
                                           style="width: 60px; padding: 5px; border: 1px solid #bdc3c7; border-radius: 3px;"
                                           placeholder="?">
                                `;
                                inputsContainer.appendChild(inputDiv);

                                document.getElementById(`input-${idx}`).addEventListener('change', (e) => {
                                    userAnswers[idx] = parseInt(e.target.value);
                                });
                            });
                        }

                        function checkAnswers() {
                            let correct = 0;
                            let total = currentProblem.events.length;

                            currentProblem.events.forEach((event, idx) => {
                                const input = document.getElementById(`input-${idx}`);
                                const userAnswer = parseInt(input.value);

                                if (userAnswer === event.answer) {
                                    input.style.borderColor = '#27ae60';
                                    input.style.background = 'rgba(39, 174, 96, 0.1)';
                                    correct++;
                                } else {
                                    input.style.borderColor = '#e74c3c';
                                    input.style.background = 'rgba(231, 76, 60, 0.1)';
                                }
                            });

                            if (correct === total) {
                                explanation.innerHTML = `<strong style="color: var(--success-color);">üéâ Perfect! All ${correct} answers correct!</strong><br>Great job understanding Lamport clocks!`;
                            } else {
                                explanation.innerHTML = `<strong>Score: ${correct}/${total}</strong><br>Review the incorrect answers (highlighted in red) and try again, or click "Show Solution".`;
                            }
                        }

                        function showSolution() {
                            drawProblem(true);
                            currentProblem.events.forEach((event, idx) => {
                                const input = document.getElementById(`input-${idx}`);
                                input.value = event.answer;
                                input.style.borderColor = '#27ae60';
                                input.style.background = 'rgba(39, 174, 96, 0.1)';
                            });
                            explanation.innerHTML = '<strong style="color: var(--secondary-color);">Solution displayed!</strong><br>Study the correct timestamps and try a new problem to practice.';
                        }

                        checkBtn.addEventListener('click', checkAnswers);
                        solutionBtn.addEventListener('click', showSolution);
                        newBtn.addEventListener('click', generateProblem);

                        generateProblem();
                    })();
                </script>
            </div>

            <h3>Problem 2: Concurrent Events</h3>
            <p>Using the Lamport timestamps from Problem 1, which events are concurrent?</p>

            <details>
                <summary><strong>Click to show solution</strong></summary>
                <div class="callout-success">
                    <ul>
                        <li>Event b (T=2) at N1 and event x (T=1) at N2: CONCURRENT (no communication)</li>
                        <li>Event b (T=2) at N1 and event y (T=2) at N2: CONCURRENT (same timestamp, different nodes)</li>
                        <li>Event c (T=4) at N1 and event p (T=1) at N3: CONCURRENT (no communication path)</li>
                    </ul>
                    <p><strong>Remember:</strong> With Lamport clocks, if T(a) &lt; T(b), we can't definitively say if concurrent or causal!</p>
                </div>
            </details>

            <h3>Problem 3: CAP Classification</h3>
            <p>Classify these scenarios:</p>

            <p><strong>a) Banking system that blocks transactions during network issues</strong></p>
            <details>
                <summary><strong>Click to show answer</strong></summary>
                <div class="callout-success">
                    <p>Answer: CP (Consistency + Partition tolerance)</p>
                    <p>Chooses consistency over availability</p>
                </div>
            </details>

            <p><strong>b) Shopping cart that always shows some version of cart contents</strong></p>
            <details>
                <summary><strong>Click to show answer</strong></summary>
                <div class="callout-success">
                    <p>Answer: AP (Availability + Partition tolerance)</p>
                    <p>Chooses availability over perfect consistency</p>
                </div>
            </details>

            <p><strong>c) Single-machine database with ACID transactions</strong></p>
            <details>
                <summary><strong>Click to show answer</strong></summary>
                <div class="callout-success">
                    <p>Answer: CA (Consistency + Availability)</p>
                    <p>No partitions because it's not distributed</p>
                </div>
            </details>
        </section>

        <section id="key-takeaways">
            <h2>Key Takeaways</h2>

            <div class="callout-success">
                <ol>
                    <li><strong>Lamport clocks</strong> give us a simple way to order events that respects causality (in one direction)</li>
                    <li><strong>Happened-before</strong> is about potential causality, not actual time</li>
                    <li><strong>Vector clocks</strong> are more powerful than Lamport clocks but cost more space</li>
                    <li><strong>Eventual consistency</strong> is the weakest model - only guarantees convergence when writes stop</li>
                    <li><strong>CAP theorem</strong> forces us to choose: in practice, it's usually CP vs AP (we need P for distributed systems)</li>
                    <li><strong>No one tool solves everything</strong> - Lamport clocks help with ordering but don't enforce consistency models</li>
                </ol>
            </div>
        </section>

        <section id="exam-tips">
            <h2>Final Exam Tips</h2>

            <div class="callout-info">
                <ol>
                    <li><strong>Draw diagrams</strong> - Timeline diagrams with messages help visualize causality</li>
                    <li><strong>Show your work</strong> - When calculating Lamport clocks, show each step</li>
                    <li><strong>Definitions matter</strong> - Know precise definitions of happened-before, consistency models, CAP properties</li>
                    <li><strong>Think about trade-offs</strong> - Why would someone choose eventual over sequential consistency? (Performance, availability!)</li>
                    <li><strong>Real-world examples</strong> - Being able to map concepts to systems like Amazon, Google, banks helps understanding</li>
                    <li><strong>Practice with edge cases</strong> - What if messages arrive out of order? What if clocks are equal?</li>
                </ol>
            </div>

            <div class="callout-success">
                <p><strong>Good luck with your exam!</strong> Remember: distributed systems is all about making trade-offs in the face of uncertainty. Understanding WHY we make these choices is just as important as knowing HOW the algorithms work.</p>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CS 416 Study Guide | Distributed Systems</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>
