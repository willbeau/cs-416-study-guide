<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin | CS 416 Study Guide</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>Bitcoin</h1>
            <p>CS 416 Study Guide - Topic 09</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="01-byzantine-fault-tolerance.html">Byzantine Fault Tolerance</a></li>
                <li><a href="02-sequential-consistency.html">Sequential Consistency</a></li>
                <li><a href="03-causal-consistency.html">Causal Consistency</a></li>
                <li><a href="04-file-sync-vector-time.html">File Sync & Vector Time</a></li>
                <li><a href="05-lamport-clocks-eventual.html">Lamport Clocks</a></li>
                <li><a href="06-mutual-exclusion.html">Mutual Exclusion</a></li>
                <li><a href="07-distributed-snapshots.html">Distributed Snapshots</a></li>
                <li><a href="08-chord-dht.html">Chord DHT</a></li>
                <li><a href="09-bitcoin.html">Bitcoin</a></li>
                <li><a href="10-practice-questions.html">Practice Questions</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <h2>The Big Picture: Bitcoin as a Distributed System</h2>

        <h3>What Problem is Bitcoin Solving?</h3>
        <p>Imagine trying to create digital money without a central authority (no banks, no governments). You face three fundamental challenges:</p>

        <ol>
            <li><strong>Who decides what's valid?</strong> (No central authority)</li>
            <li><strong>How do you prevent copying money?</strong> (Double-spending)</li>
            <li><strong>How do you agree on history?</strong> (Consensus with untrusted parties)</li>
        </ol>

        <div class="callout-success">
            <h4>Bitcoin's Innovation</h4>
            <p>A distributed system where thousands of untrusted machines collectively maintain a single, agreed-upon history of all transactions.</p>
        </div>

        <h3>Real-World Analogy: The Town Ledger</h3>
        <p>Think of Bitcoin like a small town where everyone distrusts each other:</p>

        <ul>
            <li><strong>Traditional bank:</strong> One trusted person keeps the ledger, everyone trusts them</li>
            <li><strong>Bitcoin:</strong> Everyone has a copy of the ledger, and they constantly check each other</li>
            <li><strong>New transaction:</strong> Someone shouts "I'm paying Bob 5 coins!"</li>
            <li><strong>Validation:</strong> Everyone checks: "Does Alice really have 5 coins? Has she already spent them?"</li>
            <li><strong>Agreement:</strong> Whoever solves a hard puzzle first gets to write down a page of transactions</li>
            <li><strong>Permanent record:</strong> That page is glued onto everyone's ledger permanently</li>
        </ul>

        <p>The genius? No one person controls the ledger, yet everyone agrees on its contents!</p>

        <div class="visualization-container">
            <h3>ğŸ“Š Visualization: Bitcoin Town Ledger Analogy</h3>
            <div id="townLedger" style="position: relative; width: 100%; height: 600px; background: linear-gradient(to bottom, var(--background-color), #f0f4f8); border-radius: 8px; overflow: hidden;">
                <svg width="100%" height="100%" id="townLedgerSvg"></svg>
                <div style="position: absolute; top: 20px; left: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 250px;">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px;">Ledger Pages</h4>
                    <div id="ledgerPages" style="font-family: monospace; font-size: 11px;"></div>
                </div>
                <button id="startTownDemo" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: var(--primary-color); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Start Transaction Demo</button>
            </div>
            <script>
            (function() {
                const svg = d3.select('#townLedgerSvg');
                const width = document.getElementById('townLedger').clientWidth;
                const height = 600;

                const nodes = [
                    {id: 'alice', x: 150, y: 300, name: 'Alice', color: '#3498db', role: 'sender'},
                    {id: 'bob', x: width - 150, y: 300, name: 'Bob', color: '#2ecc71', role: 'receiver'},
                    {id: 'validator1', x: width/2 - 100, y: 150, name: 'Validator 1', color: '#f39c12', role: 'validator'},
                    {id: 'validator2', x: width/2 + 100, y: 150, name: 'Validator 2', color: '#f39c12', role: 'validator'},
                    {id: 'miner', x: width/2, y: 450, name: 'Miner', color: '#9b59b6', role: 'miner'},
                    {id: 'validator3', x: width/2 - 100, y: 450, name: 'Validator 3', color: '#f39c12', role: 'validator'},
                    {id: 'validator4', x: width/2 + 100, y: 450, name: 'Validator 4', color: '#f39c12', role: 'validator'}
                ];

                let ledgerPages = [];
                let currentPhase = 0;

                // Draw nodes
                const nodeGroups = svg.selectAll('.node')
                    .data(nodes)
                    .enter()
                    .append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.x},${d.y})`);

                nodeGroups.append('circle')
                    .attr('r', 30)
                    .attr('fill', d => d.color)
                    .attr('stroke', 'white')
                    .attr('stroke-width', 3);

                nodeGroups.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', 45)
                    .attr('fill', '#2c3e50')
                    .style('font-weight', 'bold')
                    .style('font-size', '12px')
                    .text(d => d.name);

                // Ledger icon
                nodeGroups.append('rect')
                    .attr('class', 'ledger')
                    .attr('x', -12)
                    .attr('y', -10)
                    .attr('width', 24)
                    .attr('height', 20)
                    .attr('fill', 'white')
                    .attr('opacity', 0.9)
                    .attr('rx', 2);

                function updateLedger() {
                    const ledgerDiv = document.getElementById('ledgerPages');
                    ledgerDiv.innerHTML = ledgerPages.map((page, i) =>
                        `<div style="margin: 5px 0; padding: 5px; background: #ecf0f1; border-radius: 4px;">
                            Page ${i + 1}: ${page}
                        </div>`
                    ).join('');
                }

                function animatePhase(phase) {
                    svg.selectAll('.announcement, .validation-check, .puzzle-sparkle, .ledger-update').remove();

                    if (phase === 1) {
                        // Phase 1: Announcement
                        const announcement = svg.append('g').attr('class', 'announcement');
                        announcement.append('ellipse')
                            .attr('cx', 150)
                            .attr('cy', 250)
                            .attr('rx', 0)
                            .attr('ry', 0)
                            .attr('fill', 'none')
                            .attr('stroke', '#3498db')
                            .attr('stroke-width', 2)
                            .transition()
                            .duration(1500)
                            .attr('rx', 200)
                            .attr('ry', 100)
                            .attr('opacity', 0);

                        announcement.append('text')
                            .attr('x', 150)
                            .attr('y', 220)
                            .attr('text-anchor', 'middle')
                            .attr('fill', '#3498db')
                            .style('font-weight', 'bold')
                            .style('font-size', '14px')
                            .text("I'm paying Bob 5 coins!")
                            .attr('opacity', 0)
                            .transition()
                            .duration(500)
                            .attr('opacity', 1);

                    } else if (phase === 2) {
                        // Phase 2: Validation
                        nodes.filter(n => n.role === 'validator' || n.role === 'miner').forEach((node, i) => {
                            setTimeout(() => {
                                svg.append('text')
                                    .attr('class', 'validation-check')
                                    .attr('x', node.x)
                                    .attr('y', node.y - 40)
                                    .attr('text-anchor', 'middle')
                                    .attr('fill', '#2ecc71')
                                    .style('font-size', '24px')
                                    .style('font-weight', 'bold')
                                    .text('âœ“')
                                    .attr('opacity', 0)
                                    .transition()
                                    .duration(500)
                                    .attr('opacity', 1);
                            }, i * 300);
                        });

                    } else if (phase === 3) {
                        // Phase 3: Puzzle solving
                        const miner = nodes.find(n => n.role === 'miner');
                        for (let i = 0; i < 20; i++) {
                            setTimeout(() => {
                                svg.append('circle')
                                    .attr('class', 'puzzle-sparkle')
                                    .attr('cx', miner.x + (Math.random() - 0.5) * 60)
                                    .attr('cy', miner.y + (Math.random() - 0.5) * 60)
                                    .attr('r', 3)
                                    .attr('fill', '#9b59b6')
                                    .transition()
                                    .duration(1000)
                                    .attr('r', 0)
                                    .attr('opacity', 0)
                                    .remove();
                            }, i * 100);
                        }

                        setTimeout(() => {
                            svg.append('text')
                                .attr('class', 'puzzle-sparkle')
                                .attr('x', miner.x)
                                .attr('y', miner.y - 50)
                                .attr('text-anchor', 'middle')
                                .attr('fill', '#9b59b6')
                                .style('font-weight', 'bold')
                                .style('font-size', '16px')
                                .text('Puzzle Solved!')
                                .attr('opacity', 0)
                                .transition()
                                .duration(500)
                                .attr('opacity', 1);
                        }, 2000);

                    } else if (phase === 4) {
                        // Phase 4: Ledger update
                        ledgerPages.push('Alice â†’ Bob: 5 coins');
                        updateLedger();

                        nodes.forEach((node, i) => {
                            setTimeout(() => {
                                svg.append('circle')
                                    .attr('class', 'ledger-update')
                                    .attr('cx', node.x)
                                    .attr('cy', node.y)
                                    .attr('r', 30)
                                    .attr('fill', 'none')
                                    .attr('stroke', '#2ecc71')
                                    .attr('stroke-width', 3)
                                    .transition()
                                    .duration(1000)
                                    .attr('r', 50)
                                    .attr('opacity', 0)
                                    .remove();
                            }, i * 200);
                        });
                    }
                }

                document.getElementById('startTownDemo').addEventListener('click', function() {
                    ledgerPages = ['Genesis: Alice has 5 coins'];
                    updateLedger();
                    currentPhase = 0;

                    const phases = [1, 2, 3, 4];
                    phases.forEach((phase, i) => {
                        setTimeout(() => {
                            animatePhase(phase);
                        }, i * 3000);
                    });
                });

                // Initial state
                ledgerPages = ['Genesis: Alice has 5 coins'];
                updateLedger();
            })();
            </script>
        </div>

        <h3>Bitcoin as a Distributed System: Key Properties</h3>
        <div class="callout-info">
            <h4>Memory Aid: "DEPEND"</h4>
            <ul>
                <li><strong>D</strong>ecentralized: No central authority</li>
                <li><strong>E</strong>ventually consistent: All nodes converge to same history</li>
                <li><strong>P</strong>eer-to-peer: Direct node-to-node communication</li>
                <li><strong>E</strong>conomic incentives: Game theory ensures honesty</li>
                <li><strong>N</strong>o trusted parties: Byzantine fault tolerance</li>
                <li><strong>D</strong>eterministic ordering: Blockchain provides total order</li>
            </ul>
        </div>

        <h2>The Double-Spending Problem</h2>

        <h3>What is Double-Spending?</h3>
        <p><strong>The core problem:</strong> Digital money is just data. Data can be copied!</p>

        <pre><code>Alice has 1 Bitcoin
Alice's wallet file: "Address: 1A2B, Balance: 1 BTC"

Alice copies the file â†’ Now she has "2 Bitcoins"? NO!</code></pre>

        <p><strong>Why it's hard:</strong> In a distributed system, Alice could simultaneously send the same Bitcoin to both Bob and Charlie:</p>

        <pre><code>Time: 10:00:00.000 â†’ Alice sends 1 BTC to Bob
Time: 10:00:00.001 â†’ Alice sends same 1 BTC to Charlie

Different nodes might see different orders!
Node 1 sees: Bob paid first  âœ“
Node 2 sees: Charlie paid first âœ“

Which one is real? Who decides?</code></pre>

        <div class="visualization-container">
            <h3>ğŸ“Š Visualization: Double-Spending Problem</h3>
            <div id="doubleSpend" style="position: relative; width: 100%; height: 500px; background: var(--background-color); border-radius: 8px; overflow: hidden;">
                <canvas id="doubleSpendCanvas" width="1000" height="500"></canvas>
                <div style="position: absolute; top: 20px; right: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px;">Network State</h4>
                    <div id="networkState" style="font-size: 12px;"></div>
                </div>
                <button id="startDoubleSpend" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: var(--accent-color); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Simulate Double-Spend</button>
            </div>
            <script>
            (function() {
                const canvas = document.getElementById('doubleSpendCanvas');
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                class Node {
                    constructor(x, y, opinion) {
                        this.x = x;
                        this.y = y;
                        this.opinion = opinion; // 'bob', 'charlie', or 'none'
                        this.size = 15;
                    }

                    draw() {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        if (this.opinion === 'bob') {
                            ctx.fillStyle = '#2ecc71';
                        } else if (this.opinion === 'charlie') {
                            ctx.fillStyle = '#e74c3c';
                        } else {
                            ctx.fillStyle = '#95a5a6';
                        }
                        ctx.fill();
                        ctx.strokeStyle = '#34495e';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }

                const nodes = [];
                for (let i = 0; i < 30; i++) {
                    const x = 100 + Math.random() * (width - 200);
                    const y = 100 + Math.random() * (height - 200);
                    nodes.push(new Node(x, y, 'none'));
                }

                function drawAlice() {
                    ctx.beginPath();
                    ctx.arc(width / 2, height / 2, 30, 0, Math.PI * 2);
                    ctx.fillStyle = '#3498db';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Alice', width / 2, height / 2 + 5);
                    ctx.fillText('1 BTC', width / 2, height / 2 + 50);
                }

                function drawBob() {
                    ctx.beginPath();
                    ctx.arc(150, 100, 25, 0, Math.PI * 2);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Bob', 150, 105);
                }

                function drawCharlie() {
                    ctx.beginPath();
                    ctx.arc(width - 150, 100, 25, 0, Math.PI * 2);
                    ctx.fillStyle = '#e74c3c';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Charlie', width - 150, 105);
                }

                function drawArrow(fromX, fromY, toX, toY, color, label, offset = 0) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    const angle = Math.atan2(toY - fromY, toX - fromX);
                    const adjustedFromX = fromX + Math.cos(angle) * 35;
                    const adjustedFromY = fromY + Math.sin(angle) * 35;
                    const adjustedToX = toX - Math.cos(angle) * 30;
                    const adjustedToY = toY - Math.sin(angle) * 30;

                    ctx.moveTo(adjustedFromX, adjustedFromY);
                    ctx.lineTo(adjustedToX, adjustedToY);
                    ctx.stroke();

                    // Arrow head
                    ctx.setLineDash([]);
                    const headlen = 15;
                    ctx.beginPath();
                    ctx.moveTo(adjustedToX, adjustedToY);
                    ctx.lineTo(adjustedToX - headlen * Math.cos(angle - Math.PI / 6), adjustedToY - headlen * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(adjustedToX - headlen * Math.cos(angle + Math.PI / 6), adjustedToY - headlen * Math.sin(angle + Math.PI / 6));
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();

                    // Label
                    const midX = (adjustedFromX + adjustedToX) / 2;
                    const midY = (adjustedFromY + adjustedToY) / 2;
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 11px Arial';
                    ctx.fillText(label, midX, midY - 10);
                }

                function updateNetworkState() {
                    const bobCount = nodes.filter(n => n.opinion === 'bob').length;
                    const charlieCount = nodes.filter(n => n.opinion === 'charlie').length;
                    document.getElementById('networkState').innerHTML = `
                        <div style="margin: 5px 0;"><span style="color: #2ecc71;">â—</span> Bob paid first: ${bobCount} nodes</div>
                        <div style="margin: 5px 0;"><span style="color: #e74c3c;">â—</span> Charlie paid first: ${charlieCount} nodes</div>
                        <div style="margin: 10px 0; padding-top: 10px; border-top: 1px solid #ddd; font-weight: bold; color: #e74c3c;">âš  CONFLICT!</div>
                    `;
                }

                function animate() {
                    ctx.clearRect(0, 0, width, height);

                    // Draw network nodes
                    nodes.forEach(node => node.draw());

                    // Draw main actors
                    drawAlice();
                    drawBob();
                    drawCharlie();

                    requestAnimationFrame(animate);
                }

                document.getElementById('startDoubleSpend').addEventListener('click', function() {
                    // Reset
                    nodes.forEach(n => n.opinion = 'none');

                    // Draw transactions
                    setTimeout(() => {
                        drawArrow(width/2, height/2, 150, 100, '#2ecc71', 'T=0: 1 BTC');
                    }, 500);

                    setTimeout(() => {
                        drawArrow(width/2, height/2, width - 150, 100, '#e74c3c', 'T=0.001: 1 BTC');
                    }, 1000);

                    // Spread opinions
                    setTimeout(() => {
                        nodes.forEach((node, i) => {
                            setTimeout(() => {
                                node.opinion = Math.random() > 0.5 ? 'bob' : 'charlie';
                                updateNetworkState();
                            }, i * 100);
                        });
                    }, 1500);
                });

                animate();
                updateNetworkState();
            })();
            </script>
        </div>

        <h3>Traditional Solutions (and Why They Fail for Bitcoin)</h3>

        <div class="callout-warning">
            <h4>Solution 1: Trusted central server</h4>
            <pre><code>All transactions go through bank â†’ Bank decides order
Problem: Requires trust, single point of failure
Bitcoin's goal: Remove trusted parties!</code></pre>
        </div>

        <div class="callout-warning">
            <h4>Solution 2: Lamport clocks / Vector clocks</h4>
            <pre><code>Give each transaction a logical timestamp
Problem: Assumes nodes aren't malicious!
Byzantine nodes can lie about timestamps</code></pre>
        </div>

        <div class="callout-warning">
            <h4>Solution 3: Distributed consensus (Paxos/Raft)</h4>
            <pre><code>Nodes vote on which transaction came first
Problem: Assumes you know all participants!
Bitcoin: Anyone can join/leave freely (permissionless)</code></pre>
        </div>

        <h3>Bitcoin's Solution: The Blockchain</h3>
        <p><strong>Core Insight:</strong> Create a chain of transactions where:</p>
        <ol>
            <li>Each block contains many transactions</li>
            <li>Blocks are cryptographically linked (can't modify history)</li>
            <li>Creating blocks is computationally expensive (prevents spam)</li>
            <li>Longest chain wins (economic majority decides)</li>
        </ol>

        <p><strong>Why this prevents double-spending:</strong></p>
        <pre><code>Block 100: Alice receives 1 BTC
Block 101: Alice pays Bob 1 BTC âœ“ (written to blockchain)
Block 102: Alice tries to pay Charlie same 1 BTC âœ—

Rejection reason: Block 101 already spent that output!
The blockchain provides a single, ordered history.</code></pre>

        <h2>Blockchain Structure: The Distributed Ledger</h2>

        <h3>Anatomy of a Block</h3>
        <p>Think of a block as a page in a ledger with special tamper-proof properties:</p>

        <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BLOCK HEADER                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Previous Block Hash: 0x7A3F... (256bit)â”‚ â† Links to previous block
â”‚ Merkle Root: 0x9B2E... (256 bit)       â”‚ â† Summary of all transactions
â”‚ Timestamp: 2025-12-08 10:30:45         â”‚
â”‚ Difficulty Target: 0x1D00FFFF          â”‚ â† How hard the puzzle is
â”‚ Nonce: 2,847,392,847                   â”‚ â† The "answer" to the puzzle
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TRANSACTIONS (~4,000 per block)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TX 1: Alice â†’ Bob: 0.5 BTC             â”‚
â”‚ TX 2: Charlie â†’ Dave: 1.2 BTC          â”‚
â”‚ TX 3: Eve â†’ Frank: 0.3 BTC             â”‚
â”‚ ... (~3,997 more transactions)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

        <div class="visualization-container">
            <h3>ğŸ“Š Visualization: Block Anatomy</h3>
            <div id="blockAnatomy" style="position: relative; width: 100%; min-height: 600px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; padding: 20px;">
                <svg width="100%" height="600" id="blockAnatomySvg"></svg>
                <div id="fieldDetail" style="position: absolute; top: 20px; right: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); max-width: 300px; display: none;"></div>
            </div>
            <script>
            (function() {
                const svg = d3.select('#blockAnatomySvg');
                const width = document.getElementById('blockAnatomy').clientWidth - 40;
                const blockWidth = Math.min(500, width * 0.8);
                const centerX = width / 2;

                const blockFields = [
                    {name: 'Previous Block Hash', value: '0x7A3F2B1C...', y: 80, color: '#e74c3c', desc: 'Links to the previous block, creating the chain. Changing any previous block would break this link.'},
                    {name: 'Merkle Root', value: '0x9B2E7F4A...', y: 130, color: '#3498db', desc: 'Hash of all transactions in this block. Allows efficient verification of transaction inclusion.'},
                    {name: 'Timestamp', value: '2025-12-08 10:30:45', y: 180, color: '#2ecc71', desc: 'When this block was mined. Used for difficulty adjustment calculations.'},
                    {name: 'Difficulty Target', value: '0x1D00FFFF', y: 230, color: '#f39c12', desc: 'The target value the block hash must be less than. Adjusted every 2016 blocks.'},
                    {name: 'Nonce', value: '2,847,392,847', y: 280, color: '#9b59b6', desc: 'The number miners vary to find a valid hash. The "answer" to the proof-of-work puzzle.'}
                ];

                // Header section
                svg.append('rect')
                    .attr('x', centerX - blockWidth/2)
                    .attr('y', 20)
                    .attr('width', blockWidth)
                    .attr('height', 300)
                    .attr('fill', 'url(#headerGradient)')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 3)
                    .attr('rx', 8);

                svg.append('defs').append('linearGradient')
                    .attr('id', 'headerGradient')
                    .attr('x1', '0%').attr('y1', '0%')
                    .attr('x2', '0%').attr('y2', '100%')
                    .selectAll('stop')
                    .data([
                        {offset: '0%', color: '#3498db'},
                        {offset: '100%', color: '#2980b9'}
                    ])
                    .enter().append('stop')
                    .attr('offset', d => d.offset)
                    .attr('stop-color', d => d.color);

                svg.append('text')
                    .attr('x', centerX)
                    .attr('y', 50)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .style('font-weight', 'bold')
                    .style('font-size', '18px')
                    .text('BLOCK HEADER');

                // Add fields
                blockFields.forEach(field => {
                    const g = svg.append('g')
                        .style('cursor', 'pointer')
                        .on('click', function() {
                            const detail = document.getElementById('fieldDetail');
                            detail.innerHTML = `
                                <h4 style="margin: 0 0 10px 0; color: ${field.color};">${field.name}</h4>
                                <div style="font-family: monospace; background: #ecf0f1; padding: 8px; border-radius: 4px; margin: 10px 0; font-size: 12px;">${field.value}</div>
                                <p style="margin: 10px 0 0 0; font-size: 13px; line-height: 1.5;">${field.desc}</p>
                            `;
                            detail.style.display = 'block';
                        });

                    g.append('rect')
                        .attr('x', centerX - blockWidth/2 + 10)
                        .attr('y', field.y - 15)
                        .attr('width', blockWidth - 20)
                        .attr('height', 35)
                        .attr('fill', 'rgba(255,255,255,0.15)')
                        .attr('stroke', field.color)
                        .attr('stroke-width', 2)
                        .attr('rx', 4);

                    g.append('text')
                        .attr('x', centerX - blockWidth/2 + 20)
                        .attr('y', field.y)
                        .attr('fill', 'white')
                        .style('font-weight', 'bold')
                        .style('font-size', '12px')
                        .text(field.name);

                    g.append('text')
                        .attr('x', centerX + blockWidth/2 - 20)
                        .attr('y', field.y)
                        .attr('text-anchor', 'end')
                        .attr('fill', field.color)
                        .style('font-family', 'monospace')
                        .style('font-size', '11px')
                        .text(field.value);
                });

                // Transactions section
                svg.append('rect')
                    .attr('x', centerX - blockWidth/2)
                    .attr('y', 340)
                    .attr('width', blockWidth)
                    .attr('height', 220)
                    .attr('fill', '#2ecc71')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 3)
                    .attr('rx', 8);

                svg.append('text')
                    .attr('x', centerX)
                    .attr('y', 370)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .style('font-weight', 'bold')
                    .style('font-size', '18px')
                    .text('TRANSACTIONS (~4,000)');

                // Sample transactions
                const txSamples = [
                    'TX 1: Alice â†’ Bob: 0.5 BTC',
                    'TX 2: Charlie â†’ Dave: 1.2 BTC',
                    'TX 3: Eve â†’ Frank: 0.3 BTC',
                    '...',
                    'TX 3,999: User A â†’ User B: 0.1 BTC',
                    'TX 4,000: User C â†’ User D: 2.5 BTC'
                ];

                txSamples.forEach((tx, i) => {
                    svg.append('text')
                        .attr('x', centerX - blockWidth/2 + 20)
                        .attr('y', 400 + i * 25)
                        .attr('fill', 'white')
                        .style('font-family', 'monospace')
                        .style('font-size', '11px')
                        .text(tx);
                });

                // Arrow from previous hash pointing left
                svg.append('defs').append('marker')
                    .attr('id', 'arrowhead')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 10)
                    .attr('refX', 5)
                    .attr('refY', 3)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 10 3, 0 6')
                    .attr('fill', '#e74c3c');

                svg.append('line')
                    .attr('x1', centerX - blockWidth/2)
                    .attr('y1', 80)
                    .attr('x2', centerX - blockWidth/2 - 60)
                    .attr('y2', 80)
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 3)
                    .attr('marker-end', 'url(#arrowhead)');

                svg.append('text')
                    .attr('x', centerX - blockWidth/2 - 100)
                    .attr('y', 75)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#e74c3c')
                    .style('font-size', '11px')
                    .style('font-weight', 'bold')
                    .text('Previous');

                svg.append('text')
                    .attr('x', centerX - blockWidth/2 - 100)
                    .attr('y', 90)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#e74c3c')
                    .style('font-size', '11px')
                    .style('font-weight', 'bold')
                    .text('Block');

                // Click instruction
                svg.append('text')
                    .attr('x', centerX)
                    .attr('y', 590)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .style('font-size', '12px')
                    .style('font-style', 'italic')
                    .text('Click on any field to see details');
            })();
            </script>
        </div>

        <h3>The Chain: Cryptographic Linking</h3>
        <p><strong>Key Property:</strong> Each block contains the hash of the previous block!</p>

        <pre><code>Block N-1          Block N            Block N+1
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Hash:  â”‚        â”‚ Prev:  â”‚         â”‚ Prev:  â”‚
â”‚ 0xAB12 â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”‚ 0xAB12 â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”‚ 0x3F7E â”‚
â”‚        â”‚        â”‚ Hash:  â”‚         â”‚ Hash:  â”‚
â”‚ ...    â”‚        â”‚ 0x3F7E â”‚         â”‚ 0x8C21 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

        <div class="callout-info">
            <h4>Why this matters:</h4>
            <ul>
                <li>Change any transaction in Block N â†’ Changes Block N's hash</li>
                <li>Block N+1 points to old hash â†’ Chain breaks!</li>
                <li>Must recalculate ALL subsequent blocks (computationally infeasible!)</li>
            </ul>
            <p><strong>Exam insight:</strong> This is why Bitcoin's history is immutable!</p>
        </div>

        <div class="visualization-container">
            <h3>ğŸ“Š Visualization: Blockchain Cryptographic Linking</h3>
            <div id="blockchainLinking" style="position: relative; width: 100%; height: 500px; background: var(--background-color); border-radius: 8px; padding: 20px; overflow-x: auto;">
                <svg width="1200" height="460" id="blockchainLinkingSvg"></svg>
                <div id="difficultyMeter" style="position: absolute; bottom: 20px; right: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px;">Computational Work Required</h4>
                    <div id="workDisplay" style="font-size: 12px;"></div>
                </div>
            </div>
            <script>
            (function() {
                const svg = d3.select('#blockchainLinkingSvg');
                const blocks = [
                    {id: 0, hash: '0xAB12', prev: '0x0000', x: 50, modified: false},
                    {id: 1, hash: '0xCD34', prev: '0xAB12', x: 250, modified: false},
                    {id: 2, hash: '0xEF56', prev: '0xCD34', x: 450, modified: false},
                    {id: 3, hash: '0x1234', prev: '0xEF56', x: 650, modified: false},
                    {id: 4, hash: '0x5678', prev: '0x1234', x: 850, modified: false},
                    {id: 5, hash: '0x9ABC', prev: '0x5678', x: 1050, modified: false}
                ];

                function drawBlocks() {
                    svg.selectAll('*').remove();

                    blocks.forEach((block, i) => {
                        const g = svg.append('g').attr('transform', `translate(${block.x}, 100)`);

                        // Block rectangle
                        g.append('rect')
                            .attr('width', 150)
                            .attr('height', 200)
                            .attr('fill', block.modified ? '#e74c3c' : '#3498db')
                            .attr('stroke', 'white')
                            .attr('stroke-width', 3)
                            .attr('rx', 8);

                        // Block number
                        g.append('text')
                            .attr('x', 75)
                            .attr('y', 30)
                            .attr('text-anchor', 'middle')
                            .attr('fill', 'white')
                            .style('font-weight', 'bold')
                            .style('font-size', '16px')
                            .text(`Block ${block.id}`);

                        // Hash
                        g.append('text')
                            .attr('x', 75)
                            .attr('y', 70)
                            .attr('text-anchor', 'middle')
                            .attr('fill', 'white')
                            .style('font-size', '11px')
                            .style('font-weight', 'bold')
                            .text('Hash:');

                        g.append('text')
                            .attr('x', 75)
                            .attr('y', 90)
                            .attr('text-anchor', 'middle')
                            .attr('fill', '#f39c12')
                            .style('font-family', 'monospace')
                            .style('font-size', '12px')
                            .text(block.hash);

                        // Previous hash
                        g.append('text')
                            .attr('x', 75)
                            .attr('y', 120)
                            .attr('text-anchor', 'middle')
                            .attr('fill', 'white')
                            .style('font-size', '11px')
                            .style('font-weight', 'bold')
                            .text('Prev Hash:');

                        g.append('text')
                            .attr('x', 75)
                            .attr('y', 140)
                            .attr('text-anchor', 'middle')
                            .attr('fill', '#2ecc71')
                            .style('font-family', 'monospace')
                            .style('font-size', '12px')
                            .text(block.prev);

                        // Modify button
                        const button = g.append('g')
                            .attr('cursor', 'pointer')
                            .on('click', () => modifyBlock(i));

                        button.append('rect')
                            .attr('x', 25)
                            .attr('y', 160)
                            .attr('width', 100)
                            .attr('height', 30)
                            .attr('fill', '#e74c3c')
                            .attr('rx', 4);

                        button.append('text')
                            .attr('x', 75)
                            .attr('y', 180)
                            .attr('text-anchor', 'middle')
                            .attr('fill', 'white')
                            .style('font-size', '11px')
                            .style('font-weight', 'bold')
                            .text('Modify TX');

                        // Arrow to next block
                        if (i < blocks.length - 1) {
                            const isValid = block.hash === blocks[i + 1].prev;
                            const arrow = svg.append('g');

                            arrow.append('line')
                                .attr('x1', block.x + 150)
                                .attr('y1', 240)
                                .attr('x2', blocks[i + 1].x)
                                .attr('y2', 240)
                                .attr('stroke', isValid ? '#2ecc71' : '#e74c3c')
                                .attr('stroke-width', 3)
                                .attr('marker-end', isValid ? 'url(#arrowValid)' : 'url(#arrowBroken)');

                            if (!isValid) {
                                // Show X for broken link
                                arrow.append('text')
                                    .attr('x', (block.x + 150 + blocks[i + 1].x) / 2)
                                    .attr('y', 220)
                                    .attr('text-anchor', 'middle')
                                    .attr('fill', '#e74c3c')
                                    .style('font-size', '24px')
                                    .style('font-weight', 'bold')
                                    .text('âœ—');
                            }
                        }
                    });
                }

                // Define arrow markers
                svg.append('defs').append('marker')
                    .attr('id', 'arrowValid')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 10)
                    .attr('refX', 5)
                    .attr('refY', 3)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 10 3, 0 6')
                    .attr('fill', '#2ecc71');

                svg.append('defs').append('marker')
                    .attr('id', 'arrowBroken')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 10)
                    .attr('refX', 5)
                    .attr('refY', 3)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 10 3, 0 6')
                    .attr('fill', '#e74c3c');

                function modifyBlock(index) {
                    // Modify the block
                    blocks[index].modified = true;
                    blocks[index].hash = '0x' + Math.random().toString(16).substr(2, 4).toUpperCase();

                    // All subsequent blocks are now invalid
                    for (let i = index + 1; i < blocks.length; i++) {
                        blocks[i].modified = true;
                    }

                    drawBlocks();
                    updateDifficultyMeter(index);
                }

                function updateDifficultyMeter(modifiedIndex) {
                    const blocksToRecalc = blocks.length - modifiedIndex;
                    const work = Math.pow(2, blocksToRecalc * 10); // Exponential difficulty
                    document.getElementById('workDisplay').innerHTML = `
                        <div style="margin: 5px 0;"><strong>Blocks to recalculate:</strong> ${blocksToRecalc}</div>
                        <div style="margin: 5px 0;"><strong>Estimated hashes:</strong> ~${work.toExponential(2)}</div>
                        <div style="margin: 10px 0; padding: 10px; background: #ffe6e6; border-radius: 4px; font-weight: bold; color: #e74c3c;">
                            ${blocksToRecalc === 1 ? 'Feasible' : blocksToRecalc <= 3 ? 'Very Difficult' : 'Computationally Infeasible!'}
                        </div>
                    `;
                }

                drawBlocks();
                updateDifficultyMeter(6); // Initial state
            })();
            </script>
        </div>

        <h3>Merkle Trees: Efficient Transaction Verification</h3>
        <p><strong>Problem:</strong> A block has ~4,000 transactions. How to efficiently verify "Is transaction X in this block?"</p>

        <p><strong>Solution:</strong> Organize transactions in a Merkle tree:</p>

        <pre><code>                    Root Hash (in block header)
                         â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         Hash 1-2                  Hash 3-4
            â”‚                          â”‚
       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    Hash 1    Hash 2          Hash 3    Hash 4
       â”‚         â”‚               â”‚         â”‚
     TX 1      TX 2            TX 3      TX 4</code></pre>

        <div class="callout-success">
            <h4>Verification</h4>
            <p>To prove TX 3 is in the block, provide:</p>
            <pre><code>TX 3 + Hash 4 + Hash 1-2 = Can compute Root Hash!
Only log(n) hashes needed (not all 4,000 transactions!)</code></pre>
            <p><strong>Memory Aid:</strong> "Merkle = Merkle-ous proof" (efficient proof of inclusion)</p>
        </div>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Merkle Tree Verification</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an interactive Merkle tree visualization with 8-16 transactions at the leaf level. Show the tree structure with hashes propagating up to the root. Include an interactive proof demonstration: let users select any transaction at the bottom, then highlight the "proof path" (the sibling hashes needed to verify that transaction). Animate the verification process showing how the selected transaction + sibling hashes are combined to compute the root hash. Display a counter showing "Proof size: 3 hashes" vs "Sending all transactions: 4,000 hashes". Use color coding: selected transaction (gold), proof path (green), non-required nodes (gray).</p>
            </div>
        </div>

        <h3>Blockchain as a Data Structure</h3>
        <p><strong>Key properties for distributed systems:</strong></p>

        <ol>
            <li><strong>Append-only:</strong> Can only add blocks, never remove</li>
            <li><strong>Tamper-evident:</strong> Any change to history is detectable</li>
            <li><strong>Distributed consensus:</strong> Longest chain = agreed history</li>
            <li><strong>No coordination required:</strong> Miners work independently</li>
        </ol>

        <p><strong>Compare to other distributed data structures:</strong></p>
        <pre><code>Array:      Fast access, but no tamper-proofing
Hash table: Fast lookup, but no ordering
Blockchain: Ordered + Tamper-proof, but append-only</code></pre>

        <h2>Proof of Work: Computational Consensus</h2>

        <h3>The Core Problem</h3>
        <p>In a distributed system with untrusted parties:</p>
        <ul>
            <li><strong>Anyone can join</strong> (permissionless)</li>
            <li><strong>Nodes might be Byzantine</strong> (lie, cheat, collude)</li>
            <li><strong>Need to agree on order</strong> (which transactions happened first)</li>
        </ul>

        <div class="callout-warning">
            <h4>Traditional solution (voting) fails:</h4>
            <pre><code>Majority vote decides order
Problem: Attacker creates 1 million fake nodes!
(Sybil attack: one person = many identities)</code></pre>
            <p><strong>Bitcoin's insight:</strong> Make voting expensive!</p>
            <ul>
                <li>Can't create fake nodes easily</li>
                <li>One CPU = One "vote" (approximately)</li>
            </ul>
        </div>

        <h3>What is Proof of Work?</h3>
        <p><strong>Simple explanation:</strong> Solve a computationally hard puzzle to earn the right to create the next block.</p>

        <p><strong>The puzzle:</strong> Find a nonce such that hash(block header) < target</p>

        <pre><code># Pseudocode for mining
def mine_block(transactions, prev_hash, target):
    nonce = 0
    while True:
        header = create_header(transactions, prev_hash, nonce)
        hash_result = SHA256(SHA256(header))  # Double SHA-256

        if hash_result < target:
            return Block(header, transactions)  # Success!

        nonce += 1  # Try next nonce</code></pre>

        <p><strong>Concrete example:</strong></p>
        <pre><code>Target: 0x0000FFFF... (must start with 4 zeros in hex)

Try nonce=1:  Hash = 0x8A3F... âœ— (too large)
Try nonce=2:  Hash = 0x7B2E... âœ— (too large)
...
Try nonce=2,847,392,847: Hash = 0x0000AB12... âœ“ (Success!)</code></pre>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Proof of Work Mining Process</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an animated visualization of the mining process. Show a block header with a nonce counter that increments rapidly (animate with blur effect to show speed). For each nonce, show the resulting hash value being compared to a target line (difficulty threshold). Most hashes should appear above the target (red, invalid) with occasional ones getting close. When a valid nonce is found, show the hash drop below the target line (green, valid) and celebrate with a "Block Found!" animation. Include a counter showing "Attempts: 2,847,392,847" and "Time elapsed: 10 minutes". Show the difficulty target as an adjustable slider that users can move to see how it affects the number of attempts needed.</p>
            </div>
        </div>

        <h3>Why SHA-256 Hashing?</h3>
        <p><strong>Properties that matter:</strong></p>

        <ol>
            <li><strong>Deterministic:</strong> Same input â†’ Same output (always)</li>
            <li><strong>Fast to compute:</strong> One direction is quick</li>
            <li><strong>Preimage resistant:</strong> Given hash, can't find input (hard to reverse)</li>
            <li><strong>Avalanche effect:</strong> Change 1 bit in input â†’ ~50% of output bits change</li>
            <li><strong>Uniform distribution:</strong> Hash outputs look random</li>
        </ol>

        <div class="callout-info">
            <p><strong>Implication:</strong> The ONLY way to find a valid nonce is brute force!</p>
            <pre><code>No shortcuts, no clever math tricks
Must try ~2^difficulty attempts on average</code></pre>
            <p><strong>Memory Aid:</strong> "SHA = Secure Hashing Approach"</p>
        </div>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: SHA-256 Avalanche Effect</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an interactive demonstration of the SHA-256 avalanche effect. Show an input string at the top with its hash value below (displayed in binary with bits colored). Allow users to modify the input string (add/remove/change one character). When the input changes, animate the hash output where approximately 50% of the bits flip (show bits changing from 0â†’1 or 1â†’0 with a flip animation). Display a "bit change counter" showing what percentage of bits changed. Include examples: "Hello" â†’ hash1, "hello" â†’ hash2 (completely different). Use a two-color scheme: bits that stayed the same (gray), bits that flipped (red pulsing). Add a comparison view showing old hash vs new hash side-by-side.</p>
            </div>
        </div>

        <h3>Difficulty Adjustment</h3>
        <p><strong>Problem:</strong> Hardware gets faster over time â†’ Blocks found too quickly!</p>

        <p><strong>Bitcoin's solution:</strong> Adjust difficulty every 2,016 blocks (~2 weeks)</p>

        <pre><code>Target time: 10 minutes per block
Actual time: 8 minutes per block (too fast!)

New difficulty: Increase by 25% (2016 * 10 / 2016 * 8)
Now it takes ~10 minutes again</code></pre>

        <p><strong>Formula:</strong></p>
        <pre><code>New Difficulty = Old Difficulty * (Target Time / Actual Time)
Target Time = 2016 blocks * 10 minutes = 20,160 minutes
Actual Time = Time to mine last 2016 blocks</code></pre>

        <div class="callout-success">
            <h4>Why 10 minutes?</h4>
            <ul>
                <li>Fast enough for users (transactions confirm reasonably quickly)</li>
                <li>Slow enough to let blocks propagate across the network</li>
                <li>Reduces forks (competing chains)</li>
            </ul>
        </div>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Difficulty Adjustment Over Time</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create a time-series graph showing Bitcoin's difficulty adjustment over the years. The x-axis is time (2009-2025), y-axis is difficulty level (logarithmic scale). Show the difficulty increasing in a step pattern (every 2016 blocks). Include markers for major events (ASIC miners introduced, Bitcoin halvings). Add an interactive overlay showing a 2-week window where users can see: "Target: 10 min/block, Actual: 8.5 min/block â†’ Difficulty increases by 17.6%". Include a secondary graph below showing hash rate over time. Use color transitions from green (below target time) to red (above target time) for each adjustment period.</p>
            </div>
        </div>

        <h3>Proof of Work as Byzantine Fault Tolerance</h3>
        <p><strong>Classical BFT assumption:</strong> Up to f Byzantine nodes, 3f+1 total nodes required</p>

        <p><strong>Bitcoin's assumption:</strong> Honest nodes control > 50% of computational power</p>

        <div class="callout-info">
            <h4>Key difference:</h4>
            <pre><code>Classical BFT: "Majority of nodes honest"
Bitcoin: "Majority of hashpower honest"</code></pre>
            <p><strong>Why this matters:</strong></p>
            <ul>
                <li>Can't Sybil attack (creating fake nodes doesn't give more power)</li>
                <li>Must invest in actual hardware (CPUs, electricity)</li>
                <li>Economic cost makes attacks expensive</li>
            </ul>
        </div>

        <h2>Mining and Block Creation</h2>

        <h3>The Mining Process (Step by Step)</h3>
        <div class="callout-info">
            <h4>Memory Aid: "CTHVPB"</h4>
            <ol>
                <li><strong>C</strong>ollect transactions from the mempool</li>
                <li><strong>T</strong>ransaction validation (check signatures, amounts)</li>
                <li><strong>H</strong>eader construction (prev hash, merkle root, timestamp, nonce=0)</li>
                <li><strong>V</strong>ary nonce and compute hash repeatedly</li>
                <li><strong>P</strong>ublish block when valid nonce found</li>
                <li><strong>B</strong>roadcast to network</li>
            </ol>
        </div>

        <p><strong>Detailed walkthrough:</strong></p>
        <pre><code>Step 1: Collect transactions
- Miners listen to network for new transactions
- Store in "mempool" (memory pool of unconfirmed transactions)
- Select ~4,000 transactions (prefer higher fees!)

Step 2: Validate each transaction
- Check digital signatures (is this really from Alice?)
- Check inputs exist and unspent (prevent double-spend)
- Check amounts balance (input â‰¥ output)

Step 3: Construct block header
prev_hash = hash of Block 916,843
merkle_root = compute from selected transactions
timestamp = current time
difficulty_target = 0x0000FFFF... (from protocol)
nonce = 0 (will vary this)

Step 4: Mining (the hard part!)
for nonce in 0 to 4,294,967,295:
    hash = SHA256(SHA256(header))
    if hash < target:
        FOUND IT!
        break
If no valid nonce found, update timestamp and try again

Step 5: Broadcast
Send block to all peers: "I found block 916,844!"

Step 6: Other nodes validate
- Check proof of work (hash really < target?)
- Check all transactions valid
- Check prev_hash points to known block
- If valid, add to their blockchain</code></pre>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Mining Process Flowchart</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an interactive flowchart showing the 6-step mining process (CTHVPB). Use a circular flow diagram starting from "Collect transactions" at the top. Each step should be a clickable node that expands to show detailed sub-steps. Show the mempool as a waiting area with transactions (represented as small colored rectangles) flowing in. Animate the "Vary nonce" step with a rapid counter. When "Publish block" is reached, show the block broadcasting to a network of nodes (expanding circles). Include timing annotations: "Step 1-3: seconds", "Step 4: ~10 minutes", "Step 5-6: seconds". Use color progression: blue (collection), green (validation), yellow (construction), red (mining), purple (publish), orange (broadcast).</p>
            </div>
        </div>

        <h3>The Coinbase Transaction</h3>
        <p><strong>Special first transaction in every block:</strong> Creates new Bitcoin!</p>

        <pre><code>Block 916,844's coinbase transaction:
Input:  NONE (creates money from thin air!)
Output: 3.125 BTC â†’ Miner's address
        + transaction fees from block

This is the miner's reward!</code></pre>

        <p><strong>Reward schedule</strong> (halving every 210,000 blocks â‰ˆ 4 years):</p>
        <pre><code>Blocks 0 - 210,000:       50 BTC per block
Blocks 210,000 - 420,000: 25 BTC per block
Blocks 420,000 - 630,000: 12.5 BTC per block
Blocks 630,000 - 840,000: 6.25 BTC per block
Blocks 840,000 - 1,050,000: 3.125 BTC per block â† Current
...
Total cap: ~21 million BTC (year ~2140)</code></pre>

        <p><strong>Economic incentive:</strong> Why miners do this expensive computation!</p>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Bitcoin Halving Schedule</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create a timeline visualization showing Bitcoin's halving schedule from 2009 to 2140. Show block rewards decreasing in a step pattern: 50 BTC â†’ 25 BTC â†’ 12.5 BTC â†’ 6.25 BTC â†’ 3.125 BTC, etc. Use a dual-axis chart: left axis shows block reward (decreasing), right axis shows total BTC supply (increasing toward 21M asymptote). Mark each halving event with a vertical line and date. Include a cumulative supply curve approaching 21 million BTC. Add interactive markers showing "Current halving" and project future halvings. Use a color gradient from gold (high rewards) to silver (low rewards). Include a callout showing "Next halving: 2028 (estimated)".</p>
            </div>
        </div>

        <h3>Transaction Fees</h3>
        <p><strong>How fees work:</strong></p>
        <pre><code>Transaction inputs:  5.0 BTC
Transaction outputs: 4.9 BTC
Fee (implicit):      0.1 BTC (goes to miner)</code></pre>

        <p><strong>Miner's total reward</strong> = Block reward + All transaction fees</p>

        <div class="callout-success">
            <h4>Why this matters:</h4>
            <ul>
                <li>After block reward goes to 0 (year 2140), fees sustain mining</li>
                <li>Higher fees â†’ Priority in next block</li>
                <li>Free market for block space!</li>
            </ul>
        </div>

        <h2>Transaction Validation and Propagation</h2>

        <h3>Structure of a Bitcoin Transaction</h3>
        <p><strong>Not like traditional payments!</strong> Bitcoin uses <strong>UTXO model</strong> (Unspent Transaction Outputs):</p>

        <pre><code>Traditional bank account:
Alice's balance: $100
Alice pays Bob $30
Alice's new balance: $70 (balance updated)

Bitcoin (UTXO):
Alice has: 1 BTC (from TX #123)
Alice creates TX:
  Input: TX #123 output
  Output 1: 0.3 BTC â†’ Bob
  Output 2: 0.69 BTC â†’ Alice (change)
  Fee: 0.01 BTC (implicit)
Alice's old UTXO destroyed, new change UTXO created</code></pre>

        <p><strong>Complete transaction structure:</strong></p>
        <pre><code>Transaction TX#456:
â”œâ”€ Inputs (what you're spending):
â”‚  â””â”€ Reference to TX#123 output 0
â”‚     Signature: Proves Alice owns this UTXO
â”‚
â””â”€ Outputs (where money goes):
   â”œâ”€ Output 0: 0.3 BTC â†’ Bob's address
   â””â”€ Output 1: 0.69 BTC â†’ Alice's change address</code></pre>

        <div class="callout-info">
            <h4>Key validation rules:</h4>
            <ol>
                <li><strong>Inputs exist:</strong> Referenced UTXOs exist in blockchain</li>
                <li><strong>Inputs unspent:</strong> Not already spent in another transaction</li>
                <li><strong>Signatures valid:</strong> Cryptographic proof of ownership</li>
                <li><strong>Amounts balance:</strong> Sum(inputs) â‰¥ Sum(outputs) + fees</li>
                <li><strong>No double-spend:</strong> Not already in blockchain</li>
            </ol>
        </div>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: UTXO Model vs Account Model</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create a side-by-side comparison showing traditional account model vs Bitcoin's UTXO model. Left side: Show Alice's account balance decreasing from $100 to $70 (simple number update). Right side: Show Alice's UTXO (1 BTC box) being "consumed" and split into two new UTXOs (0.3 BTC to Bob, 0.69 BTC back to Alice as change). Animate the UTXO being destroyed (fade out) and new ones being created (fade in). Show transaction references as arrows pointing to previous outputs. Use a "coin box" metaphor where UTXOs are physical boxes that must be spent entirely and replaced with new boxes. Include a fee visualization showing 0.01 BTC disappearing (going to miner).</p>
            </div>
        </div>

        <h3>Transaction Propagation</h3>
        <p><strong>Gossip protocol</strong> (peer-to-peer flooding):</p>

        <pre><code>Step 1: Alice creates transaction and signs it
Step 2: Alice broadcasts to her peers (3-8 nodes)
Step 3: Each peer validates transaction
Step 4: If valid, peer broadcasts to THEIR peers
Step 5: Exponential spread across network!

Timing:
t=0s:    1 node knows
t=1s:    ~7 nodes know
t=2s:    ~49 nodes know
t=3s:    ~343 nodes know
t=10s:   Most of network knows</code></pre>

        <p><strong>What nodes check before relaying:</strong></p>
        <ul>
            <li>Transaction well-formed (valid structure)</li>
            <li>Signatures valid</li>
            <li>Inputs unspent (check mempool too!)</li>
            <li>Not seen before (prevent spam)</li>
            <li>Pays sufficient fee (relay policy)</li>
        </ul>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Transaction Propagation Network</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an animated network graph showing transaction propagation across the Bitcoin network. Start with Alice's node at the center (gold). Show the transaction spreading in waves: t=0s (1 node), t=1s (7 nodes), t=2s (49 nodes), etc. Use a force-directed graph layout with nodes as circles that light up (color change from gray to green) as they receive and validate the transaction. Animate the gossip protocol with pulses traveling along edges. Include a time slider to control playback speed. Show validation checkmarks on nodes as they verify the transaction. Display a counter showing "Nodes reached: 343/10,000" and "Time: 3 seconds". Include occasional red nodes that reject the transaction (with X mark) to show validation in action.</p>
            </div>
        </div>

        <h3>Confirmations: When is a Transaction "Final"?</h3>
        <p><strong>Problem:</strong> Blockchain can fork! Your transaction might be in one branch but not another.</p>

        <p><strong>Solution:</strong> Wait for multiple confirmations</p>

        <pre><code>Block 100: Your transaction included (1 confirmation)
Block 101: Another block built on top (2 confirmations)
Block 102: Another block built on top (3 confirmations)
...
Block 106: (6 confirmations) â†’ Generally considered "final"</code></pre>

        <div class="callout-success">
            <h4>Why 6 confirmations?</h4>
            <ul>
                <li>Probability of reversal decreases exponentially</li>
                <li>With 6 blocks, attacker needs ~6 hours of 51% attack</li>
                <li>Cost becomes prohibitively expensive</li>
            </ul>
        </div>

        <p><strong>Formula for reversal probability</strong> (with attacker having q fraction of hashpower):</p>
        <pre><code>P(reversal with k confirmations) â‰ˆ (q/(1-q))^k

Example: q=0.4 (40% attacker), k=6 confirmations
P(reversal) â‰ˆ (0.4/0.6)^6 â‰ˆ 0.088 (8.8% chance)

Example: q=0.4, k=10 confirmations
P(reversal) â‰ˆ (0.4/0.6)^10 â‰ˆ 0.017 (1.7% chance)</code></pre>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Confirmation Security Graph</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an interactive graph showing the probability of transaction reversal vs number of confirmations. X-axis: confirmations (0-10), Y-axis: reversal probability (0-100%, logarithmic scale). Show multiple curves for different attacker hashpower levels: 10%, 25%, 40%, 49%. Highlight the 6-confirmation threshold with a vertical line. Use color coding: green zone (<1% risk), yellow zone (1-10% risk), red zone (>10% risk). Add an interactive slider for "Attacker Hashpower %" that updates the curve in real-time. Include a callout showing "At 6 confirmations with 40% attacker: 8.8% reversal risk". Show the exponential decay with animation as confirmations increase.</p>
            </div>
        </div>

        <h2>Byzantine Fault Tolerance in Bitcoin</h2>

        <h3>Byzantine Generals Problem Refresher</h3>
        <p><strong>Classic problem:</strong> Generals surround a city, must agree to attack or retreat</p>
        <ul>
            <li>Communication by messenger (can be intercepted)</li>
            <li>Some generals might be traitors (Byzantine)</li>
            <li>Need consensus despite traitors</li>
        </ul>

        <p><strong>Classical solution</strong> (Lamport et al.): Requires 3f+1 generals to tolerate f traitors</p>

        <div class="callout-warning">
            <h4>Problem for Bitcoin:</h4>
            <ul>
                <li>Don't know how many participants exist!</li>
                <li>Can't do "2/3 majority vote"</li>
                <li>Nodes can join/leave freely</li>
            </ul>
        </div>

        <h3>Bitcoin's Byzantine Fault Tolerance Model</h3>
        <p><strong>Key insight:</strong> Weight votes by computational power, not by node count!</p>

        <p><strong>Assumptions:</strong></p>
        <ol>
            <li>Honest nodes control > 50% of total hashpower</li>
            <li>Network is eventually synchronous (messages eventually delivered)</li>
            <li>Cryptographic assumptions hold (SHA-256, ECDSA secure)</li>
        </ol>

        <p><strong>How consensus works:</strong></p>
        <pre><code>Competing blocks:                Fork resolution:

    Block A â†â”€â”€â”               Block A â†â”€â”€ Block A' â† Block A''
               â”‚                          (3 blocks, most work)
Block 999 â”€â”€â”€â”€â”€â”¤                          â†“
               â”‚                    THIS CHAIN WINS
    Block B â†â”€â”€â”˜               Block B â† Block B'
                                         (2 blocks, less work)
                                         â†“
                                   ORPHANED/ABANDONED</code></pre>

        <div class="callout-info">
            <h4>Longest chain rule (actually "most work" chain):</h4>
            <ul>
                <li>Miners always build on the chain with most cumulative proof-of-work</li>
                <li>Honest majority ensures honest chain grows fastest</li>
                <li>Dishonest branches eventually abandoned</li>
            </ul>
        </div>

        <p><strong>Byzantine nodes can:</strong></p>
        <ul>
            <li>Create invalid transactions (rejected by validation)</li>
            <li>Mine on old blocks (wasted effort, orphaned)</li>
            <li>Withhold blocks temporarily (small disruption)</li>
        </ul>

        <p><strong>Byzantine nodes CANNOT</strong> (if < 50% hashpower):</p>
        <ul>
            <li>Reverse deep transactions (exponentially hard)</li>
            <li>Steal others' coins (need private keys)</li>
            <li>Create money beyond protocol (validation rejects)</li>
        </ul>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Fork Resolution Process</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an animated visualization of a blockchain fork and its resolution. Show blocks 999-1003 with a fork occurring at block 1000 (two competing blocks A and B). Animate miners building on both chains simultaneously. Show hashpower distribution: 60% on chain A (honest), 40% on chain B (dishonest). Over time, chain A grows faster and reaches height 1003 while chain B only reaches 1002. Animate the moment of resolution: all nodes switch to chain A (highlighted in green), chain B turns gray (orphaned). Show transactions from orphaned blocks returning to the mempool (floating back out). Include a "cumulative work" meter for each chain showing chain A accumulating more work faster. Use time progression slider to show the process step-by-step.</p>
            </div>
        </div>

        <h3>The 51% Attack</h3>
        <p><strong>What an attacker with 51% hashpower CAN do:</strong></p>

        <p><strong>1. Double-spend their own transactions:</strong></p>
        <pre><code>Public chain:           Secret chain (attacker):
Block 100: Pay Bob â†â”€â”€â”€ Block 100: Pay myself
Block 101               Block 101
Block 102               Block 102
                        Block 103 (more work!)
Bob ships product       Attacker broadcasts secret chain
                        â†“ Bob's payment reversed!</code></pre>

        <p><strong>2. Censor transactions</strong> (exclude specific transactions)</p>
        <p><strong>3. Cause reorganizations</strong> (disrupt consensus)</p>

        <div class="callout-warning">
            <h4>What attacker CANNOT do:</h4>
            <ul>
                <li>Steal anyone else's Bitcoin (need private keys)</li>
                <li>Change past blocks beyond their hashpower reach</li>
                <li>Create Bitcoin out of thin air (nodes validate coinbase)</li>
                <li>Change protocol rules (other nodes would reject)</li>
            </ul>
        </div>

        <div class="callout-success">
            <h4>Economic reality:</h4>
            <pre><code>Cost of 51% attack: >$10 billion in hardware + electricity
Likely outcome: Bitcoin price crashes, attacker's rewards worthless
Result: Attack is economically irrational!</code></pre>
            <p><strong>Defense:</strong> Economic incentives align with honesty!</p>
        </div>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: 51% Attack Scenario</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create a split-screen visualization showing a 51% attack in progress. Top panel: "Public blockchain" (shown to the network). Bottom panel: "Secret blockchain" (attacker's private chain). Show both chains growing from block 100. In the public chain, show "Alice â†’ Bob: 1 BTC" transaction getting confirmed. Show Bob shipping a product (icon). In the secret chain, show "Alice â†’ Alice: 1 BTC" transaction (double-spend). Animate the attacker's chain growing faster (thicker/brighter). At block 103, show the attacker broadcasting the secret chain, causing a reorganization (public chain fades, secret chain becomes main). Show Bob's payment being reversed (red X). Include a hashpower distribution pie chart: 51% attacker (red), 49% honest (blue). Add cost calculator showing hardware cost (~$10B) and expected loss from price crash.</p>
            </div>
        </div>

        <h3>Comparing to Classical BFT</h3>
        <table>
            <thead>
                <tr>
                    <th>Aspect</th>
                    <th>Classical BFT (PBFT)</th>
                    <th>Bitcoin</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Participants</strong></td>
                    <td>Known, permissioned</td>
                    <td>Unknown, permissionless</td>
                </tr>
                <tr>
                    <td><strong>Fault tolerance</strong></td>
                    <td>f &lt; n/3 Byzantine nodes</td>
                    <td>f &lt; 50% hashpower</td>
                </tr>
                <tr>
                    <td><strong>Finality</strong></td>
                    <td>Immediate (after 2f+1 votes)</td>
                    <td>Probabilistic (6+ blocks)</td>
                </tr>
                <tr>
                    <td><strong>Performance</strong></td>
                    <td>~1000s TPS</td>
                    <td>~7 TPS</td>
                </tr>
                <tr>
                    <td><strong>Latency</strong></td>
                    <td>Low (milliseconds)</td>
                    <td>High (~10 min/block)</td>
                </tr>
                <tr>
                    <td><strong>Scalability</strong></td>
                    <td>Dozens of nodes</td>
                    <td>Thousands of nodes</td>
                </tr>
                <tr>
                    <td><strong>Sybil resistance</strong></td>
                    <td>Membership control</td>
                    <td>Proof of Work</td>
                </tr>
            </tbody>
        </table>

        <div class="callout-info">
            <h4>Trade-offs:</h4>
            <ul>
                <li><strong>Bitcoin:</strong> Worse performance, better decentralization</li>
                <li><strong>PBFT:</strong> Better performance, requires trust/permission</li>
            </ul>
        </div>

        <h2>Security and Attack Vectors</h2>

        <h3>Cryptographic Security</h3>
        <p><strong>Bitcoin uses two cryptographic primitives:</strong></p>

        <p><strong>1. SHA-256 (hashing):</strong></p>
        <ul>
            <li><strong>Used for:</strong> Proof of work, block hashes, Merkle trees</li>
            <li><strong>Security:</strong> Preimage resistance (can't reverse)</li>
            <li><strong>Attack:</strong> Need to find collision (hash to same value)</li>
            <li><strong>Current status:</strong> No known attacks, considered secure</li>
        </ul>

        <p><strong>2. ECDSA (signatures):</strong></p>
        <ul>
            <li><strong>Used for:</strong> Transaction signatures, address generation</li>
            <li><strong>Security:</strong> Discrete log problem on elliptic curves</li>
            <li><strong>Attack:</strong> Need to derive private key from public key</li>
            <li><strong>Current status:</strong> Secure with proper random number generation</li>
        </ul>

        <div class="callout-warning">
            <h4>Quantum threat:</h4>
            <p>Future quantum computers could break ECDSA!</p>
            <ul>
                <li>Bitcoin addresses only reveal public key when spent</li>
                <li><strong>Defense:</strong> Use each address once (fresh address for change)</li>
            </ul>
        </div>

        <h3>Common Attack Vectors</h3>

        <div class="callout-warning">
            <h4>1. Double-Spend Attack</h4>
            <p><strong>Prevention:</strong> Wait for confirmations (6+ blocks)</p>
        </div>

        <div class="callout-warning">
            <h4>2. Selfish Mining</h4>
            <pre><code>Attacker finds block but doesn't broadcast immediately
Continues mining on secret chain
Broadcasts when public chain catches up
Result: Wastes honest miners' work, increases attacker's revenue

Mitigation: Requires >25% hashpower to be profitable
           Random uncle block rewards (Ethereum's approach)</code></pre>
        </div>

        <div class="callout-warning">
            <h4>3. Eclipse Attack</h4>
            <pre><code>Attacker surrounds victim node with attacker-controlled peers
Victim only sees attacker's version of blockchain
Can feed victim fake transaction confirmations

Prevention: - Connect to diverse, well-known peers
           - IP address diversity requirements
           - Listen on hardcoded DNS seeds</code></pre>
        </div>

        <div class="callout-warning">
            <h4>4. Timejacking</h4>
            <pre><code>Attacker lies about time (timestamps in blocks)
Victim accepts old blocks as recent
Can be used with other attacks

Prevention: Nodes check timestamps against local clock
           Reject blocks with timestamp too far off</code></pre>
        </div>

        <div class="callout-warning">
            <h4>5. Dust Attack (Privacy attack)</h4>
            <pre><code>Send tiny amounts to many addresses
Track how dust is spent together
Cluster addresses belonging to same user

Defense: Coin control (manual UTXO selection)
         Don't spend dust outputs</code></pre>
        </div>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Attack Vectors Overview</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an interactive security dashboard showing different attack vectors on Bitcoin. Use a circular radar chart in the center showing attack difficulty (1-10 scale) for each attack type: 51% Attack (difficulty 9), Selfish Mining (7), Eclipse Attack (5), Double-spend (3), Timejacking (4), Dust Attack (2). Make each attack type clickable to show a detailed explanation panel with: attack description, requirements, potential impact, and mitigations. Use color coding: red (high severity), yellow (medium), green (low). Include a risk assessment meter showing overall network security. Add a "Hashpower requirement" slider to show which attacks become feasible at different attacker power levels.</p>
            </div>
        </div>

        <h3>Network-Level Security</h3>
        <p><strong>P2P network properties:</strong></p>
        <ul>
            <li>~10,000 - 100,000 nodes (varies)</li>
            <li>Average 8 outbound + 117 inbound connections per node</li>
            <li>Gossip protocol for transaction/block propagation</li>
            <li>No central coordination</li>
        </ul>

        <p><strong>DDoS resistance:</strong></p>
        <ul>
            <li>No single point of failure</li>
            <li>Attack individual nodes â†’ They disconnect, others continue</li>
            <li>Very expensive to attack entire network</li>
        </ul>

        <p><strong>Sybil attack mitigation:</strong></p>
        <ul>
            <li>Proof of Work makes identity creation costly</li>
            <li>Can create many fake nodes, but can't fake hashpower!</li>
        </ul>

        <h2>Bitcoin vs. Traditional Distributed Systems</h2>

        <h3>CAP Theorem and Bitcoin</h3>
        <div class="callout-info">
            <h4>Reminder - CAP Theorem: Can only have 2 of 3:</h4>
            <ul>
                <li><strong>C</strong>onsistency: All nodes see same data</li>
                <li><strong>A</strong>vailability: System always responds</li>
                <li><strong>P</strong>artition tolerance: Works despite network splits</li>
            </ul>
        </div>

        <p><strong>Bitcoin's choice:</strong> AP system (eventually consistent)</p>

        <pre><code>Partition occurs:
US nodes see:     Block A at height 100
China nodes see:  Block B at height 100

Eventually (partition heals):
All nodes converge to longer chain
One block orphaned â†’ Eventually consistent</code></pre>

        <p><strong>Not strongly consistent:</strong> Different nodes may temporarily disagree!</p>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: CAP Theorem Triangle</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an interactive CAP theorem triangle with Consistency, Availability, and Partition Tolerance at the three vertices. Show different distributed systems positioned on the triangle: Bitcoin (between A and P, away from C), traditional databases (between C and A), Chord DHT (between A and P). Make each system clickable to highlight their CAP properties. Show Bitcoin with an "Eventually Consistent" label and animation showing nodes temporarily disagreeing then converging. Include a network partition scenario: split the triangle into two regions, show how Bitcoin maintains availability on both sides but loses consistency temporarily, then reconciles when partition heals. Use color coding: green (property satisfied), red (property sacrificed), yellow (partial/eventual).</p>
            </div>
        </div>

        <h3>Scalability Challenges</h3>
        <p><strong>Bitcoin's fundamental limits:</strong></p>

        <pre><code>Block size: 1 MB (legacy) or 4 MB (with SegWit)
Block time: 10 minutes
Transaction size: ~250 bytes average

Throughput: 4,000 transactions / 600 seconds â‰ˆ 7 TPS

Compare:
Visa: ~24,000 TPS (peak: 65,000 TPS)</code></pre>

        <div class="callout-warning">
            <h4>Blockchain trilemma: Can only optimize 2 of 3:</h4>
            <ul>
                <li><strong>Decentralization:</strong> Anyone can run a node</li>
                <li><strong>Security:</strong> Resistant to attacks</li>
                <li><strong>Scalability:</strong> High transaction throughput</li>
            </ul>
            <p><strong>Bitcoin's choice:</strong> Decentralization + Security â†’ Sacrifices scalability</p>
        </div>

        <div class="callout-success">
            <h4>Layer 2 solutions (exam may not cover, but good to know):</h4>
            <ul>
                <li><strong>Lightning Network:</strong> Off-chain payment channels</li>
                <li>Can achieve millions of TPS off-chain</li>
                <li>Periodically settle on Bitcoin blockchain</li>
            </ul>
        </div>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Blockchain Trilemma</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an interactive triangle diagram for the blockchain trilemma with Decentralization, Security, and Scalability at the vertices. Show Bitcoin positioned at the intersection of Decentralization and Security (away from Scalability). Include other systems for comparison: Ethereum (moving toward the center), Visa/traditional systems (high scalability + security, low decentralization). Use sliders for each property (0-10 scale) to show how adjusting one property affects the others - they should form a triangle with fixed perimeter (can't maximize all three). Add visual indicators: node count icons (decentralization), shield (security), speedometer (scalability). Include a "Layer 2" toggle that shows how Lightning Network extends toward scalability while maintaining Bitcoin's base layer properties.</p>
            </div>
        </div>

        <h3>Comparison Table</h3>
        <table>
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Traditional DB</th>
                    <th>Chord DHT</th>
                    <th>Raft/Paxos</th>
                    <th>Bitcoin</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Trust model</strong></td>
                    <td>Single authority</td>
                    <td>Untrusted nodes</td>
                    <td>Trusted majority</td>
                    <td>Untrusted majority</td>
                </tr>
                <tr>
                    <td><strong>Consistency</strong></td>
                    <td>Strong</td>
                    <td>Eventual</td>
                    <td>Strong</td>
                    <td>Eventual</td>
                </tr>
                <tr>
                    <td><strong>Throughput</strong></td>
                    <td>Very high</td>
                    <td>High</td>
                    <td>Medium</td>
                    <td>Very low</td>
                </tr>
                <tr>
                    <td><strong>Latency</strong></td>
                    <td>Low (ms)</td>
                    <td>Medium (100s ms)</td>
                    <td>Medium (ms)</td>
                    <td>High (~10 min)</td>
                </tr>
                <tr>
                    <td><strong>Fault tolerance</strong></td>
                    <td>Crash faults</td>
                    <td>Crash faults</td>
                    <td>Crash faults</td>
                    <td>Byzantine faults</td>
                </tr>
                <tr>
                    <td><strong>Open membership</strong></td>
                    <td>No</td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>Yes</td>
                </tr>
                <tr>
                    <td><strong>Data structure</strong></td>
                    <td>Various</td>
                    <td>Hash table</td>
                    <td>Log</td>
                    <td>Blockchain</td>
                </tr>
                <tr>
                    <td><strong>Scalability</strong></td>
                    <td>Vertical</td>
                    <td>Horizontal</td>
                    <td>Limited</td>
                    <td>Global</td>
                </tr>
            </tbody>
        </table>

        <h2>Exam Tips and Common Pitfalls</h2>

        <h3>Key Concepts to Master</h3>
        <div class="callout-info">
            <h4>Memory Aid: "BITCOIN"</h4>
            <ul>
                <li><strong>B</strong>lockchain structure (linked blocks, Merkle trees)</li>
                <li><strong>I</strong>mmutability (cryptographic hashing)</li>
                <li><strong>T</strong>ransaction validation (UTXO model, signatures)</li>
                <li><strong>C</strong>onsensus (longest chain rule)</li>
                <li><strong>O</strong>rphaned blocks (forks and resolution)</li>
                <li><strong>I</strong>ncentives (mining rewards, fees)</li>
                <li><strong>N</strong>onces (proof of work)</li>
            </ul>
        </div>

        <h3>Common Exam Question Types</h3>

        <div class="callout-success">
            <h4>Q1: "Explain how Bitcoin prevents double-spending"</h4>
            <p><strong>Answer template:</strong></p>
            <ol>
                <li>Define double-spending (spending same UTXO twice)</li>
                <li>Blockchain provides single, ordered history</li>
                <li>Miners validate transactions (check UTXO not already spent)</li>
                <li>Longest chain rule ensures consensus</li>
                <li>Confirmations reduce reversal probability</li>
            </ol>
        </div>

        <div class="callout-success">
            <h4>Q2: "Why does Bitcoin use Proof of Work?"</h4>
            <p><strong>Answer template:</strong></p>
            <ol>
                <li>Permissionless system (anyone can join)</li>
                <li>Prevents Sybil attacks (can't fake hashpower)</li>
                <li>Makes voting expensive (one CPU â‰ˆ one vote)</li>
                <li>Economic incentives align with honesty</li>
                <li>Achieves Byzantine fault tolerance</li>
            </ol>
        </div>

        <div class="callout-success">
            <h4>Q3: "What happens when two miners find a block simultaneously?"</h4>
            <p><strong>Answer:</strong></p>
            <pre><code>Time 0: Miner A finds Block X at height 100
        Miner B finds Block Y at height 100
        (Both valid!)

Time 1: Network splits
        50% nodes build on Block X
        50% nodes build on Block Y

Time 10: Miner C (building on X) finds Block X'
         X chain now longer (more cumulative work)

Time 11: All nodes switch to X chain
         Block Y orphaned (abandoned)
         Transactions in Y return to mempool</code></pre>
        </div>

        <div class="callout-success">
            <h4>Q4: "Calculate probability of successful double-spend attack"</h4>
            <p>Use exponential formula:</p>
            <pre><code>P(success) â‰ˆ (q/(1-q))^k
Where:
  q = attacker's fraction of hashpower
  k = number of confirmations

Example: q=0.3, k=6
P(success) = (0.3/0.7)^6 = 0.428^6 â‰ˆ 0.005 (0.5%)</code></pre>
        </div>

        <h3>Tricky iClicker-Style Questions</h3>

        <div class="callout-warning">
            <h4>Q: "Can a miner make proof-of-work easier by carefully choosing which transactions to include?"</h4>
            <p><strong>Answer: NO!</strong></p>
            <ul>
                <li>Nonce is separate from transaction list</li>
                <li>Must try all nonces regardless of transactions</li>
                <li>Merkle root changes if transactions change, but doesn't make puzzle easier</li>
                <li><strong>Key insight:</strong> Difficulty is purely about finding hash < target</li>
            </ul>
        </div>

        <div class="callout-warning">
            <h4>Q: "Can two adjacent blocks have the same nonce?"</h4>
            <p><strong>Answer: YES!</strong></p>
            <ul>
                <li>Nonce is per-block, not globally unique</li>
                <li>Each block has different previous hash â†’ Different header</li>
                <li>Same nonce + different header = different hash</li>
                <li><strong>Misconception:</strong> "Same nonce = instant validation" is FALSE</li>
            </ul>
        </div>

        <div class="callout-warning">
            <h4>Q: "Could previous block hash be a 16-bit checksum instead of 256-bit hash?"</h4>
            <p><strong>Answer: NO!</strong></p>
            <ul>
                <li>Previous hash IS part of current block's header</li>
                <li>Current block's hash depends on previous hash</li>
                <li>Changing previous hash makes finding valid nonce a different puzzle</li>
                <li><strong>Key insight:</strong> Previous hash contributes to proof-of-work!</li>
            </ul>
        </div>

        <div class="callout-warning">
            <h4>Q: "If average confirmation is 10 min and there are ~4,000 TX per block, what's average time per TX?"</h4>
            <p><strong>Answer: Still ~10 minutes!</strong> (NOT 10 min / 4000 = 0.15 seconds)</p>
            <ul>
                <li>Transactions are batched into blocks</li>
                <li>All 4,000 TXs get confirmed when the block is mined</li>
                <li>Individual TX doesn't get "partially" confirmed</li>
                <li><strong>Misconception:</strong> Time is per-block, not per-transaction</li>
            </ul>
        </div>

        <h3>Don't Confuse These!</h3>

        <table>
            <thead>
                <tr>
                    <th>Concept 1</th>
                    <th>vs</th>
                    <th>Concept 2</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Block hash</strong></td>
                    <td>vs</td>
                    <td><strong>Previous block hash</strong></td>
                </tr>
                <tr>
                    <td>Hash of current block's header (output)</td>
                    <td></td>
                    <td>Hash of previous block (input to current)</td>
                </tr>
                <tr>
                    <td colspan="3"></td>
                </tr>
                <tr>
                    <td><strong>Nonce</strong></td>
                    <td>vs</td>
                    <td><strong>Transaction ID</strong></td>
                </tr>
                <tr>
                    <td>Number varied to solve PoW puzzle</td>
                    <td></td>
                    <td>Hash of transaction data (immutable)</td>
                </tr>
                <tr>
                    <td colspan="3"></td>
                </tr>
                <tr>
                    <td><strong>Confirmation</strong></td>
                    <td>vs</td>
                    <td><strong>Validation</strong></td>
                </tr>
                <tr>
                    <td>Transaction included in block on longest chain</td>
                    <td></td>
                    <td>Checking transaction is well-formed (immediate)</td>
                </tr>
                <tr>
                    <td colspan="3"></td>
                </tr>
                <tr>
                    <td><strong>Fork</strong></td>
                    <td>vs</td>
                    <td><strong>Orphan</strong></td>
                </tr>
                <tr>
                    <td>Two competing chains (temporary state)</td>
                    <td></td>
                    <td>Block not on longest chain (abandoned)</td>
                </tr>
                <tr>
                    <td colspan="3"></td>
                </tr>
                <tr>
                    <td><strong>Mining reward</strong></td>
                    <td>vs</td>
                    <td><strong>Transaction fee</strong></td>
                </tr>
                <tr>
                    <td>New Bitcoin created (3.125 BTC currently)</td>
                    <td></td>
                    <td>Sum(inputs) - Sum(outputs) per TX</td>
                </tr>
                <tr>
                    <td colspan="2"><strong>Miner gets:</strong></td>
                    <td>Mining reward + All fees in block</td>
                </tr>
            </tbody>
        </table>

        <h3>Calculation Formulas to Memorize</h3>

        <div class="callout-info">
            <h4>1. Approximate number of hashes required:</h4>
            <pre><code>Expected hashes = 2^difficulty

Example: difficulty target starts with 4 zero bytes
That's 32 zero bits
Expected hashes â‰ˆ 2^32 â‰ˆ 4.3 billion</code></pre>
        </div>

        <div class="callout-info">
            <h4>2. Double-spend success probability:</h4>
            <pre><code>P(success with k confirmations) â‰ˆ (q/(1-q))^k

Where q = attacker's hashpower fraction</code></pre>
        </div>

        <div class="callout-info">
            <h4>3. Block time adjustment:</h4>
            <pre><code>New difficulty = Old difficulty Ã— (Target time / Actual time)

Target: 2016 blocks in 20,160 minutes</code></pre>
        </div>

        <div class="callout-info">
            <h4>4. Maximum Bitcoin supply:</h4>
            <pre><code>Total = 50 Ã— 210,000 + 25 Ã— 210,000 + 12.5 Ã— 210,000 + ...
      = 210,000 Ã— (50 + 25 + 12.5 + 6.25 + ...)
      = 210,000 Ã— 100 (geometric series sum)
      â‰ˆ 21,000,000 BTC</code></pre>
        </div>

        <h3>Visual Mnemonics</h3>

        <div class="callout-success">
            <h4>"CHAIN" - Remember blockchain properties:</h4>
            <ul>
                <li><strong>C</strong>ryptographically linked (previous block hash)</li>
                <li><strong>H</strong>ashing for immutability (tamper-evident)</li>
                <li><strong>A</strong>ppend-only (can't modify history)</li>
                <li><strong>I</strong>mmutable with depth (deeper = harder to change)</li>
                <li><strong>N</strong>o central authority (distributed consensus)</li>
            </ul>
        </div>

        <div class="callout-success">
            <h4>"MINER" - Remember mining process:</h4>
            <ul>
                <li><strong>M</strong>empool (collect transactions)</li>
                <li><strong>I</strong>nclude in block (construct header)</li>
                <li><strong>N</strong>once variation (try different values)</li>
                <li><strong>E</strong>valuate hash (check if < target)</li>
                <li><strong>R</strong>eward collection (coinbase + fees)</li>
            </ul>
        </div>

        <div class="callout-success">
            <h4>"UTXO" - Remember transaction model:</h4>
            <ul>
                <li><strong>U</strong>nspent outputs only (can't spend twice)</li>
                <li><strong>T</strong>ransaction inputs reference previous outputs</li>
                <li><strong>X</strong> (cross out) spent outputs (marked as spent)</li>
                <li><strong>O</strong>utputs created for recipients (+ change)</li>
            </ul>
        </div>

        <h2>Practice Questions</h2>

        <h3>Question 1: Blockchain Structure</h3>
        <p>Given this blockchain:</p>
        <pre><code>Block 100: Hash=0xAAAA, Prev=0xBBBB, Nonce=12345, TXs=[...]
Block 101: Hash=0xCCCC, Prev=0xAAAA, Nonce=67890, TXs=[...]
Block 102: Hash=0xDDDD, Prev=0xCCCC, Nonce=11111, TXs=[...]</code></pre>

        <p>If an attacker modifies a transaction in Block 100, what must they do to make the chain valid again?</p>

        <details>
            <summary><strong>Click to show answer</strong></summary>
            <div class="callout-info">
                <p><strong>The attacker must:</strong></p>
                <ol>
                    <li>Find a new nonce for Block 100 (hash changes due to TX modification)</li>
                    <li>Update Block 101's "Prev" field to new Block 100 hash</li>
                    <li>Find a new nonce for Block 101 (header changed)</li>
                    <li>Update Block 102's "Prev" field to new Block 101 hash</li>
                    <li>Find a new nonce for Block 102</li>
                    <li>Continue for ALL subsequent blocks!</li>
                </ol>
                <p><strong>Why this is hard:</strong> Each block requires ~2^difficulty hashes to mine. With hundreds of thousands of blocks, this is computationally infeasible!</p>
                <p><strong>Key insight:</strong> This is why older transactions are more secure - buried under more proof-of-work.</p>
            </div>
        </details>

        <h3>Question 2: Double-Spending Attack</h3>
        <p>Alice has 1 BTC. She wants to double-spend by sending it to both Bob (merchant) and Charlie (herself).</p>

        <p><strong>Scenario:</strong></p>
        <ul>
            <li>Alice controls 40% of network hashpower</li>
            <li>Bob ships product after 3 confirmations</li>
            <li>Current block height: 1000</li>
        </ul>

        <p>Walk through Alice's attack strategy and calculate her probability of success.</p>

        <details>
            <summary><strong>Click to show answer</strong></summary>
            <div class="callout-info">
                <p><strong>Alice's strategy:</strong></p>
                <pre><code>Public chain (honest miners):    Secret chain (Alice's miners):
Block 1000 (Alice has 1 BTC)     Block 1000 (Alice has 1 BTC)
Block 1001: Alice â†’ Bob 1 BTC    Block 1001: Alice â†’ Charlie 1 BTC
Block 1002                       Block 1002
Block 1003                       Block 1003
Block 1004 (Bob ships product)   Block 1004
                                 Block 1005
                                 Alice broadcasts secret chain!
                                 â†“ Reorganization!
                                 Public chain orphaned
                                 Bob's payment reversed</code></pre>

                <p><strong>Probability calculation:</strong></p>
                <pre><code>q = 0.4 (Alice's hashpower)
k = 3 (Bob's confirmation requirement)

P(success) = (q / (1-q))^k
           = (0.4 / 0.6)^3
           = (2/3)^3
           = 8/27
           â‰ˆ 0.296 or 29.6%</code></pre>

                <p><strong>Conclusion:</strong> Bob should wait for more confirmations! With 6 confirmations, P(success) â‰ˆ 8.8%.</p>
            </div>
        </details>

        <h3>Question 3: Proof of Work</h3>
        <p>A miner is trying to find a valid block with difficulty target = 0x00FFFFFF... (3 zero bytes).</p>

        <p><strong>Questions:</strong></p>
        <ol type="a">
            <li>Approximately how many hashes must be computed on average?</li>
            <li>If the miner's hardware can compute 10^9 hashes/second, how long to find a block on average?</li>
            <li>What changes in the block header each iteration?</li>
        </ol>

        <details>
            <summary><strong>Click to show answer</strong></summary>
            <div class="callout-info">
                <p><strong>a) Number of hashes:</strong></p>
                <pre><code>3 zero bytes = 24 zero bits
Average hashes needed = 2^24
                      = 16,777,216 hashes</code></pre>

                <p><strong>b) Time required:</strong></p>
                <pre><code>Hashes per second = 10^9 = 1,000,000,000
Time = 16,777,216 / 1,000,000,000
     â‰ˆ 0.017 seconds

Note: This is VERY EASY difficulty (real Bitcoin is ~2^72+)!</code></pre>

                <p><strong>c) What changes:</strong></p>
                <pre><code>Primary: Nonce (0 to 4,294,967,295)
Secondary: Timestamp (periodically updated)
           Merkle root (if changing transaction set)

Other fields stay constant:
- Previous block hash (fixed)
- Difficulty target (fixed for this block)</code></pre>
            </div>
        </details>

        <h3>Question 4: Byzantine Fault Tolerance</h3>
        <p>Compare how these systems handle a malicious node that sends different values to different nodes:</p>
        <ol type="a">
            <li>Bitcoin</li>
            <li>Classical BFT (like PBFT)</li>
            <li>Raft consensus</li>
        </ol>

        <details>
            <summary><strong>Click to show answer</strong></summary>
            <div class="callout-info">
                <p><strong>a) Bitcoin:</strong></p>
                <pre><code>Scenario: Malicious miner broadcasts different blocks to different nodes
Block A sent to US nodes
Block B sent to China nodes

Resolution:
- Both chains grow temporarily (fork)
- Honest majority eventually makes one chain longer
- All nodes converge to longest chain
- One block orphaned

Tolerance: Works if malicious < 50% hashpower
Finality: Probabilistic (never 100% certain)</code></pre>

                <p><strong>b) Classical BFT (PBFT):</strong></p>
                <pre><code>Scenario: Malicious node sends different pre-prepare messages

Resolution:
- Nodes cross-verify messages from all nodes
- 2f+1 matching messages required for agreement
- Malicious node detected and ignored

Tolerance: Works if malicious < n/3 nodes
Finality: Deterministic (mathematically guaranteed)</code></pre>

                <p><strong>c) Raft consensus:</strong></p>
                <pre><code>Scenario: Malicious leader sends different log entries

Resolution:
- CANNOT HANDLE! Raft assumes crash failures only
- No verification between nodes
- System could become inconsistent

Tolerance: 0 Byzantine nodes
Finality: Deterministic (if no Byzantine faults)</code></pre>

                <p><strong>Key insight:</strong> Bitcoin trades performance (slow) for Byzantine fault tolerance in permissionless setting!</p>
            </div>
        </details>

        <h3>Question 5: Transaction Lifecycle</h3>
        <p>Trace this transaction from creation to confirmation:</p>

        <pre><code>Alice's UTXO: 2 BTC (from TX#999)
Alice creates new transaction:
  Input: TX#999 output 0
  Output 0: 1.5 BTC â†’ Bob
  Output 1: 0.49 BTC â†’ Alice (change)
  Implied fee: 0.01 BTC</code></pre>

        <p>What happens at each stage? Include timing estimates.</p>

        <details>
            <summary><strong>Click to show answer</strong></summary>
            <div class="callout-info">
                <p><strong>Stage 1: Creation (t=0s)</strong></p>
                <pre><code>Alice's wallet software:
1. Selects UTXO (TX#999 output 0)
2. Creates outputs (Bob: 1.5, Change: 0.49)
3. Calculates fee (2 - 1.5 - 0.49 = 0.01)
4. Signs with Alice's private key
5. Broadcasts to peers</code></pre>

                <p><strong>Stage 2: Propagation (t=0s to t=10s)</strong></p>
                <pre><code>t=0s:   Alice's node â†’ 8 peers
t=1s:   8 peers â†’ ~64 peers
t=2s:   64 peers â†’ ~512 peers
t=10s:  Most of network has seen it

Each node validates:
âœ“ Signature valid
âœ“ Input exists (TX#999 output 0)
âœ“ Input unspent
âœ“ Amount balance (2 = 1.5 + 0.49 + 0.01)</code></pre>

                <p><strong>Stage 3: Mempool (t=10s to t=~600s)</strong></p>
                <pre><code>Transaction sits in miners' mempools
Waiting to be included in a block
Miners prefer higher fee transactions</code></pre>

                <p><strong>Stage 4: Mining (t=~600s)</strong></p>
                <pre><code>Miner finds valid block:
- Includes Alice's TX (among ~4,000 others)
- Block height 101,000
- Alice â†’ Bob transaction: 1 confirmation</code></pre>

                <p><strong>Stage 5: Confirmations (t=600s to t=3600s)</strong></p>
                <pre><code>t=~600s:  Block 101,000 (1 confirmation)
t=~1200s: Block 101,001 (2 confirmations)
t=~1800s: Block 101,002 (3 confirmations)
t=~3600s: Block 101,006 (6 confirmations)

After 6 confirmations: Generally considered irreversible
Bob can safely ship the product!</code></pre>

                <p><strong>Total time:</strong> ~1 hour for high confidence</p>
            </div>
        </details>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Transaction Lifecycle Timeline</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an interactive timeline showing the complete lifecycle of a Bitcoin transaction from creation to 6 confirmations. Use a horizontal timeline from t=0 to t=3600 seconds. Show 5 stages as segments: (1) Creation (instant, gold), (2) Propagation (0-10s, blue with network spreading animation), (3) Mempool waiting (10-600s, yellow), (4) First confirmation (600s, green flash), (5) Additional confirmations (600-3600s, deepening green). Include animated icons: wallet creating TX, network nodes lighting up during propagation, mempool pool filling, miner finding block, blocks stacking for confirmations. Add interactive markers that show detailed info when clicked. Include a "security meter" that increases with each confirmation. Show Alice's transaction as a colored packet moving through each stage.</p>
            </div>
        </div>

        <h2>Final Checklist Before Exam</h2>

        <ul class="checklist">
            <li>Can you explain the double-spending problem and Bitcoin's solution?</li>
            <li>Can you draw a blockchain showing linked blocks?</li>
            <li>Can you explain proof of work and why it's needed?</li>
            <li>Do you understand the mining process step-by-step?</li>
            <li>Can you trace a transaction from creation to confirmation?</li>
            <li>Can you calculate double-spend attack success probability?</li>
            <li>Do you understand Byzantine fault tolerance in Bitcoin vs. classical BFT?</li>
            <li>Can you explain why Bitcoin is eventually consistent, not strongly consistent?</li>
            <li>Do you know the difference between validation and confirmation?</li>
            <li>Can you explain economic incentives (mining rewards, fees)?</li>
            <li>Do you understand why longer/deeper blocks are more secure?</li>
            <li>Can you compare Bitcoin to other distributed systems (Raft, Chord, etc.)?</li>
        </ul>

        <h2>Connection to Other Course Topics</h2>

        <h3>Distributed Consensus</h3>
        <ul>
            <li><strong>Raft/Paxos:</strong> Leader-based, crash fault tolerant, closed membership</li>
            <li><strong>Bitcoin:</strong> Leaderless (rotating), Byzantine fault tolerant, open membership</li>
            <li><strong>Trade-off:</strong> Bitcoin sacrifices speed for openness and Byzantine tolerance</li>
        </ul>

        <h3>Distributed Hash Tables (Chord)</h3>
        <ul>
            <li><strong>Chord:</strong> Maps keys to nodes deterministically, O(log N) lookup</li>
            <li><strong>Bitcoin:</strong> Maps transactions to blocks probabilistically, O(1) lookup once confirmed</li>
            <li><strong>Similarity:</strong> Both use hash functions for decentralization</li>
        </ul>

        <h3>Vector Clocks / Lamport Clocks</h3>
        <ul>
            <li><strong>Logical clocks:</strong> Partial ordering of events</li>
            <li><strong>Bitcoin blockchain:</strong> Total ordering of events (transactions)</li>
            <li><strong>Difference:</strong> Bitcoin achieves global total order (much harder!)</li>
        </ul>

        <h3>Byzantine Fault Tolerance (PBFT)</h3>
        <ul>
            <li><strong>PBFT:</strong> 3-phase protocol, 3f+1 nodes for f faults, known participants</li>
            <li><strong>Bitcoin:</strong> Proof of work, 2x hashpower for x% faults, unknown participants</li>
            <li><strong>Trade-off:</strong> PBFT faster but requires permission; Bitcoin slower but permissionless</li>
        </ul>

        <div class="visualization-placeholder">
            <h3>ğŸ“Š Visualization: Course Topics Concept Map</h3>
            <p><em>Interactive visualization will be generated here</em></p>
            <div class="viz-prompt">
                <strong>Prompt for visualization agent:</strong>
                <p>Create an interactive concept map showing how Bitcoin relates to other distributed systems topics covered in the course. Center node: Bitcoin. Connected nodes: Raft/Paxos (consensus), Chord DHT (distributed hash tables), Vector/Lamport Clocks (ordering), PBFT (Byzantine tolerance), CAP Theorem (consistency trade-offs). Use different colored edges to show relationships: "Similar to" (green), "Contrasts with" (red), "Builds upon" (blue). Make each connection clickable to show detailed comparison. Include properties as smaller satellite nodes: decentralization, fault tolerance, consistency model, scalability. Use a force-directed layout where similar concepts cluster together. Add toggle filters to highlight specific aspects: "Byzantine tolerance", "Consensus mechanisms", "Ordering guarantees".</p>
            </div>
        </div>

        <div class="callout-success">
            <h4>Final Message</h4>
            <p><strong>Good luck on your exam! Remember:</strong> Bitcoin is a masterpiece of distributed systems design. It combines cryptography (hashing, signatures), economics (incentives), game theory (rational miners), and consensus (longest chain) to solve a problem previously thought impossible - money without trusted parties. Focus on understanding <strong>WHY</strong> each component exists, and the <strong>HOW</strong> will follow naturally!</p>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CS 416 Study Guide | Distributed Systems</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
    <script src="js/bitcoin-viz.js"></script>
</body>
</html>
