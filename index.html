<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS 416 Distributed Systems - Exam Study Guide</title>
    <script src="rpc-visualizations.js" defer></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --primary-dark: #1e40af;
            --secondary: #10b981;
            --background: #f8fafc;
            --surface: #ffffff;
            --text: #1e293b;
            --text-light: #64748b;
            --border: #e2e8f0;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--background);
            color: var(--text);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 30px 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .timer {
            font-size: 1.5rem;
            font-weight: bold;
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 8px;
            margin-top: 10px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 8px;
            background: var(--surface);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow-x: auto;
            flex-wrap: wrap;
        }

        .tab {
            padding: 12px 20px;
            background: transparent;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .tab:hover {
            background: var(--background);
        }

        .tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Content */
        .content-area {
            background: var(--surface);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-height: 500px;
        }

        .lecture-content {
            display: none;
        }

        .lecture-content.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Flashcard */
        .flashcard-container {
            display: none;
            max-width: 800px;
            margin: 0 auto;
        }

        .flashcard-container.active {
            display: block;
        }

        .flashcard-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .flashcard-progress {
            font-weight: 600;
            color: var(--text-light);
        }

        .flashcard {
            perspective: 1000px;
            min-height: 300px;
            margin: 30px 0;
        }

        .flashcard-inner {
            position: relative;
            width: 100%;
            min-height: 300px;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            cursor: pointer;
        }

        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            min-height: 300px;
            backface-visibility: hidden;
            border-radius: 12px;
            padding: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 1.3rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .flashcard-front {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .flashcard-back {
            background: linear-gradient(135deg, var(--secondary) 0%, #059669 100%);
            color: white;
            transform: rotateY(180deg);
        }

        .flashcard-hint {
            text-align: center;
            color: var(--text-light);
            margin-top: 10px;
            font-style: italic;
        }

        .flashcard-nav {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37,99,235,0.3);
        }

        .btn-secondary {
            background: var(--background);
            color: var(--text);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--surface);
            border-color: var(--primary);
        }

        /* Markdown Styles */
        .lecture-content h1 {
            color: var(--primary);
            font-size: 2rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--primary);
        }

        .lecture-content h2 {
            color: var(--primary);
            font-size: 1.6rem;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .lecture-content h3 {
            color: var(--text);
            font-size: 1.3rem;
            margin-top: 25px;
            margin-bottom: 12px;
        }

        .lecture-content p {
            margin-bottom: 15px;
        }

        .lecture-content ul, .lecture-content ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        .lecture-content li {
            margin-bottom: 8px;
        }

        .lecture-content code {
            background: var(--background);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .lecture-content pre {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
        }

        .lecture-content pre code {
            background: transparent;
            padding: 0;
            color: inherit;
        }

        .lecture-content strong {
            color: var(--primary);
            font-weight: 700;
        }

        /* Visualization */
        .visualization {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin: 30px 0;
        }

        .visualization h3 {
            color: var(--primary);
            margin-bottom: 15px;
        }

        .viz-canvas {
            background: white;
            border-radius: 8px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 30px;
            color: var(--text-light);
            margin-top: 40px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.5rem;
            }

            .tabs {
                flex-direction: column;
            }

            .content-area {
                padding: 20px;
            }

            .flashcard-front, .flashcard-back {
                font-size: 1.1rem;
                padding: 30px;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>CS 416 Distributed Systems - Exam Study Guide</h1>
        </div>
    </header>

    <div class="container">
        <!-- Tabs -->
        <div class="tabs">
            <div class="tab active" data-tab="lecture1">Lecture 1: Intro</div>
            <div class="tab" data-tab="lecture2">Lecture 2: Multithreading</div>
            <div class="tab" data-tab="lecture3">Lecture 3: RPC</div>
            <div class="tab" data-tab="lecture4">Lecture 4: MapReduce</div>
            <div class="tab" data-tab="lecture6">Lecture 6: Crash Recovery</div>
            <div class="tab" data-tab="lecture7">Lecture 7: 2PC</div>
            <div class="tab" data-tab="distributed-commit">üìö Distributed Commit</div>
            <div class="tab" data-tab="practice">üìù Practice Questions</div>
            <div class="tab" data-tab="flashcards">üé¥ Flashcards</div>
        </div>

        <!-- Content Area -->
        <div class="content-area">
            <!-- Lecture 1 -->
            <div class="lecture-content active" id="lecture1">
                <h1>Lecture 1: Introduction to Distributed Systems</h1>

                <h2>What is a Distributed System?</h2>

                <h3>Definition</h3>
                <p>A <strong>distributed system</strong> is a collection of independent computers that appears to its users as a single coherent system. More specifically:</p>
                <ul>
                    <li><strong>Multiple computers networked over some medium</strong> (LAN, WAN, Internet)</li>
                    <li><strong>Organized to achieve an overarching goal</strong> (shared purpose or functionality)</li>
                    <li><strong>Components may not directly communicate with each other</strong> (indirect coordination is possible)</li>
                    <li><strong>Appear as a unified system</strong> to end users despite being physically separated</li>
                </ul>

                <h3>Key Characteristics</h3>
                <ol>
                    <li><strong>Autonomy</strong>: Each node operates independently with its own processor and memory</li>
                    <li><strong>Coordination</strong>: Nodes work together through message passing (no shared memory in pure distributed systems)</li>
                    <li><strong>Transparency</strong>: Users shouldn't need to know the system is distributed</li>
                    <li><strong>Concurrency</strong>: Multiple nodes execute operations simultaneously</li>
                    <li><strong>No Global Clock</strong>: Cannot rely on perfectly synchronized time across all nodes</li>
                </ol>

                <h2>Examples of Distributed Systems</h2>

                <h3>1. Distributed Databases</h3>
                <p><strong>What they are:</strong> Database systems spread across multiple physical locations with data partitioned (sharded) or replicated across nodes.</p>
                <p><strong>Examples:</strong> Google Spanner, Amazon DynamoDB, Apache Cassandra</p>

                <h3>2. Botnets</h3>
                <p><strong>What they are:</strong> Network of compromised computers controlled by attacker(s). Shows distributed systems aren't always benign.</p>

                <h3>3. Domain Name System (DNS)</h3>
                <p><strong>What it is:</strong> Hierarchical distributed database mapping domain names to IP addresses, globally distributed with millions of DNS servers.</p>
                <p><strong>Structure:</strong> Root servers ‚Üí TLD servers ‚Üí Authoritative servers with caching and eventual consistency</p>

                <h3>4. Blockchain</h3>
                <p><strong>What it is:</strong> Distributed ledger technology with no central authority, replicated across all participating nodes.</p>
                <p><strong>Consensus:</strong> Proof of Work (Bitcoin), Proof of Stake (Ethereum), Byzantine Fault Tolerance</p>

                <div class="visualization">
                    <h3>üìä Interactive: Latency Simulator</h3>
                    <p>Experience how network latency affects distributed systems:</p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin: 15px 0;">
                        <button class="btn btn-primary" onclick="simulateLatency(10, 'Local Network')">Local (10ms)</button>
                        <button class="btn btn-primary" onclick="simulateLatency(50, 'Same Region')">Same Region (50ms)</button>
                        <button class="btn btn-primary" onclick="simulateLatency(150, 'Cross-Country')">Cross-Country (150ms)</button>
                        <button class="btn btn-primary" onclick="simulateLatency(300, 'Cross-Continent')">Cross-Continent (300ms)</button>
                        <button class="btn btn-primary" onclick="simulateLatency(1000, 'Satellite')">Satellite (1000ms)</button>
                    </div>
                    <div id="latency-display" style="margin-top: 20px; min-height: 80px;">
                        <div id="latency-bar" style="width: 0%; height: 30px; background: linear-gradient(90deg, var(--success), var(--warning), var(--danger)); border-radius: 15px; transition: width 0.5s;"></div>
                        <p id="latency-result" style="margin-top: 10px; font-weight: bold;"></p>
                    </div>
                </div>

                <h2>Challenges in Distributed Systems</h2>

                <h3>1. Latency</h3>
                <p><strong>What it is:</strong> Time delay between sending a message and receiving a response. Speed of light limitation (~300,000 km/s) creates minimum latencies:</p>
                <ul>
                    <li>Sydney to London: minimum ~50ms one-way (physical limit)</li>
                    <li>Round trip time (RTT) at least 100ms</li>
                    <li>Users notice delays >100-200ms</li>
                </ul>
                <p><strong>Mitigation:</strong> Caching, replication (CDNs), asynchronous communication, batching</p>

                <h3>2. Network Failures</h3>
                <p><strong>Types of failures:</strong></p>
                <ul>
                    <li><strong>Packet loss</strong>: Messages dropped by network</li>
                    <li><strong>Partitions</strong>: Network splits, some nodes can't reach others</li>
                    <li><strong>Byzantine failures</strong>: Nodes send corrupted/malicious messages</li>
                    <li><strong>Crash failures</strong>: Nodes stop responding entirely</li>
                </ul>
                <p><strong>Key Problem:</strong> Cannot distinguish between crashed node, slow network, or lost message.</p>
                <p><strong>Fundamental limits:</strong> FLP Impossibility, Two Generals Problem, CAP Theorem</p>

                <h3>3. Security Across Systems</h3>
                <p><strong>Challenges:</strong></p>
                <ul>
                    <li>Larger attack surface (more nodes = more vulnerabilities)</li>
                    <li>Trust boundaries (different owners/administrators)</li>
                    <li>Must secure all communication paths</li>
                    <li>Authentication & Authorization across domains</li>
                </ul>
                <p><strong>Security mechanisms:</strong> TLS/SSL encryption, mutual authentication, access control (RBAC), audit logging, zero-trust architecture</p>

                <h2>Why Distribute Systems?</h2>

                <h3>1. Performance</h3>
                <p><strong>Parallel processing:</strong> Divide work across nodes (MapReduce, web servers with load balancers)</p>
                <p><strong>Limitation:</strong> Amdahl's Law - if 5% of task is sequential, max speedup is 20x regardless of CPUs</p>

                <h3>2. Scale</h3>
                <p><strong>Horizontal scaling:</strong> Add more machines instead of bigger machines</p>
                <ul>
                    <li><strong>Sharding/Partitioning:</strong> Split data across nodes (hash-based, range-based, geographic)</li>
                    <li><strong>Replication:</strong> Same data on multiple nodes for read scaling</li>
                </ul>
                <p><strong>Real-world scale:</strong> Google processes 20+ petabytes daily, AWS S3 stores trillions of objects</p>

                <h3>3. Availability</h3>
                <p><strong>Measured as uptime:</strong> 99.999% = "five nines" = 5.26 min downtime/year</p>
                <p><strong>Redundancy:</strong> No single point of failure. With 3 replicas at 99% uptime each, system has 99.9999% availability</p>
                <p><strong>Geographic distribution:</strong> Survive datacenter outages, natural disasters</p>

                <h3>4. Localization</h3>
                <p><strong>Place data/compute close to users:</strong></p>
                <ul>
                    <li>Reduce latency (speed of light limits)</li>
                    <li>Regulatory compliance (GDPR: EU data stays in EU)</li>
                    <li>Better user experience (each 100ms delay reduces conversions ~7%)</li>
                </ul>
                <p><strong>Examples:</strong> CDNs (Cloudflare, Akamai), Netflix caching video in ISPs, gaming regional servers</p>

                <h2>Key Takeaways for Exam</h2>

                <h3>Critical Concepts</h3>
                <ul>
                    <li><strong>Distributed system definition:</strong> Multiple independent computers working toward common goal</li>
                    <li><strong>No shared memory:</strong> All coordination via message passing over network</li>
                    <li><strong>Partial failures:</strong> Some components fail while others work</li>
                    <li><strong>CAP Theorem:</strong> Consistency vs. Availability during Partitions (pick 2 of 3)</li>
                </ul>

                <h3>Trade-offs to Remember</h3>
                <ul>
                    <li><strong>Latency vs. Consistency:</strong> Strong consistency requires coordination (slow)</li>
                    <li><strong>Availability vs. Cost:</strong> More redundancy = higher availability but more expensive</li>
                    <li><strong>Performance vs. Complexity:</strong> Distributed systems fast but complex</li>
                </ul>

                <h3>Common Patterns</h3>
                <ul>
                    <li><strong>Replication:</strong> For availability and read scalability</li>
                    <li><strong>Partitioning/Sharding:</strong> For write scalability and large datasets</li>
                    <li><strong>Caching:</strong> For performance (reduce latency and load)</li>
                    <li><strong>Consensus protocols:</strong> Agreement despite failures (Paxos, Raft)</li>
                </ul>
            </div>

            <!-- Lecture 2 -->
            <div class="lecture-content" id="lecture2">
                <h1>Lecture 2: Multithreading - Detailed Exam Prep Notes</h1>

                <h2 id="thread-interface">Thread Interface</h2>

                <h3>What Threads Are & Why We Need Them</h3>
                <p><strong>Threads</strong> are independent sequences of execution within the same process that share the same memory space.</p>

                <p><strong>Why we need threads:</strong></p>
                <ul>
                    <li><strong>Concurrency</strong>: Handle multiple tasks simultaneously (e.g., web server handling multiple requests)</li>
                    <li><strong>Performance</strong>: Utilize multiple CPU cores for parallel computation</li>
                    <li><strong>Responsiveness</strong>: Keep UI responsive while doing background work</li>
                    <li><strong>I/O overlap</strong>: Continue processing while waiting for I/O operations</li>
                </ul>

                <p><strong>Key distinction</strong>: Threads share memory (unlike processes), making communication easier but requiring synchronization.</p>

                <h3>Thread Create</h3>
                <p><strong>Purpose</strong>: Spawn a new thread of execution.</p>

                <p><strong>Conceptual operation:</strong></p>
                <pre><code>Original execution:
    main() ‚Üí statement1 ‚Üí statement2 ‚Üí statement3

After thread_create(func):
    main() ‚Üí statement1 ‚Üí thread_create ‚Üí statement2 (continues in parallel)
                               ‚Üì
                         new thread ‚Üí func() ‚Üí executes concurrently</code></pre>

                <p><strong>What happens:</strong></p>
                <ol>
                    <li>OS allocates a new stack for the thread</li>
                    <li>New thread begins executing the specified function</li>
                    <li>Parent thread continues execution immediately (non-blocking)</li>
                    <li>Both threads run concurrently, sharing the same memory</li>
                </ol>

                <h3>Thread Join</h3>
                <p><strong>Purpose</strong>: Wait for a thread to complete and synchronize results.</p>

                <p><strong>Why it's needed:</strong></p>
                <ul>
                    <li>Parent needs results from child thread</li>
                    <li>Prevent premature program termination (main exits before threads finish)</li>
                    <li>Resource cleanup (reclaim thread resources)</li>
                    <li>Establish happens-before relationship for memory consistency</li>
                </ul>

                <div class="visualization">
                    <h3>Thread State Diagram</h3>
                    <div class="viz-controls" style="margin-bottom: 15px;">
                        <button class="btn btn-primary" onclick="threadStateViz.createThread()">Create Thread</button>
                        <button class="btn btn-primary" onclick="threadStateViz.runThread()">Run Thread</button>
                        <button class="btn btn-primary" onclick="threadStateViz.blockThread()">Block Thread</button>
                        <button class="btn btn-primary" onclick="threadStateViz.wakeThread()">Wake Thread</button>
                        <button class="btn btn-secondary" onclick="threadStateViz.reset()">Reset</button>
                    </div>
                    <svg id="thread-state-viz" width="100%" height="400" style="background: white; border-radius: 8px;"></svg>
                </div>

                <h2 id="mutex-mutual-exclusion">Mutex (Mutual Exclusion)</h2>

                <h3>What a Mutex Is & Why It's Needed</h3>
                <p><strong>Mutex</strong> (mutual exclusion lock) ensures only one thread at a time can access a critical section.</p>

                <p><strong>Why we need mutexes:</strong></p>
                <p><strong>Problem - Race condition example:</strong></p>
                <pre><code>// Two threads executing this simultaneously:
balance = balance + 100

// Assembly-level operations:
Thread 1: LOAD balance ‚Üí register (1000)
Thread 2: LOAD balance ‚Üí register (1000)  ‚Üê loaded old value!
Thread 1: ADD 100 ‚Üí register (1100)
Thread 2: ADD 100 ‚Üí register (1100)
Thread 1: STORE register ‚Üí balance (1100)
Thread 2: STORE register ‚Üí balance (1100)  ‚Üê overwrites Thread 1's work!

// Expected: 1200, Actual: 1100 (lost update!)</code></pre>

                <p><strong>Solution: Mutex protects critical section:</strong></p>
                <pre><code>mutex.Lock()
balance = balance + 100  // Only one thread executes this at a time
mutex.Unlock()</code></pre>

                <h3>Lock Operation</h3>
                <p><strong>What it does:</strong></p>
                <ul>
                    <li>Attempts to acquire exclusive ownership of the mutex</li>
                    <li>If mutex is free: acquires it and continues</li>
                    <li>If mutex is held: <strong>blocks</strong> until it becomes available</li>
                </ul>

                <h3>Unlock Operation</h3>
                <p><strong>What it does:</strong></p>
                <ul>
                    <li>Releases ownership of the mutex</li>
                    <li>Wakes up one waiting thread (if any)</li>
                    <li>Makes mutex available for acquisition</li>
                </ul>

                <div class="visualization">
                    <h3>Mutex Lock/Unlock Animation</h3>
                    <div class="viz-controls" style="margin-bottom: 15px;">
                        <button class="btn btn-primary" onclick="mutexViz.thread1Lock()">Thread 1: Lock</button>
                        <button class="btn btn-primary" onclick="mutexViz.thread2Lock()">Thread 2: Lock</button>
                        <button class="btn btn-primary" onclick="mutexViz.thread3Lock()">Thread 3: Lock</button>
                        <button class="btn btn-secondary" onclick="mutexViz.unlock()">Unlock</button>
                        <button class="btn btn-secondary" onclick="mutexViz.reset()">Reset</button>
                    </div>
                    <svg id="mutex-viz" width="100%" height="450" style="background: white; border-radius: 8px;"></svg>
                </div>

                <h2 id="condition-variables">Condition Variables</h2>

                <h3>What Condition Variables Are & Why They're Needed</h3>
                <p><strong>Condition Variable</strong> allows threads to wait for specific conditions to become true and to signal when conditions change.</p>

                <p><strong>The problem they solve:</strong></p>
                <p><strong>Bad approach (busy waiting):</strong></p>
                <pre><code>// Consumer waiting for data
for {
    mutex.Lock()
    if len(queue) > 0 {
        item = queue[0]
        queue = queue[1:]
        mutex.Unlock()
        break
    }
    mutex.Unlock()
    // Wastes CPU spinning!
}</code></pre>

                <p><strong>Good approach (condition variable):</strong></p>
                <pre><code>mutex.Lock()
for len(queue) == 0 {
    cond.Wait()  // Efficiently sleeps until signaled
}
item = queue[0]
queue = queue[1:]
mutex.Unlock()</code></pre>

                <h3>Wait Operation</h3>
                <p><strong>What it does:</strong></p>
                <ol>
                    <li><strong>Atomically</strong> releases the mutex</li>
                    <li>Puts thread to sleep (on wait queue)</li>
                    <li>When signaled, wakes up</li>
                    <li><strong>Automatically re-acquires</strong> the mutex before returning</li>
                    <li>Returns with mutex held</li>
                </ol>

                <p><strong>Critical requirement: CALLER MUST HOLD THE MUTEX</strong></p>

                <p><strong>CRITICAL PATTERN - Always use while/for loop:</strong></p>
                <pre><code>mutex.Lock()
for !condition {  // NOT "if" - use "for"/"while"!
    cond.Wait()
}
// Condition is true and mutex is held
performAction()
mutex.Unlock()</code></pre>

                <p><strong>Why loop instead of if:</strong></p>
                <ol>
                    <li><strong>Spurious wakeups</strong>: OS might wake thread even without signal</li>
                    <li><strong>Multiple waiters</strong>: Another thread might consume the resource first</li>
                    <li><strong>Broadcast</strong>: Multiple threads wake up, only one gets the resource</li>
                    <li><strong>Mesa semantics</strong>: Condition might change between signal and wakeup</li>
                </ol>

                <h3>Signal Operation</h3>
                <p><strong>What it does:</strong></p>
                <ul>
                    <li>Wakes up <strong>one</strong> waiting thread (if any)</li>
                    <li>If no threads waiting: signal is lost (not queued)</li>
                    <li>Does NOT release the mutex</li>
                </ul>

                <h3>Broadcast Operation</h3>
                <p><strong>What it does:</strong></p>
                <ul>
                    <li>Wakes up <strong>all</strong> waiting threads</li>
                    <li>All awakened threads compete for the mutex</li>
                    <li>Only one acquires mutex first, others wait</li>
                </ul>

                <div class="visualization">
                    <h3>Condition Variable Wait/Signal/Broadcast Animation</h3>
                    <div class="viz-controls" style="margin-bottom: 15px;">
                        <button class="btn btn-primary" onclick="condVarViz.addWaiter()">Add Waiting Thread</button>
                        <button class="btn btn-primary" onclick="condVarViz.signal()">Signal (Wake One)</button>
                        <button class="btn btn-primary" onclick="condVarViz.broadcast()">Broadcast (Wake All)</button>
                        <button class="btn btn-secondary" onclick="condVarViz.reset()">Reset</button>
                    </div>
                    <svg id="condvar-viz" width="100%" height="400" style="background: white; border-radius: 8px;"></svg>
                </div>

                <h2 id="go-implementations">Go Implementations</h2>

                <h3>Goroutines</h3>
                <p><strong>What they are:</strong></p>
                <ul>
                    <li>Lightweight threads managed by Go runtime (not OS threads)</li>
                    <li>Multiplexed onto OS threads by Go scheduler</li>
                    <li>Very cheap to create (starts with 2KB stack, grows as needed)</li>
                </ul>

                <p><strong>Creation:</strong></p>
                <pre><code>go functionName(args)  // Spawn new goroutine
go func() {            // Anonymous function
    // Concurrent work
}()</code></pre>

                <p><strong>Common gotcha:</strong></p>
                <pre><code>// WRONG: All goroutines see final value of i
for i := 0; i < 10; i++ {
    go func() {
        fmt.Println(i)  // Captures i by reference, likely prints 10 ten times
    }()
}

// CORRECT: Pass i as argument
for i := 0; i < 10; i++ {
    go func(val int) {
        fmt.Println(val)  // Prints 0-9 in some order
    }(i)
}</code></pre>

                <h3>sync.WaitGroup</h3>
                <p><strong>Purpose</strong>: Wait for a collection of goroutines to complete (like joining multiple threads).</p>

                <p><strong>Three operations:</strong></p>
                <ol>
                    <li><strong>Add(delta)</strong>: Increment counter by delta (usually Add(1) before launching goroutine)</li>
                    <li><strong>Done()</strong>: Decrement counter by 1 (call when goroutine completes)</li>
                    <li><strong>Wait()</strong>: Block until counter reaches 0</li>
                </ol>

                <p><strong>Typical pattern:</strong></p>
                <pre><code>var wg sync.WaitGroup

for i := 0; i < 10; i++ {
    wg.Add(1)  // Increment before launching
    go func(id int) {
        defer wg.Done()  // Decrement when done (even if panic)
        doWork(id)
    }(i)
}

wg.Wait()  // Block until all 10 goroutines call Done()
fmt.Println("All work complete")</code></pre>

                <h3>Channels</h3>
                <p><strong>What they are:</strong></p>
                <ul>
                    <li>Typed conduits for communication between goroutines</li>
                    <li>Built-in synchronization (thread-safe)</li>
                    <li>Can be buffered or unbuffered</li>
                </ul>

                <p><strong>Unbuffered channel (synchronous):</strong></p>
                <pre><code>ch := make(chan int)  // No buffer

// Send blocks until receiver is ready
ch <- 42  // Sender waits

// Receive blocks until sender sends
val := <-ch  // Receiver waits</code></pre>

                <p><strong>Buffered channel (asynchronous up to capacity):</strong></p>
                <pre><code>ch := make(chan int, 3)  // Buffer of 3

ch <- 1  // Doesn't block (buffer has space)
ch <- 2  // Doesn't block
ch <- 3  // Doesn't block
ch <- 4  // BLOCKS until someone receives

val := <-ch  // Doesn't block (buffer has data)</code></pre>

                <h3>sync.Mutex</h3>
                <p><strong>Go's mutex implementation:</strong></p>
                <pre><code>var mu sync.Mutex

mu.Lock()    // Acquire lock (blocks if held)
// Critical section
mu.Unlock()  // Release lock

// Best practice: defer unlock
mu.Lock()
defer mu.Unlock()
// Critical section - automatically unlocked on return/panic</code></pre>

                <p><strong>Important Go-specific details:</strong></p>
                <ol>
                    <li><strong>Not reentrant</strong>: Same goroutine locking twice deadlocks</li>
                    <li><strong>Zero value is unlocked</strong>: Can use without initialization</li>
                    <li><strong>Should not be copied</strong>: Mutex contains state; copying breaks it</li>
                </ol>

                <h3>sync.Cond</h3>
                <p><strong>Go's condition variable implementation:</strong></p>
                <pre><code>var mu sync.Mutex
cond := sync.NewCond(&mu)  // Must pass mutex to NewCond

// Waiter
mu.Lock()
for !condition {
    cond.Wait()  // Releases mu, sleeps, re-acquires mu
}
// Condition true, mu held
doWork()
mu.Unlock()

// Signaler
mu.Lock()
condition = true
cond.Signal()    // Wake one waiter
// or cond.Broadcast()  // Wake all waiters
mu.Unlock()</code></pre>

                <h2 id="common-patterns">Common Patterns & Best Practices</h2>

                <h3>Producer-Consumer Pattern</h3>
                <p><strong>With channels (idiomatic Go):</strong></p>
                <pre><code>func producer(ch chan<- int) {
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)  // Signal completion
}

func consumer(ch <-chan int) {
    for item := range ch {  // Exits when channel closed
        process(item)
    }
}

ch := make(chan int, 5)  // Buffered channel
go producer(ch)
consumer(ch)  // Runs in main goroutine</code></pre>

                <h3>Critical Best Practices</h3>
                <ol>
                    <li><strong>Always use defer with Unlock</strong></li>
                    <li><strong>Keep critical sections small</strong></li>
                    <li><strong>Avoid nested locks (deadlock risk)</strong></li>
                    <li><strong>Use channels for communication, mutexes for state</strong></li>
                    <li><strong>Close channels from sender side</strong></li>
                </ol>

                <h2>Common Exam Questions</h2>

                <h3>Conceptual Questions to Prepare For:</h3>
                <ol>
                    <li><strong>Why can't we use busy-waiting instead of condition variables?</strong><br>
                        Answer: Wastes CPU, potential race condition in check-and-wait</li>

                    <li><strong>Why must Wait() be called in a loop (while/for) instead of if?</strong><br>
                        Answer: Spurious wakeups, multiple waiters, condition might change before reacquiring lock</li>

                    <li><strong>Why does Wait() release and re-acquire the mutex?</strong><br>
                        Release: Allow other threads to modify condition<br>
                        Atomic release+sleep: Prevent lost wakeup<br>
                        Re-acquire: Make condition check thread-safe</li>

                    <li><strong>When to use Signal vs Broadcast?</strong><br>
                        Signal: One resource available, one thread should proceed<br>
                        Broadcast: Multiple threads affected, shutdown, or unsure which should wake</li>

                    <li><strong>Difference between goroutines and OS threads?</strong><br>
                        Goroutines: Lightweight, Go-runtime scheduled, growable stacks<br>
                        Threads: Heavy, OS-scheduled, fixed stack</li>

                    <li><strong>When to use channels vs mutexes in Go?</strong><br>
                        Channels: Communication, passing data, orchestration<br>
                        Mutexes: Protecting shared state, guarding invariants</li>
                </ol>
            </div>

            <!-- Lecture 3 -->
            <div class="lecture-content" id="lecture3">
                <h1>Lecture 3: Remote Procedure Call (RPC) - Detailed Study Notes</h1>

                <h2>Overview</h2>
                <p>RPC is a fundamental building block for distributed systems that makes remote function calls appear like local function calls, hiding the complexity of network communication.</p>

                <hr>

                <h2>1. Remote Procedure Call (RPC) Concept</h2>

                <h3>What is RPC?</h3>
                <ul>
                    <li>A mechanism that allows a program to execute a function on a <strong>remote machine</strong> as if it were a local function call</li>
                    <li>The <strong>client waits</strong> (blocks) while the remote function executes, just like a normal function call</li>
                    <li>Returns the result to the caller when complete</li>
                </ul>

                <h3>Key Characteristics</h3>
                <ul>
                    <li><strong>Synchronous</strong>: Client blocks until the RPC completes</li>
                    <li><strong>Transparent</strong>: Ideally, programmer shouldn't need to worry about the fact that it's remote</li>
                    <li><strong>Request-Response pattern</strong>: Client sends request, waits for server response</li>
                </ul>

                <h3>Why RPC Exists</h3>
                <p><strong>Problem it solves</strong>: Without RPC, distributed programming is painful</p>
                <ul>
                    <li>Manually handling sockets, serialization, network errors</li>
                    <li>Different programming paradigms for local vs. remote calls</li>
                    <li>Complex error handling for network failures</li>
                </ul>

                <p><strong>Benefits</strong>:</p>
                <ul>
                    <li>Makes distributed programming look like regular programming</li>
                    <li>Simplifies client-server architecture</li>
                    <li>Allows reuse of familiar programming patterns</li>
                    <li>Enables building distributed systems more easily</li>
                </ul>

                <h3>Example Flow</h3>
                <pre><code>Client Code:
    result = remote_function(arg1, arg2)  // Looks like local call!
    print(result)

What Actually Happens:
    1. Client blocks/waits
    2. Arguments sent over network
    3. Server executes function
    4. Result sent back over network
    5. Client resumes with result</code></pre>

                <div class="visualization">
                    <h3>RPC Message Flow Diagram</h3>
                    <div class="viz-canvas" id="rpc-flow-canvas">
                        <svg width="100%" height="350" id="rpc-flow-svg">
                            <!-- SVG will be populated by JavaScript -->
                        </svg>
                    </div>
                    <div style="margin-top: 15px; text-align: center;">
                        <button class="btn btn-primary" onclick="animateRPCFlow()">‚ñ∂ Animate RPC Flow</button>
                        <button class="btn btn-secondary" onclick="resetRPCFlow()">‚Ü∫ Reset</button>
                    </div>
                </div>

                <hr>

                <h2>2. Stub Functions</h2>

                <h3>What are Stubs?</h3>
                <ul>
                    <li><strong>Local proxy functions</strong> that have the <strong>same signature</strong> as the remote function</li>
                    <li>Sits between your code and the network layer</li>
                    <li>Two types:
                        <ul>
                            <li><strong>Client stub</strong>: Called by client, sends RPC request</li>
                            <li><strong>Server stub</strong>: Receives request, calls actual function on server</li>
                        </ul>
                    </li>
                </ul>

                <h3>How Stubs Work</h3>
                <p><strong>Client-side stub</strong>:</p>
                <pre><code>def remote_function(arg1, arg2):  // This is the stub
    # 1. Marshal arguments into bytes
    # 2. Send request over network
    # 3. Wait for response
    # 4. Unmarshal response
    # 5. Return result</code></pre>

                <p><strong>Server-side stub</strong>:</p>
                <pre><code># Receives network request
def handle_request(request_bytes):
    # 1. Unmarshal arguments from bytes
    # 2. Call the REAL function
    result = actual_remote_function(arg1, arg2)
    # 3. Marshal result
    # 4. Send response back</code></pre>

                <h3>Why Stubs Exist</h3>
                <p><strong>Problem</strong>: Need to hide network complexity from programmer</p>
                <p><strong>Solution</strong>: Stubs provide:</p>
                <ul>
                    <li><strong>Same interface</strong> as if function were local</li>
                    <li>Automatic handling of network communication</li>
                    <li>Separation of concerns (business logic vs. network code)</li>
                </ul>

                <h3>Key Property</h3>
                <ul>
                    <li><strong>Signature matching</strong>: Stub must have identical function signature
                        <ul>
                            <li>Same function name</li>
                            <li>Same parameter types</li>
                            <li>Same return type</li>
                        </ul>
                    </li>
                    <li>This allows drop-in replacement: change local call to remote call without changing code structure</li>
                </ul>

                <hr>

                <h2>3. Marshalling</h2>

                <h3>What is Marshalling?</h3>
                <ul>
                    <li><strong>Converting arguments and return values into bytes</strong> for network transmission</li>
                    <li>Also called <strong>serialization</strong></li>
                    <li>Opposite process: <strong>Unmarshalling</strong> (deserialization) - bytes back to data structures</li>
                </ul>

                <h3>Why Marshalling Exists</h3>
                <p><strong>Problem</strong>: Network can only send bytes, but programs use complex data types</p>
                <ul>
                    <li>Integers, strings, objects, arrays, pointers, etc.</li>
                    <li>Different machines may have different:
                        <ul>
                            <li>Endianness (byte order)</li>
                            <li>Data type sizes</li>
                            <li>Memory layouts</li>
                        </ul>
                    </li>
                </ul>

                <p><strong>Solution</strong>: Standard format for converting data to bytes</p>
                <ul>
                    <li>Both sides agree on encoding format</li>
                    <li>Handles platform differences</li>
                    <li>Preserves data meaning across machines</li>
                </ul>

                <h3>What Gets Marshalled?</h3>
                <ul>
                    <li><strong>Function arguments</strong> (client ‚Üí server)</li>
                    <li><strong>Return values</strong> (server ‚Üí client)</li>
                    <li>Potentially <strong>exceptions/errors</strong></li>
                </ul>

                <h3>Marshalling Challenges</h3>
                <ol>
                    <li><strong>Complex data structures</strong>: How to serialize linked lists, trees, graphs?</li>
                    <li><strong>Pointers</strong>: Cannot send memory addresses (meaningless on remote machine)</li>
                    <li><strong>Platform differences</strong>: Must handle endianness, word sizes</li>
                    <li><strong>Efficiency</strong>: Marshalling adds overhead</li>
                </ol>

                <h3>Example</h3>
                <pre><code>Client side:
    Arguments: (42, "hello", [1, 2, 3])
    Marshalled: &lt;binary bytes representing these values&gt;

Server side:
    Receives: &lt;binary bytes&gt;
    Unmarshalled: (42, "hello", [1, 2, 3])
    Executes: function(42, "hello", [1, 2, 3])</code></pre>

                <hr>

                <h2>4. IDL - Interface Definition Language</h2>

                <h3>What is IDL?</h3>
                <ul>
                    <li>A <strong>language-agnostic specification</strong> for defining RPC interfaces</li>
                    <li>Describes:
                        <ul>
                            <li>Function names</li>
                            <li>Parameter types</li>
                            <li>Return types</li>
                            <li>Data structures</li>
                        </ul>
                    </li>
                </ul>

                <h3>Why IDL Exists</h3>
                <p><strong>Problem</strong>: How do client and server agree on interface, especially if written in different languages?</p>
                <p><strong>Solution</strong>: IDL as a contract</p>
                <ul>
                    <li>Write interface once in IDL</li>
                    <li><strong>Generate stubs automatically</strong> for both client and server</li>
                    <li>Can generate code for different programming languages</li>
                    <li>Ensures client and server agree on protocol</li>
                </ul>

                <h3>How IDL Works</h3>
                <ol>
                    <li><strong>Define interface</strong> in IDL file</li>
                    <li><strong>Run IDL compiler</strong> (code generator)</li>
                    <li><strong>Generates</strong>:
                        <ul>
                            <li>Client stub</li>
                            <li>Server stub</li>
                            <li>Marshalling/unmarshalling code</li>
                            <li>Data type definitions</li>
                        </ul>
                    </li>
                </ol>

                <h3>Example IDL (pseudo-syntax)</h3>
                <pre><code>interface Calculator {
    int add(int a, int b);
    float divide(float numerator, float denominator);
    string concat(string s1, string s2);
}</code></pre>

                <p>From this, IDL compiler generates:</p>
                <ul>
                    <li>C++ client stub + server stub</li>
                    <li>Python client stub + server stub</li>
                    <li>Java client stub + server stub</li>
                    <li>All interoperable!</li>
                </ul>

                <h3>Benefits</h3>
                <ul>
                    <li><strong>Language independence</strong>: Python client can call Java server</li>
                    <li><strong>Automatic code generation</strong>: Less manual work, fewer bugs</li>
                    <li><strong>Versioning</strong>: Can track interface changes</li>
                    <li><strong>Documentation</strong>: IDL serves as specification</li>
                </ul>

                <h3>Examples of Real IDL Systems</h3>
                <ul>
                    <li><strong>Protocol Buffers</strong> (Google)</li>
                    <li><strong>Thrift</strong> (Facebook/Apache)</li>
                    <li><strong>gRPC</strong> (Google)</li>
                    <li><strong>CORBA IDL</strong></li>
                </ul>

                <hr>

                <h2>5. Drawbacks and Failure Modes</h2>

                <h3>Key Drawback: Networks are Unreliable</h3>
                <p><strong>Unlike local function calls, RPC can fail in many ways:</strong></p>

                <h3>Failure Modes</h3>

                <h4>1. Network Packet Loss</h4>
                <ul>
                    <li>Request lost ‚Üí server never receives it</li>
                    <li>Response lost ‚Üí server executed but client doesn't know</li>
                </ul>

                <h4>2. Network Delay</h4>
                <ul>
                    <li>Request delayed ‚Üí client times out, but server eventually processes</li>
                    <li>Response delayed ‚Üí client times out, server already finished</li>
                </ul>

                <h4>3. Server Crashes</h4>
                <ul>
                    <li><strong>Before execution</strong>: Request arrives, server crashes before running function</li>
                    <li><strong>During execution</strong>: Server crashes mid-function</li>
                    <li><strong>After execution</strong>: Server finishes but crashes before sending response</li>
                </ul>

                <h4>4. Client Crashes</h4>
                <ul>
                    <li>Client crashes after sending request</li>
                    <li>Server executes but no one receives response</li>
                </ul>

                <h3>Why These Matter</h3>
                <p><strong>Local function calls</strong>:</p>
                <ul>
                    <li>Either succeeds or crashes entire program</li>
                    <li>No ambiguity</li>
                </ul>

                <p><strong>RPC</strong>:</p>
                <ul>
                    <li>Many failure modes with <strong>ambiguous outcomes</strong></li>
                    <li>Did the function execute or not?</li>
                    <li>Did it execute multiple times?</li>
                    <li>Cannot always distinguish between different failures</li>
                </ul>

                <h3>The Fundamental Problem</h3>
                <p><strong>When RPC times out, you don't know</strong>:</p>
                <ul>
                    <li>‚ùì Did request never arrive?</li>
                    <li>‚ùì Did server crash before execution?</li>
                    <li>‚ùì Did server execute but response got lost?</li>
                    <li>‚ùì Did server execute but is just slow?</li>
                </ul>
                <p><strong>This ambiguity is unavoidable in distributed systems!</strong></p>

                <div class="visualization">
                    <h3>Failure Scenario Simulator</h3>
                    <div class="viz-canvas" id="failure-canvas" style="min-height: 400px;">
                        <svg width="100%" height="400" id="failure-svg">
                            <!-- SVG will be populated by JavaScript -->
                        </svg>
                    </div>
                    <div style="margin-top: 15px; text-align: center;">
                        <button class="btn btn-primary" onclick="simulateFailure('request-lost')">Request Lost</button>
                        <button class="btn btn-primary" onclick="simulateFailure('response-lost')">Response Lost</button>
                        <button class="btn btn-primary" onclick="simulateFailure('crash-before')">Crash Before Execution</button>
                        <button class="btn btn-primary" onclick="simulateFailure('crash-after')">Crash After Execution</button>
                        <button class="btn btn-secondary" onclick="resetFailureSimulator()">‚Ü∫ Reset</button>
                    </div>
                    <div id="failure-description" style="margin-top: 15px; padding: 15px; background: var(--background); border-radius: 8px; font-size: 0.95rem;"></div>
                </div>

                <h3>Other Drawbacks</h3>

                <h4>Performance</h4>
                <ul>
                    <li>Much slower than local calls (network latency)</li>
                    <li>Marshalling/unmarshalling overhead</li>
                </ul>

                <h4>Partial Failures</h4>
                <ul>
                    <li>Some machines can fail while others work</li>
                    <li>Harder to reason about system state</li>
                </ul>

                <h4>Transparency is a Lie</h4>
                <ul>
                    <li>Cannot truly hide that it's remote</li>
                    <li>Different failure semantics force programmer to think about distribution</li>
                </ul>

                <hr>

                <h2>6. Fault Tolerance Strategies</h2>
                <p>Two main approaches to handle failures: <strong>At-Least-Once</strong> and <strong>At-Most-Once</strong></p>

                <div class="visualization">
                    <h3>At-Least-Once vs At-Most-Once Interactive Comparison</h3>
                    <div class="viz-canvas" id="comparison-canvas" style="min-height: 450px; flex-direction: column;">
                        <div style="display: flex; gap: 20px; width: 100%; padding: 20px;">
                            <div style="flex: 1; text-align: center;">
                                <h4 style="color: var(--primary); margin-bottom: 10px;">At-Least-Once</h4>
                                <svg width="100%" height="300" id="atleast-svg"></svg>
                                <div id="atleast-status" style="margin-top: 10px; font-weight: 600;"></div>
                            </div>
                            <div style="flex: 1; text-align: center;">
                                <h4 style="color: var(--secondary); margin-bottom: 10px;">At-Most-Once</h4>
                                <svg width="100%" height="300" id="atmost-svg"></svg>
                                <div id="atmost-status" style="margin-top: 10px; font-weight: 600;"></div>
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 15px; text-align: center;">
                        <button class="btn btn-primary" onclick="runComparison('normal')">‚úì Normal Case</button>
                        <button class="btn btn-primary" onclick="runComparison('response-lost')">‚úó Response Lost</button>
                        <button class="btn btn-primary" onclick="runComparison('delayed')">‚è± Delayed Response</button>
                        <button class="btn btn-secondary" onclick="resetComparison()">‚Ü∫ Reset</button>
                    </div>
                    <div id="comparison-explanation" style="margin-top: 15px; padding: 15px; background: var(--background); border-radius: 8px;"></div>
                </div>

                <hr>

                <h3>Strategy 1: At-Least-Once Semantics</h3>

                <h4>How It Works</h4>
                <ol>
                    <li>Client sends RPC request</li>
                    <li>Client <strong>waits for response</strong> with timeout</li>
                    <li><strong>If timeout</strong>: Re-transmit request (assume request or response was lost)</li>
                    <li><strong>Repeat</strong> until response received (or give up after N attempts)</li>
                </ol>

                <h4>Guarantees</h4>
                <ul>
                    <li><strong>At least once</strong>: Function executes <strong>one or more times</strong></li>
                    <li>May execute multiple times if:
                        <ul>
                            <li>Response was lost (not request)</li>
                            <li>Response delayed (client already retried)</li>
                        </ul>
                    </li>
                </ul>

                <h4>Example Scenario</h4>
                <pre><code>Client: add_to_cart(item_id=42)
    ‚Üí Request sent
    ‚Üí Response lost in network
    ‚Üí Timeout!
    ‚Üí Re-send request
    ‚Üí Server executes AGAIN (item added twice!)
    ‚Üí Response received</code></pre>

                <h4>When It's Safe: Idempotent Operations</h4>
                <p><strong>Idempotent</strong>: Executing multiple times has same effect as once</p>

                <p><strong>Safe examples</strong>:</p>
                <ul>
                    <li><code>read_temperature()</code> - reading is idempotent</li>
                    <li><code>set_value(x, 10)</code> - setting same value repeatedly is fine</li>
                    <li><code>get_user_info(user_id)</code> - queries are typically idempotent</li>
                </ul>

                <p><strong>Unsafe examples</strong>:</p>
                <ul>
                    <li><code>increment_counter()</code> - executing twice increments by 2!</li>
                    <li><code>add_to_cart()</code> - adds item multiple times</li>
                    <li><code>send_payment()</code> - charges customer multiple times!</li>
                    <li><code>delete_file()</code> - first deletes, second might error</li>
                </ul>

                <h4>Tradeoffs</h4>
                <p><strong>Pros</strong>:</p>
                <ul>
                    <li>‚úÖ Simple to implement</li>
                    <li>‚úÖ Guarantees execution (if server eventually responds)</li>
                    <li>‚úÖ Good for read operations</li>
                </ul>

                <p><strong>Cons</strong>:</p>
                <ul>
                    <li>‚ùå May execute multiple times</li>
                    <li>‚ùå Only safe for idempotent operations</li>
                    <li>‚ùå Can cause duplicate side effects</li>
                </ul>

                <hr>

                <h3>Strategy 2: At-Most-Once Semantics</h3>

                <h4>How It Works</h4>
                <p>Goal: <strong>Ensure each RPC executes 0 or 1 times, never more</strong></p>

                <p><strong>Key mechanism</strong>: Give each RPC a <strong>unique ID</strong></p>
                <ol>
                    <li>Client assigns unique ID to each RPC</li>
                    <li>Server tracks which RPCs it has executed</li>
                    <li>If duplicate request arrives, server returns <strong>cached response</strong> instead of re-executing</li>
                </ol>

                <h4>The Unique ID System</h4>

                <p><strong>Problem</strong>: How to generate unique IDs across client restarts?</p>
                <p><strong>Solution</strong>: <strong>Epoch-based ID</strong> = <code>(epoch, sequence_number)</code></p>

                <div class="visualization">
                    <h3>Unique ID Generation Demo</h3>
                    <div class="viz-canvas" id="uniqueid-canvas" style="min-height: 300px; flex-direction: column; justify-content: flex-start; padding: 20px;">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 1.2rem; margin-bottom: 10px;">Current Epoch: <span id="current-epoch" style="color: var(--primary); font-weight: bold;">1000</span></div>
                            <div style="font-size: 1.2rem; margin-bottom: 20px;">Sequence Number: <span id="current-seq" style="color: var(--secondary); font-weight: bold;">0</span></div>
                            <div style="font-size: 1.5rem; padding: 15px; background: var(--background); border-radius: 8px; margin-bottom: 20px;">
                                Next RPC ID: (<span id="next-epoch" style="color: var(--primary);">1000</span>, <span id="next-seq" style="color: var(--secondary);">0</span>)
                            </div>
                        </div>
                        <div id="rpc-history" style="max-height: 150px; overflow-y: auto; width: 100%; background: white; padding: 10px; border-radius: 8px; font-family: monospace; font-size: 0.9rem;"></div>
                    </div>
                    <div style="margin-top: 15px; text-align: center;">
                        <button class="btn btn-primary" onclick="sendRPC()">üì§ Send RPC</button>
                        <button class="btn btn-primary" onclick="rebootClient()">üîÑ Reboot Client</button>
                        <button class="btn btn-secondary" onclick="resetUniqueIDDemo()">‚Ü∫ Reset</button>
                    </div>
                </div>

                <h5>Epoch Component</h5>
                <ul>
                    <li><strong>Epoch</strong> = Boot time / Reboot time (timestamp when client started)</li>
                    <li>Changes on every client restart</li>
                    <li>Ensures IDs from different client incarnations don't collide</li>
                </ul>

                <h5>Sequence Number Component</h5>
                <ul>
                    <li><strong>Monotonically increasing</strong> counter within current epoch</li>
                    <li>Starts at 0 on each boot</li>
                    <li>Increments for each new RPC</li>
                </ul>

                <h5>Combined Unique ID</h5>
                <pre><code>RPC_ID = (client_epoch, sequence_number)

Examples:
    First RPC after boot at time 1000:  (1000, 0)
    Second RPC:                         (1000, 1)
    Third RPC:                          (1000, 2)

    [Client reboots at time 2000]

    First RPC after reboot:             (2000, 0)  // Different from (1000, 0)!
    Second RPC:                         (2000, 1)</code></pre>

                <p><strong>Why this works</strong>:</p>
                <ul>
                    <li>Different client instances have different epochs</li>
                    <li>Within an instance, sequence numbers don't repeat</li>
                    <li>Together: globally unique</li>
                </ul>

                <h4>Server-Side Implementation</h4>

                <p><strong>Server maintains</strong>:</p>
                <ol>
                    <li><strong>Table of executed RPCs</strong>: <code>{RPC_ID ‚Üí response}</code></li>
                    <li><strong>Discards old entries</strong> after client confirms receipt or timeout</li>
                </ol>

                <p><strong>When request arrives</strong>:</p>
                <pre><code>if RPC_ID in executed_table:
    # This is a duplicate retry
    return cached_response  // Don't execute again!
else:
    # This is a new request
    result = execute_function()
    executed_table[RPC_ID] = result
    return result</code></pre>

                <h4>Example Scenario</h4>
                <pre><code>Client (epoch=1000):
    RPC 1: (1000, 0) add_to_cart(item=42)
        ‚Üí Server executes, caches response
        ‚Üí Response lost

    Client retries: (1000, 0) add_to_cart(item=42)
        ‚Üí Server sees duplicate ID
        ‚Üí Returns cached response WITHOUT executing again
        ‚Üí Item only added once! ‚úì</code></pre>

                <h4>Tradeoffs</h4>
                <p><strong>Pros</strong>:</p>
                <ul>
                    <li>‚úÖ Safe for non-idempotent operations</li>
                    <li>‚úÖ Prevents duplicate side effects</li>
                    <li>‚úÖ Critical for banking, e-commerce, etc.</li>
                </ul>

                <p><strong>Cons</strong>:</p>
                <ul>
                    <li>‚ùå More complex implementation</li>
                    <li>‚ùå Server must store state (executed RPCs table)</li>
                    <li>‚ùå Memory overhead for caching responses</li>
                    <li>‚ùå Must handle table cleanup</li>
                </ul>

                <hr>

                <h2>7. Detailed Crash Scenarios (At-Most-Once)</h2>

                <h3>Scenario 1: Response Lost</h3>
                <p><strong>Timeline</strong>:</p>
                <ol>
                    <li>Client sends: <code>(1000, 5)</code> with arguments</li>
                    <li>Server receives, executes function successfully</li>
                    <li>Server caches: <code>(1000, 5) ‚Üí result</code></li>
                    <li><strong>Response packet lost in network</strong></li>
                    <li>Client times out</li>
                    <li>Client retries: <code>(1000, 5)</code> (same ID!)</li>
                    <li>Server checks table, finds <code>(1000, 5)</code> already executed</li>
                    <li>Server returns <strong>cached result</strong> without re-executing</li>
                </ol>
                <p><strong>Outcome</strong>: ‚úÖ Function executed exactly once</p>

                <hr>

                <h3>Scenario 2: Client Crashes Before Response</h3>
                <p><strong>Timeline</strong>:</p>
                <ol>
                    <li>Client (epoch=1000) sends: <code>(1000, 10)</code></li>
                    <li>Server executes, caches result</li>
                    <li>Server sends response</li>
                    <li><strong>Client crashes before receiving response</strong></li>
                    <li>Client reboots ‚Üí <strong>new epoch=2000</strong></li>
                    <li>Client retries same logical request ‚Üí <strong>new ID: (2000, 0)</strong></li>
                    <li>Server sees new ID (different epoch)</li>
                    <li>Server executes again (appears as new request)</li>
                </ol>
                <p><strong>Outcome</strong>: ‚ö†Ô∏è Function executed <strong>twice</strong> (but with different IDs, considered different RPCs)</p>
                <p><strong>Why</strong>: Epoch changed, so server cannot detect it's the "same" request</p>

                <hr>

                <h3>Scenario 3: Server Crashes Before Execution</h3>
                <p><strong>Timeline</strong>:</p>
                <ol>
                    <li>Client sends: <code>(1000, 7)</code></li>
                    <li>Request arrives at server</li>
                    <li><strong>Server crashes before executing</strong></li>
                    <li>Server reboots, loses all state (including executed table)</li>
                    <li>Client retries: <code>(1000, 7)</code></li>
                    <li>Server (after reboot) has no record of <code>(1000, 7)</code></li>
                    <li>Server executes function</li>
                </ol>
                <p><strong>Outcome</strong>: ‚úÖ Function executed exactly once (server crashed before first execution, so retry is first real execution)</p>

                <hr>

                <h3>Scenario 4: Server Crashes After Execution, Before Response</h3>
                <p><strong>Timeline</strong>:</p>
                <ol>
                    <li>Client sends: <code>(1000, 3)</code></li>
                    <li>Server executes function successfully</li>
                    <li>Server caches: <code>(1000, 3) ‚Üí result</code></li>
                    <li><strong>Server crashes before sending response</strong></li>
                    <li>Server reboots ‚Üí <strong>loses executed table</strong> (volatile memory)</li>
                    <li>Client retries: <code>(1000, 3)</code></li>
                    <li>Server has no record (lost in crash)</li>
                    <li>Server executes again</li>
                </ol>
                <p><strong>Outcome</strong>: ‚ö†Ô∏è Function executed <strong>twice</strong></p>
                <p><strong>Why</strong>: Server lost memory of having executed it</p>
                <p><strong>Improvement</strong>: Persist executed table to disk (expensive!)</p>

                <hr>

                <h3>Scenario 5: Server Crashes During Execution</h3>
                <p><strong>Timeline</strong>:</p>
                <ol>
                    <li>Client sends: <code>(1000, 9)</code></li>
                    <li>Server starts executing function</li>
                    <li><strong>Server crashes mid-execution</strong></li>
                    <li>Server reboots</li>
                    <li>Client retries: <code>(1000, 9)</code></li>
                    <li>Server executes (no record of partial execution)</li>
                </ol>
                <p><strong>Outcome</strong>: Depends on what partial execution did</p>
                <ul>
                    <li>If function had side effects before crash ‚Üí <strong>inconsistent state</strong></li>
                    <li>This is why <strong>transactions</strong> are important in distributed systems</li>
                </ul>

                <hr>

                <h3>Scenario 6: Network Partition (Request Delayed, Not Lost)</h3>
                <p><strong>Timeline</strong>:</p>
                <ol>
                    <li>Client sends: <code>(1000, 2)</code></li>
                    <li><strong>Request severely delayed in network</strong> (not lost, just slow)</li>
                    <li>Client times out</li>
                    <li>Client retries: <code>(1000, 2)</code> (same ID)</li>
                    <li><strong>Retry arrives first</strong>, server executes, caches result, responds</li>
                    <li>Client receives response, happy</li>
                    <li><strong>Original delayed request finally arrives</strong></li>
                    <li>Server sees <code>(1000, 2)</code> in table</li>
                    <li>Server returns cached response (doesn't execute again)</li>
                </ol>
                <p><strong>Outcome</strong>: ‚úÖ Function executed exactly once</p>

                <hr>

                <h2>8. At-Least-Once vs. At-Most-Once Comparison</h2>

                <h3>Summary Table</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <thead>
                        <tr style="background: var(--primary); color: white;">
                            <th style="padding: 12px; text-align: left; border: 1px solid var(--border);">Aspect</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid var(--border);">At-Least-Once</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid var(--border);">At-Most-Once</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>Guarantee</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Executes ‚â• 1 times</td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Executes ‚â§ 1 times</td>
                        </tr>
                        <tr style="background: var(--background);">
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>Complexity</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Simple</td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Complex</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>Server state</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Stateless</td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Must track executed RPCs</td>
                        </tr>
                        <tr style="background: var(--background);">
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>Safe for</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Idempotent operations</td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Non-idempotent operations</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>Examples</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Read operations, queries</td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Payments, mutations, deletions</td>
                        </tr>
                        <tr style="background: var(--background);">
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>Network overhead</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Low</td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Higher (IDs, state)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>Memory overhead</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">None</td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Must cache responses</td>
                        </tr>
                        <tr style="background: var(--background);">
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>Failure handling</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Just retry</td>
                            <td style="padding: 10px; border: 1px solid var(--border);">Check table + retry</td>
                        </tr>
                    </tbody>
                </table>

                <h3>When to Use Each</h3>
                <p><strong>Use At-Least-Once when</strong>:</p>
                <ul>
                    <li>Operations are idempotent</li>
                    <li>Simplicity is important</li>
                    <li>Performance is critical</li>
                    <li>Examples: Temperature readings, status checks, log queries</li>
                </ul>

                <p><strong>Use At-Most-Once when</strong>:</p>
                <ul>
                    <li>Operations have non-idempotent side effects</li>
                    <li>Correctness is more important than performance</li>
                    <li>Examples: Financial transactions, shopping cart mutations, account creation</li>
                </ul>

                <h3>Real-World Considerations</h3>
                <p>Many systems use <strong>hybrid approaches</strong>:</p>
                <ul>
                    <li>Read operations: At-least-once (cheap, safe)</li>
                    <li>Write operations: At-most-once (expensive, necessary)</li>
                    <li>Some operations made idempotent by design (e.g., "set" instead of "increment")</li>
                </ul>

                <hr>

                <h2>9. Key Takeaways for Exam</h2>

                <h3>Core Concepts to Remember</h3>
                <ol>
                    <li><strong>RPC makes remote calls look local</strong> but cannot hide failure modes</li>
                    <li><strong>Stubs</strong> provide identical interface, hide marshalling/network</li>
                    <li><strong>Marshalling</strong> converts data structures ‚Üî bytes</li>
                    <li><strong>IDL</strong> defines interface, generates code, enables cross-language RPC</li>
                    <li><strong>Network failures create ambiguity</strong> that local calls don't have</li>
                </ol>

                <h3>Fault Tolerance Deep Understanding</h3>
                <p><strong>At-Least-Once</strong>:</p>
                <ul>
                    <li>Retry until success</li>
                    <li>May execute multiple times</li>
                    <li>Only safe for idempotent operations</li>
                </ul>

                <p><strong>At-Most-Once</strong>:</p>
                <ul>
                    <li>Use unique ID: <code>(epoch, sequence_number)</code></li>
                    <li>Server caches executed RPCs</li>
                    <li>Prevents duplicate execution</li>
                    <li>Required for non-idempotent operations</li>
                </ul>

                <h3>Unique ID System</h3>
                <ul>
                    <li><strong>Epoch</strong>: Reboot timestamp (ensures uniqueness across restarts)</li>
                    <li><strong>Sequence</strong>: Monotonic counter (uniqueness within session)</li>
                    <li><strong>Combined</strong>: Globally unique identifier per RPC</li>
                </ul>

                <h3>Critical Failure Scenarios</h3>
                <ol>
                    <li><strong>Response lost</strong> ‚Üí Retry with same ID ‚Üí Cached response ‚úì</li>
                    <li><strong>Client crash</strong> ‚Üí New epoch ‚Üí Appears as new request ‚Üí Executes again ‚ö†Ô∏è</li>
                    <li><strong>Server crash before execution</strong> ‚Üí Retry executes once ‚úì</li>
                    <li><strong>Server crash after execution</strong> ‚Üí Loses state ‚Üí Executes again ‚ö†Ô∏è</li>
                </ol>

                <h3>What "At-Most-Once" Really Means</h3>
                <ul>
                    <li><strong>Best case</strong>: Executes exactly once</li>
                    <li><strong>Worst case</strong>: Executes zero times (e.g., server permanently down)</li>
                    <li><strong>Guarantee</strong>: NEVER more than once</li>
                    <li><strong>Cannot guarantee execution</strong> (that's at-least-once)</li>
                </ul>

                <hr>

                <h2>10. Practice Questions</h2>

                <h3>Question 1</h3>
                <p><strong>Why can't we use just a sequence number (without epoch) for at-most-once?</strong></p>
                <p><strong>Answer</strong>: Client crashes and reboots, sequence resets to 0. New <code>seq=0</code> would collide with old <code>seq=0</code> from before crash. Server would think it's a duplicate when it's actually a new request.</p>

                <h3>Question 2</h3>
                <p><strong>Is <code>set_temperature(device_id, value)</code> idempotent?</strong></p>
                <p><strong>Answer</strong>: Yes! Setting to same value multiple times has same effect. Safe for at-least-once.</p>

                <h3>Question 3</h3>
                <p><strong>Server executes RPC, then crashes before sending response. Client retries. What happens with at-most-once?</strong></p>
                <p><strong>Answer</strong>: Server lost executed table in crash. Retry appears as new request. Function executes TWICE. At-most-once only works if server state survives crashes (or is persisted).</p>

                <h3>Question 4</h3>
                <p><strong>Why is marshalling necessary?</strong></p>
                <p><strong>Answer</strong>: Networks transmit bytes. Programs use complex types (structs, objects, arrays). Need standard format to convert data ‚Üí bytes ‚Üí data while handling platform differences (endianness, sizes).</p>

                <hr>

                <h2>Study Tips</h2>
                <ol>
                    <li><strong>Draw timelines</strong> for crash scenarios</li>
                    <li><strong>Trace through examples</strong> with specific IDs</li>
                    <li><strong>Think about real applications</strong>: Which need at-most-once? (Banking, shopping) Which can use at-least-once? (Weather queries)</li>
                    <li><strong>Remember the tradeoffs</strong>: Simplicity vs. correctness</li>
                    <li><strong>Understand the fundamental problem</strong>: Network failures create ambiguity that local calls don't have</li>
                </ol>

                <p style="font-weight: bold; color: var(--success); margin-top: 30px;">Good luck on your exam!</p>
            </div>

            <!-- Lecture 4 -->
            <div class="lecture-content" id="lecture4">
                <h1>Lecture 4: MapReduce</h1>

                <h2>Overview</h2>
                <p><strong>What is MapReduce?</strong> A programming model for processing large datasets distributed across thousands of machines.</p>
                <p><strong>Core Idea:</strong></p>
                <ul>
                    <li><strong>Map:</strong> Apply function to each piece of data independently (parallel)</li>
                    <li><strong>Reduce:</strong> Aggregate mapped results by key to produce final output</li>
                </ul>

                <h2>The 4-Step Process</h2>

                <h3>Step 1: Split Data into M Pieces</h3>
                <ul>
                    <li><strong>Who:</strong> Transaction Coordinator (TC)</li>
                    <li><strong>What:</strong> Divides input into M chunks for parallel processing</li>
                </ul>

                <h3>Step 2: Map Phase (Produce Local Word Counts)</h3>
                <ul>
                    <li><strong>Who:</strong> M Mapper workers</li>
                    <li><strong>What:</strong> Each mapper applies Map function, produces intermediate key-value pairs</li>
                    <li><strong>Example:</strong> "the cat sat" ‚Üí [("the", 1), ("cat", 1), ("sat", 1)]</li>
                </ul>

                <h3>Step 3: Write Intermediates to Mapper Disk</h3>
                <ul>
                    <li>Mappers partition output into R groups (one per reducer)</li>
                    <li>Write to <strong>LOCAL disk</strong> (NOT NFS)</li>
                    <li>Files named: M1_R1, M1_R2, ..., M1_R, M2_R1, etc.</li>
                    <li><strong>Why local?</strong> Performance (10-100x faster), saves network bandwidth, temporary data</li>
                </ul>

                <h3>Step 4: Reduce Phase</h3>
                <ul>
                    <li><strong>Who:</strong> R Reducer workers</li>
                    <li><strong>What:</strong> Fetch data from all mappers, sort/group by key, apply Reduce function</li>
                    <li>Write final output to <strong>NFS</strong></li>
                    <li><strong>Why NFS?</strong> Durability, accessibility, expensive to recompute</li>
                </ul>

                <h2>System Components</h2>

                <h3>Transaction Coordinator (TC)</h3>
                <ul>
                    <li>Splits data into M chunks</li>
                    <li>Spawns M mappers, gives them data + Map function</li>
                    <li>Receives location data from mappers</li>
                    <li>Spawns R reducers, sends them location data</li>
                    <li>Monitors health via pings, handles failures</li>
                </ul>

                <h3>Mappers (M workers)</h3>
                <ul>
                    <li>Must know <strong>R</strong> (number of reducers) to partition correctly</li>
                    <li>Must know <strong>partition logic</strong> (e.g., hash(key) mod R, or A-M ‚Üí R1, N-Z ‚Üí R2)</li>
                    <li>Writes R intermediate files to local disk</li>
                    <li>Reports completion + file locations to TC</li>
                </ul>

                <h3>Reducers (R workers)</h3>
                <ul>
                    <li>Gets location data from TC</li>
                    <li>Fetches intermediate data from mapper disks</li>
                    <li>Outputs single file (R1_out, R2_out) to NFS</li>
                    <li>Can work concurrently with mappers</li>
                </ul>

                <h2>Storage Decisions</h2>

                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid var(--border);">Aspect</th>
                        <th style="padding: 10px; border: 1px solid var(--border);">Intermediate (Mapper Disk)</th>
                        <th style="padding: 10px; border: 1px solid var(--border);">Final Output (NFS)</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>Storage</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Local disk</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Network File System</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>Why?</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Fast, temporary, cheap to recompute</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Durable, accessible, expensive to recompute</td>
                    </tr>
                </table>

                <h2>Fault Tolerance</h2>

                <h3>1. Pings</h3>
                <p>TC sends periodic pings to detect crash failures</p>

                <h3>2. Speculative Execution (Final 5% Rule)</h3>
                <ul>
                    <li>When 95% of tasks complete, re-execute remaining slow tasks</li>
                    <li>Use whichever finishes first (original or backup)</li>
                    <li><strong>Why?</strong> Stragglers can slow down entire job</li>
                    <li>Improves performance by 30-50%</li>
                </ul>

                <h3>3. Mapper Failure</h3>
                <ul>
                    <li><strong>Reschedule:</strong> BOTH completed AND uncompleted tasks</li>
                    <li><strong>Why?</strong> Local disk is inaccessible after failure</li>
                    <li><strong>Update:</strong> Inform reducers that had that mapper's data</li>
                </ul>

                <h3>4. Reducer Failure</h3>
                <ul>
                    <li><strong>Reschedule:</strong> ONLY uncompleted tasks</li>
                    <li><strong>Why?</strong> Input data still accessible (on mapper disks), NFS persists partial output</li>
                </ul>

                <div class="visualization">
                    <h3>üìä MapReduce Data Flow</h3>
                    <div style="background: white; padding: 20px; border-radius: 8px;">
                        <svg width="100%" height="300" viewBox="0 0 800 300">
                            <!-- User -->
                            <rect x="10" y="130" width="80" height="40" fill="#667eea" rx="5"/>
                            <text x="50" y="155" text-anchor="middle" fill="white" font-weight="bold">User</text>

                            <!-- TC -->
                            <rect x="150" y="130" width="80" height="40" fill="#2563eb" rx="5"/>
                            <text x="190" y="155" text-anchor="middle" fill="white" font-weight="bold">TC</text>

                            <!-- Mappers -->
                            <rect x="290" y="50" width="100" height="40" fill="#10b981" rx="5"/>
                            <text x="340" y="75" text-anchor="middle" fill="white" font-weight="bold">Mapper 1</text>
                            <rect x="290" y="130" width="100" height="40" fill="#10b981" rx="5"/>
                            <text x="340" y="155" text-anchor="middle" fill="white" font-weight="bold">Mapper 2</text>
                            <rect x="290" y="210" width="100" height="40" fill="#10b981" rx="5"/>
                            <text x="340" y="235" text-anchor="middle" fill="white" font-weight="bold">Mapper M</text>

                            <!-- Reducers -->
                            <rect x="480" y="80" width="100" height="40" fill="#f59e0b" rx="5"/>
                            <text x="530" y="105" text-anchor="middle" fill="white" font-weight="bold">Reducer 1</text>
                            <rect x="480" y="180" width="100" height="40" fill="#f59e0b" rx="5"/>
                            <text x="530" y="205" text-anchor="middle" fill="white" font-weight="bold">Reducer R</text>

                            <!-- NFS -->
                            <rect x="650" y="130" width="80" height="40" fill="#8b5cf6" rx="5"/>
                            <text x="690" y="155" text-anchor="middle" fill="white" font-weight="bold">NFS</text>

                            <!-- Arrows -->
                            <path d="M 90 150 L 150 150" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 230 140 L 290 80" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 230 150 L 290 150" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 230 160 L 290 225" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>

                            <path d="M 390 70 L 480 95" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5"/>
                            <path d="M 390 150 L 480 100" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5"/>
                            <path d="M 390 70 L 480 195" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5"/>
                            <path d="M 390 230 L 480 205" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5"/>

                            <path d="M 580 100 L 650 145" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 580 200 L 650 155" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>

                            <!-- Arrow marker -->
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                    <polygon points="0 0, 10 3, 0 6" fill="#333" />
                                </marker>
                            </defs>

                            <!-- Labels -->
                            <text x="115" y="125" font-size="12" fill="#666">data+funcs</text>
                            <text x="340" y="30" font-size="12" fill="#666">Local Disk</text>
                            <text x="430" y="130" font-size="12" fill="#666">fetch</text>
                            <text x="605" y="125" font-size="12" fill="#666">output</text>
                        </svg>
                    </div>
                    <p style="margin-top: 15px; text-align: center; color: var(--text-light);">
                        Solid arrows = data flow; Dashed arrows = intermediate data on mapper local disks
                    </p>
                </div>

                <h2>Key Takeaways</h2>
                <ul>
                    <li><strong>Mapper writes to local disk</strong> (fast, temporary)</li>
                    <li><strong>Reducer writes to NFS</strong> (durable, accessible)</li>
                    <li><strong>Mapper failure:</strong> Reschedule ALL tasks (disk lost)</li>
                    <li><strong>Reducer failure:</strong> Reschedule ONLY incomplete (NFS persists)</li>
                    <li><strong>Speculative execution:</strong> Re-run slow tasks at 95% completion</li>
                    <li><strong>Mappers need R and partition logic</strong> to split output correctly</li>
                </ul>
            </div>

                        <!-- Lecture 6 -->
            <div class="lecture-content" id="lecture6">
                <h1>Lecture 6: Crash Recovery - Detailed Exam Notes</h1>

                <h2>Overview</h2>
                <p>Crash recovery is critical in distributed systems to ensure data consistency when systems fail unexpectedly (power loss, kernel panic, hardware failure). The key challenge: how do we ensure multi-step operations complete atomically despite crashes?</p>

                <hr>

                <h2>1. Atomic Operations</h2>

                <h3>What Are Atomic Operations?</h3>
                <p><strong>Definition</strong>: Operations where either ALL steps complete successfully OR NONE of them appear to have happened.</p>
                <p><strong>Key Principle</strong>: No partial state should be visible after a crash.</p>

                <h3>Why Atomicity is Needed</h3>
                <ul>
                    <li><strong>Problem</strong>: Most file system operations require multiple disk writes</li>
                    <li><strong>Risk</strong>: A crash between writes leaves the file system in an inconsistent state</li>
                    <li><strong>Example</strong>: Creating a file requires 3 writes (allocate inode, initialize metadata, update directory). If only 2 complete, you have:
                        <ul>
                            <li>An allocated but uninitialized inode (garbage data)</li>
                            <li>A directory pointing to corrupted metadata</li>
                            <li>Orphaned data blocks</li>
                        </ul>
                    </li>
                </ul>

                <h3>Guarantees Required</h3>
                <ol>
                    <li><strong>Durability</strong>: Once an operation completes, it survives crashes</li>
                    <li><strong>Atomicity</strong>: Either all effects are visible or none</li>
                    <li><strong>Consistency</strong>: File system remains in valid state</li>
                </ol>

                <h3>Real-World Impact</h3>
                <p>Without atomicity:</p>
                <ul>
                    <li>Lost files</li>
                    <li>Corrupted metadata</li>
                    <li>Disk space leaks (allocated but unreachable blocks)</li>
                    <li>Directory inconsistencies</li>
                </ul>

                <hr>

                <h2>2. UNIX File System Structure</h2>
                <p>Understanding the file system structure is crucial for understanding what needs to be protected during crashes.</p>

                <div class="visualization">
                    <h3>Interactive File System Structure</h3>
                    <div class="viz-canvas" id="fs-structure">
                        <svg width="100%" height="500" viewBox="0 0 800 500" style="max-width: 100%;">
                            <!-- Superblock -->
                            <g id="superblock">
                                <rect x="50" y="20" width="700" height="60" fill="#2563eb" stroke="#1e40af" stroke-width="2" rx="5"/>
                                <text x="400" y="55" text-anchor="middle" fill="white" font-size="18" font-weight="bold">Superblock - File System Metadata</text>
                            </g>

                            <!-- Inode Bitmap -->
                            <g id="inode-bitmap">
                                <rect x="50" y="100" width="700" height="60" fill="#10b981" stroke="#059669" stroke-width="2" rx="5"/>
                                <text x="400" y="135" text-anchor="middle" fill="white" font-size="18" font-weight="bold">Inode Bitmap - Tracks Free/Used Inodes</text>
                            </g>

                            <!-- Data Bitmap -->
                            <g id="data-bitmap">
                                <rect x="50" y="180" width="700" height="60" fill="#f59e0b" stroke="#d97706" stroke-width="2" rx="5"/>
                                <text x="400" y="215" text-anchor="middle" fill="white" font-size="18" font-weight="bold">Data Bitmap - Tracks Free/Used Data Blocks</text>
                            </g>

                            <!-- Inode Table -->
                            <g id="inode-table">
                                <rect x="50" y="260" width="340" height="100" fill="#8b5cf6" stroke="#7c3aed" stroke-width="2" rx="5"/>
                                <text x="220" y="295" text-anchor="middle" fill="white" font-size="16" font-weight="bold">Inode Table</text>
                                <text x="220" y="320" text-anchor="middle" fill="white" font-size="12">Array of inodes</text>
                                <text x="220" y="340" text-anchor="middle" fill="white" font-size="12">(metadata for each file)</text>
                            </g>

                            <!-- Data Blocks -->
                            <g id="data-blocks">
                                <rect x="410" y="260" width="340" height="100" fill="#ef4444" stroke="#dc2626" stroke-width="2" rx="5"/>
                                <text x="580" y="295" text-anchor="middle" fill="white" font-size="16" font-weight="bold">Data Blocks</text>
                                <text x="580" y="320" text-anchor="middle" fill="white" font-size="12">Actual file/directory data</text>
                            </g>

                            <!-- Example Directory -->
                            <g id="example-dir">
                                <rect x="50" y="380" width="340" height="100" fill="#64748b" stroke="#475569" stroke-width="2" rx="5"/>
                                <text x="220" y="405" text-anchor="middle" fill="white" font-size="14" font-weight="bold">Example Directory "/home/user"</text>
                                <text x="70" y="430" fill="white" font-size="12" font-family="monospace">. ‚Üí 42</text>
                                <text x="70" y="450" fill="white" font-size="12" font-family="monospace">.. ‚Üí 2</text>
                                <text x="70" y="470" fill="white" font-size="12" font-family="monospace">file.txt ‚Üí 103</text>
                                <text x="200" y="430" fill="white" font-size="12" font-family="monospace">report.pdf ‚Üí 104</text>
                            </g>

                            <!-- Example Inode -->
                            <g id="example-inode">
                                <rect x="410" y="380" width="340" height="100" fill="#64748b" stroke="#475569" stroke-width="2" rx="5"/>
                                <text x="580" y="405" text-anchor="middle" fill="white" font-size="14" font-weight="bold">Example Inode #103</text>
                                <text x="430" y="430" fill="white" font-size="11">Type: Regular File</text>
                                <text x="430" y="450" fill="white" font-size="11">Size: 4096 bytes</text>
                                <text x="430" y="470" fill="white" font-size="11">Permissions: rw-r--r--</text>
                                <text x="600" y="430" fill="white" font-size="11">Owner: user</text>
                                <text x="600" y="450" fill="white" font-size="11">Data blocks: 8000</text>
                            </g>
                        </svg>
                    </div>
                </div>

                <h3>Directories</h3>
                <ul>
                    <li><strong>What they are</strong>: Special files that map names to inode numbers</li>
                    <li><strong>Structure</strong>: Array of (name, inode number) pairs</li>
                </ul>

                <h3>Inode Numbers (inumbers)</h3>
                <ul>
                    <li><strong>Definition</strong>: Unique identifier for each file/directory</li>
                    <li><strong>Purpose</strong>: Indirect reference to file metadata</li>
                    <li><strong>Range</strong>: 0 to N-1 (where N is max number of inodes)</li>
                    <li><strong>Location</strong>: Index into inode table</li>
                    <li><strong>Why needed</strong>: Allows multiple directory entries (hard links) to reference same file</li>
                </ul>

                <h3>Inodes (Index Nodes)</h3>
                <p><strong>Purpose</strong>: Store all metadata about a file EXCEPT its name</p>
                <p><strong>Contents</strong>:</p>
                <ul>
                    <li>File type (regular file, directory, symlink, etc.)</li>
                    <li>Permission bits (rwxrwxrwx)</li>
                    <li>Owner UID and GID</li>
                    <li>File size (in bytes)</li>
                    <li>Timestamps (created, modified, accessed)</li>
                    <li>Link count (number of directory entries pointing to this inode)</li>
                    <li><strong>Pointers to data blocks</strong>: Where the actual file content lives</li>
                </ul>

                <p><strong>Data Block Pointers Structure</strong>:</p>
                <pre><code>Inode:
‚îú‚îÄ Direct pointers (12) ‚Üí Point directly to data blocks
‚îú‚îÄ Single indirect ‚Üí Points to block containing 256 pointers
‚îú‚îÄ Double indirect ‚Üí Points to block containing 256 single indirect blocks
‚îî‚îÄ Triple indirect ‚Üí Points to block containing 256 double indirect blocks</code></pre>

                <p>This allows files to grow from small (48KB with direct pointers) to massive (terabytes with triple indirect).</p>

                <h3>Why This Structure?</h3>
                <ul>
                    <li><strong>Separation</strong>: Name separate from metadata separate from data</li>
                    <li><strong>Flexibility</strong>: Multiple names (hard links) for same file</li>
                    <li><strong>Efficiency</strong>: Fixed-size inodes for quick access</li>
                    <li><strong>Scalability</strong>: Indirect pointers allow files of any size</li>
                </ul>

                <hr>

                <h2>3. Free Bitmaps</h2>

                <h3>Purpose</h3>
                <p>Track which inodes and data blocks are in use vs. available for allocation.</p>

                <h3>Structure</h3>
                <ul>
                    <li><strong>Inode Bitmap</strong>: One bit per inode (1 = used, 0 = free)</li>
                    <li><strong>Data Block Bitmap</strong>: One bit per data block (1 = used, 0 = free)</li>
                </ul>

                <p><strong>Example</strong>:</p>
                <pre><code>Inode Bitmap: 11110011000...
              ‚Üë‚Üë‚Üë‚Üë  ‚Üë‚Üë
              Used  Used  Free inodes</code></pre>

                <h3>Operations</h3>
                <ol>
                    <li><strong>Allocate</strong>: Find first 0 bit, set to 1, return index</li>
                    <li><strong>Free</strong>: Set bit at index to 0</li>
                    <li><strong>Check</strong>: Test bit to see if resource is available</li>
                </ol>

                <h3>Why Bitmaps Matter for Crash Recovery</h3>
                <p><strong>Critical invariant</strong>: Bitmap must match actual allocation state</p>
                <p><strong>Crash scenarios</strong>:</p>
                <ul>
                    <li><strong>False positive</strong> (bitmap=1, actually free): Disk space leak</li>
                    <li><strong>False negative</strong> (bitmap=0, actually in use): Data corruption (overwrite active file!)</li>
                </ul>
                <p><strong>Solution</strong>: Logging ensures bitmap updates are atomic with actual allocation/deallocation</p>

                <hr>

                <h2>4. Writing a File: The Three-Step Problem</h2>

                <h3>Steps to Create a New File</h3>
                <p>When you run <code>echo "hello" > newfile.txt</code>, the file system must:</p>

                <pre><code>Step 1: Allocate inode number
   - Search inode bitmap for free bit
   - Set bit to 1 (mark as used)
   - Write inode bitmap to disk
   ‚úì Write #1: Updated inode bitmap

Step 2: Initialize inode
   - Fill in metadata (permissions, size, timestamps, etc.)
   - Set pointers to data blocks
   - Allocate data blocks from data bitmap
   - Write data to allocated blocks
   - Write inode to disk
   ‚úì Write #2: Updated inode
   ‚úì Write #3: Updated data bitmap
   ‚úì Write #4: Data blocks

Step 3: Append to parent directory
   - Add entry (name ‚Üí inode number)
   - Write directory block to disk
   ‚úì Write #5: Updated directory</code></pre>

                <div class="visualization">
                    <h3>Crash Scenario Simulator</h3>
                    <div style="margin: 20px 0;">
                        <button class="btn btn-primary" onclick="crashSimulator.simulateCrash(1)">Crash After Step 1</button>
                        <button class="btn btn-primary" onclick="crashSimulator.simulateCrash(2)">Crash After Step 2</button>
                        <button class="btn btn-primary" onclick="crashSimulator.simulateCrash(3)">Crash During Step 3</button>
                        <button class="btn btn-secondary" onclick="crashSimulator.reset()">Reset</button>
                    </div>
                    <div class="viz-canvas" id="crash-simulator" style="flex-direction: column; align-items: stretch; padding: 20px;">
                        <div id="crash-steps" style="display: flex; justify-content: space-around; margin-bottom: 20px;">
                            <div style="text-align: center;">
                                <div id="step1-box" style="width: 120px; height: 80px; background: #e2e8f0; border: 2px solid #cbd5e1; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: bold;">Step 1<br>Bitmap</div>
                            </div>
                            <div style="text-align: center;">
                                <div id="step2-box" style="width: 120px; height: 80px; background: #e2e8f0; border: 2px solid #cbd5e1; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: bold;">Step 2<br>Inode</div>
                            </div>
                            <div style="text-align: center;">
                                <div id="step3-box" style="width: 120px; height: 80px; background: #e2e8f0; border: 2px solid #cbd5e1; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: bold;">Step 3<br>Directory</div>
                            </div>
                        </div>
                        <div id="crash-result" style="background: #f8fafc; border: 2px solid #cbd5e1; border-radius: 8px; padding: 15px; min-height: 100px;">
                            <strong>Click a button to simulate a crash at different points</strong>
                        </div>
                    </div>
                </div>

                <h3>The Crash Problem</h3>

                <p><strong>Scenario 1: Crash after Step 1</strong></p>
                <ul>
                    <li>Result: Inode marked used but not initialized</li>
                    <li>Impact: Wasted inode, possible garbage read</li>
                </ul>

                <p><strong>Scenario 2: Crash after Step 2</strong></p>
                <ul>
                    <li>Result: Initialized inode but not reachable from any directory</li>
                    <li>Impact: Orphaned inode, disk space leak</li>
                </ul>

                <p><strong>Scenario 3: Crash during Step 3</strong></p>
                <ul>
                    <li>Result: Partial directory entry</li>
                    <li>Impact: Corrupted directory, system won't boot</li>
                </ul>

                <h3>Why Simple Solutions Don't Work</h3>
                <p><strong>Ordering writes carefully</strong>: Still have windows where crash leaves inconsistency</p>
                <p><strong>fsck (File System Check)</strong>:</p>
                <ul>
                    <li>Scans entire disk after crash</li>
                    <li>Takes HOURS on large disks</li>
                    <li>Only detects problems, can't always fix them</li>
                    <li>Not feasible for modern systems</li>
                </ul>

                <hr>

                <h2>5. Logging (Write-Ahead Logging / Journaling)</h2>

                <h3>Core Concept</h3>
                <p>Before making ANY changes to the file system, write a <strong>log entry</strong> describing all changes. Only after the log is safely on disk, apply the changes.</p>

                <h3>Why Logging Works</h3>
                <ul>
                    <li><strong>Single point of truth</strong>: Log contains complete operation</li>
                    <li><strong>Atomicity</strong>: Either entire log entry is written or none (detect via END_BLOCK)</li>
                    <li><strong>Recovery</strong>: Replay log after crash to complete operations</li>
                    <li><strong>Fast</strong>: Writing sequential log is much faster than random disk writes</li>
                </ul>

                <div class="visualization">
                    <h3>Write-Ahead Logging Timeline</h3>
                    <div class="viz-canvas" id="wal-timeline" style="flex-direction: column; padding: 20px;">
                        <svg width="100%" height="300" viewBox="0 0 900 300" style="max-width: 100%;">
                            <!-- Timeline -->
                            <line x1="50" y1="150" x2="850" y2="150" stroke="#cbd5e1" stroke-width="4"/>

                            <!-- Phase 1: Write to Log -->
                            <g id="phase1">
                                <circle cx="150" cy="150" r="30" fill="#2563eb" stroke="#1e40af" stroke-width="3"/>
                                <text x="150" y="158" text-anchor="middle" fill="white" font-size="16" font-weight="bold">1</text>
                                <text x="150" y="200" text-anchor="middle" font-size="12" font-weight="bold">Write to Log</text>
                                <text x="150" y="215" text-anchor="middle" font-size="10">TXN_BEGIN</text>
                                <text x="150" y="228" text-anchor="middle" font-size="10">All blocks</text>
                                <text x="150" y="241" text-anchor="middle" font-size="10">END_BLOCK</text>
                            </g>

                            <!-- Phase 2: Commit Point -->
                            <g id="phase2">
                                <circle cx="400" cy="150" r="35" fill="#10b981" stroke="#059669" stroke-width="3"/>
                                <text x="400" y="158" text-anchor="middle" fill="white" font-size="16" font-weight="bold">2</text>
                                <text x="400" y="200" text-anchor="middle" font-size="12" font-weight="bold">COMMIT POINT</text>
                                <text x="400" y="215" text-anchor="middle" font-size="10">fsync() to disk</text>
                                <rect x="360" y="115" width="80" height="25" fill="#f59e0b" rx="5"/>
                                <text x="400" y="132" text-anchor="middle" fill="white" font-size="11" font-weight="bold">ATOMIC</text>
                            </g>

                            <!-- Phase 3: Checkpoint -->
                            <g id="phase3">
                                <circle cx="650" cy="150" r="30" fill="#8b5cf6" stroke="#7c3aed" stroke-width="3"/>
                                <text x="650" y="158" text-anchor="middle" fill="white" font-size="16" font-weight="bold">3</text>
                                <text x="650" y="200" text-anchor="middle" font-size="12" font-weight="bold">Checkpoint</text>
                                <text x="650" y="215" text-anchor="middle" font-size="10">Write blocks to</text>
                                <text x="650" y="228" text-anchor="middle" font-size="10">actual locations</text>
                            </g>

                            <!-- Crash scenarios -->
                            <g id="crash-before-commit">
                                <line x1="250" y1="50" x2="250" y2="120" stroke="#ef4444" stroke-width="3" stroke-dasharray="5,5"/>
                                <text x="250" y="40" text-anchor="middle" font-size="11" fill="#ef4444" font-weight="bold">Crash here?</text>
                                <text x="250" y="280" text-anchor="middle" font-size="9" fill="#ef4444">‚Üí Ignore incomplete log</text>
                            </g>

                            <g id="crash-after-commit">
                                <line x1="550" y1="50" x2="550" y2="120" stroke="#22c55e" stroke-width="3" stroke-dasharray="5,5"/>
                                <text x="550" y="40" text-anchor="middle" font-size="11" fill="#22c55e" font-weight="bold">Crash here?</text>
                                <text x="550" y="280" text-anchor="middle" font-size="9" fill="#22c55e">‚Üí Replay log on recovery</text>
                            </g>
                        </svg>
                    </div>
                </div>

                <h3>Log Structure</h3>
                <pre><code>+-------------------+
| TXN_BEGIN         |  ‚Üê Transaction start marker
+-------------------+
| Block #1 (bitmap) |  ‚Üê All modified blocks
+-------------------+
| Block #2 (inode)  |
+-------------------+
| Block #3 (dir)    |
+-------------------+
| END_BLOCK         |  ‚Üê Transaction end marker (commit point)
+-------------------+</code></pre>

                <h3>Writing a File WITH Logging</h3>
                <p><strong>New protocol</strong> (Write-Ahead Logging):</p>
                <pre><code>PHASE 1: Write to Log
  1. Write TXN_BEGIN to log
  2. Write all modified blocks to log (inode bitmap, inode, directory, data bitmap, data)
  3. Write END_BLOCK to log
  4. FORCE LOG TO DISK (fsync/fdatasync) ‚Üê COMMIT POINT

PHASE 2: Checkpoint (Write to Actual Locations)
  5. Write inode bitmap to its real location
  6. Write inode to its real location
  7. Write directory block to its real location
  8. Write data bitmap to its real location
  9. Write data blocks to their real locations
  (These can happen in any order, even in parallel)

PHASE 3: Free Log
  10. Mark log entry as processed (can be reused)</code></pre>

                <h3>Critical Insight</h3>
                <p><strong>After step 4 completes</strong>, the transaction is considered committed:</p>
                <ul>
                    <li>If crash happens in Phase 2, we replay the log to finish</li>
                    <li>If crash happens before step 4, we ignore the incomplete log entry</li>
                </ul>

                <h3>Log Location</h3>
                <ul>
                    <li><strong>Separate region</strong> of disk (or separate disk)</li>
                    <li><strong>Circular buffer</strong>: Reuse space as entries are completed</li>
                    <li><strong>Sequential writes</strong>: Very fast (100+ MB/s)</li>
                </ul>

                <hr>

                <h2>6. END_BLOCK Mechanism</h2>

                <h3>Purpose</h3>
                <p>Detect whether a log entry was completely written before a crash.</p>

                <h3>How It Works</h3>
                <p><strong>END_BLOCK contains</strong>:</p>
                <ul>
                    <li>Magic number (e.g., 0xDEADBEEF)</li>
                    <li>Checksum of all preceding blocks in transaction</li>
                    <li>Transaction ID</li>
                </ul>

                <p><strong>Writing</strong>:</p>
                <pre><code>Write block 1 to log
Write block 2 to log
Write block 3 to log
Calculate checksum = hash(block1 + block2 + block3)
Write END_BLOCK(magic=0xDEADBEEF, checksum, txn_id)
fsync()  ‚Üê Force to disk</code></pre>

                <p><strong>Validation</strong> (during recovery):</p>
                <pre><code>Read TXN_BEGIN
Read all blocks until END_BLOCK
Calculate checksum of read blocks

if (END_BLOCK.magic == 0xDEADBEEF &&
    END_BLOCK.checksum == calculated_checksum):
    // Valid transaction - replay it
else:
    // Incomplete transaction - ignore it</code></pre>

                <h3>Why This Ensures Atomicity</h3>
                <p><strong>Case 1: Crash before END_BLOCK written</strong></p>
                <ul>
                    <li>END_BLOCK missing or has wrong magic/checksum</li>
                    <li><strong>Action</strong>: Discard this log entry (transaction never committed)</li>
                    <li><strong>Result</strong>: As if operation never started ‚úì</li>
                </ul>

                <p><strong>Case 2: END_BLOCK successfully written</strong></p>
                <ul>
                    <li>END_BLOCK present with valid magic/checksum</li>
                    <li><strong>Action</strong>: Replay all blocks to their file system locations</li>
                    <li><strong>Result</strong>: Operation completes atomically ‚úì</li>
                </ul>

                <p><strong>Case 3: Crash during checkpoint (Phase 2)</strong></p>
                <ul>
                    <li>END_BLOCK is valid</li>
                    <li>Some blocks written to file system, others not</li>
                    <li><strong>Action</strong>: Replay anyway (writing already-written blocks is idempotent)</li>
                    <li><strong>Result</strong>: Operation completes ‚úì</li>
                </ul>

                <h3>Idempotence</h3>
                <p><strong>Critical property</strong>: Replaying a transaction multiple times has same effect as replaying once</p>
                <ul>
                    <li>Writing inode with same values multiple times is safe</li>
                    <li>Bitmap updates are overwrites (idempotent)</li>
                    <li>This allows safe recovery even if crash happens during replay</li>
                </ul>

                <hr>

                <h2>7. Multi-Transaction Log</h2>

                <h3>The Problem with Single Transaction Logs</h3>
                <ul>
                    <li>Small operations (create file) require waiting for log flush</li>
                    <li>Only one operation at a time in log</li>
                    <li>Disk sits idle between transactions</li>
                    <li><strong>Throughput</strong>: Very low</li>
                </ul>

                <h3>Solution: Batching Multiple Transactions</h3>
                <p><strong>Concept</strong>: Allow multiple transactions in the log buffer simultaneously, flush together.</p>

                <h3>Structure</h3>
                <pre><code>Log Buffer (e.g., 64 KB):
+------------------+
| TXN_1 BEGIN      |
| Blocks for TXN_1 |
| TXN_1 END_BLOCK  |
+------------------+
| TXN_2 BEGIN      |
| Blocks for TXN_2 |
| TXN_2 END_BLOCK  |
+------------------+
| TXN_3 BEGIN      |
| Blocks for TXN_3 |
| TXN_3 END_BLOCK  |
+------------------+
| ...              |
+------------------+</code></pre>

                <h3>Writing Until Full</h3>
                <p><strong>Protocol</strong>:</p>
                <pre><code>while (log buffer not full && transactions pending):
    txn = get_next_transaction()

    // Check for conflicts
    if (conflicts_with_existing_transactions_in_buffer(txn)):
        break  // Don't add this transaction

    write_to_log_buffer(txn)

// Now flush entire buffer to disk in one giant write
fsync(log)

// All non-conflicting transactions now committed atomically</code></pre>

                <h3>Conflict Detection</h3>
                <p><strong>Transactions conflict if they modify the same block</strong>:</p>
                <p>Example:</p>
                <ul>
                    <li>TXN_1: Create <code>/home/file1.txt</code> (modifies <code>/home</code> directory block 42)</li>
                    <li>TXN_2: Create <code>/home/file2.txt</code> (modifies <code>/home</code> directory block 42)</li>
                    <li><strong>Conflict!</strong> Both modify block 42</li>
                </ul>

                <p><strong>Resolution</strong>:</p>
                <ul>
                    <li>Add TXN_1 to log buffer</li>
                    <li>When TXN_2 arrives, detect conflict</li>
                    <li>Stop adding transactions, flush buffer</li>
                    <li>After flush, start new buffer with TXN_2</li>
                </ul>

                <h3>Flushing Non-Conflicting Transactions</h3>
                <p><strong>Example scenario</strong>:</p>
                <pre><code>TXN_1: Create /home/user1/file.txt
TXN_2: Create /home/user2/file.txt  ‚Üê Different directory, no conflict
TXN_3: Create /tmp/tempfile         ‚Üê Different directory, no conflict
TXN_4: Create /home/user1/photo.jpg ‚Üê Conflicts with TXN_1 (same parent dir)</code></pre>

                <p><strong>Buffer contents</strong>:</p>
                <pre><code>+------------------+
| TXN_1            | ‚úì Added
+------------------+
| TXN_2            | ‚úì Added (no conflict)
+------------------+
| TXN_3            | ‚úì Added (no conflict)
+------------------+
| TXN_4            | ‚úó Conflict detected - STOP and FLUSH
+------------------+</code></pre>

                <p>After flush, TXN_1, TXN_2, TXN_3 are all committed. Start new buffer with TXN_4.</p>

                <h3>Benefits</h3>
                <ol>
                    <li><strong>Amortized flush cost</strong>: One expensive fsync commits many transactions</li>
                    <li><strong>Higher throughput</strong>: Process operations in parallel</li>
                    <li><strong>Better disk utilization</strong>: Larger sequential writes</li>
                    <li><strong>Reduced latency</strong>: Operations commit faster on average</li>
                </ol>

                <h3>Recovery with Multi-Transaction Logs</h3>
                <p><strong>Replay logic</strong>:</p>
                <pre><code>for each transaction in log:
    if (has_valid_END_BLOCK(transaction)):
        replay(transaction)  // Apply all blocks to file system
    else:
        break  // Stop at first incomplete transaction</code></pre>

                <p>All completed transactions (with END_BLOCK) are replayed in order.</p>

                <hr>

                <h2>8. Group Commit</h2>

                <h3>The Problem</h3>
                <p>Even with multi-transaction logs, when do we flush?</p>
                <p><strong>Options</strong>:</p>
                <ol>
                    <li><strong>Flush immediately when full</strong>: Misses opportunities for batching</li>
                    <li><strong>Wait for more transactions</strong>: Increases latency</li>
                </ol>

                <h3>Group Commit Solution</h3>
                <p><strong>Strategy</strong>: Use a <strong>timer-based flush policy</strong></p>

                <div class="visualization">
                    <h3>Group Commit Animation</h3>
                    <div style="margin: 20px 0;">
                        <button class="btn btn-primary" onclick="groupCommit.start()">Start Animation</button>
                        <button class="btn btn-secondary" onclick="groupCommit.stop()">Stop</button>
                        <button class="btn btn-secondary" onclick="groupCommit.reset()">Reset</button>
                    </div>
                    <div class="viz-canvas" id="group-commit-viz" style="flex-direction: column; padding: 20px;">
                        <div style="margin-bottom: 15px;">
                            <strong>Time: <span id="gc-time">0.0</span>s</strong> |
                            <strong>Buffer: <span id="gc-buffer-count">0</span> transactions</strong> |
                            <strong>Committed: <span id="gc-committed">0</span></strong>
                        </div>
                        <div style="background: white; border: 2px solid #cbd5e1; border-radius: 8px; padding: 15px; height: 200px; overflow-y: auto;">
                            <div id="gc-log" style="font-family: monospace; font-size: 12px;"></div>
                        </div>
                        <div style="margin-top: 15px; background: #f8fafc; border: 2px solid #cbd5e1; border-radius: 8px; padding: 15px;">
                            <strong>Log Buffer (Max 5 transactions):</strong>
                            <div id="gc-buffer" style="display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;"></div>
                        </div>
                    </div>
                </div>

                <h3>How Group Commit Works</h3>
                <p><strong>Algorithm</strong>:</p>
                <pre><code>Every 1 second (or 5 seconds):
    if (log buffer has any transactions):
        fsync(log)  // Force everything to disk
        mark all transactions as committed
        wake up waiting threads
        clear buffer</code></pre>

                <p><strong>Application thread behavior</strong>:</p>
                <pre><code>thread_create_file():
    add_transaction_to_log_buffer()

    if (synchronous operation requested):
        wait_until_next_group_commit()  // Max 1 second wait
    else:
        return immediately  // Asynchronous</code></pre>

                <h3>Giant Consecutive Write</h3>
                <p><strong>Key optimization</strong>: Log is written sequentially</p>

                <p><strong>Without group commit</strong>:</p>
                <pre><code>Time: 0ms   100ms  200ms  300ms  400ms
      |     |      |      |      |
      fsync fsync  fsync  fsync  fsync  ‚Üê 5 separate disk operations
      4KB   4KB    4KB    4KB    4KB     = 20 KB total</code></pre>

                <p><strong>With group commit</strong> (1 second intervals):</p>
                <pre><code>Time: 0ms                           1000ms
      |                             |
      [accumulate transactions...]  fsync  ‚Üê ONE giant disk operation
                                    50 KB   = 50 KB in single write</code></pre>

                <h3>Performance Benefits</h3>
                <p><strong>Disk characteristics</strong>:</p>
                <ul>
                    <li><strong>Seek time</strong>: ~10ms (moving disk head)</li>
                    <li><strong>Sequential write speed</strong>: 100-200 MB/s</li>
                    <li><strong>Random write speed</strong>: 1-2 MB/s</li>
                </ul>

                <p><strong>Without group commit</strong>:</p>
                <ul>
                    <li>Each fsync = seek + small write</li>
                    <li>100 transactions = 100 seeks = 1000ms</li>
                    <li>Throughput: 100 transactions/second</li>
                </ul>

                <p><strong>With group commit</strong>:</p>
                <ul>
                    <li>One fsync = one seek + large write</li>
                    <li>100 transactions in buffer = 1 seek + 50KB write = 10ms + 0.5ms = 10.5ms</li>
                    <li>Throughput: 9,500 transactions/second</li>
                    <li><strong>90x improvement!</strong></li>
                </ul>

                <h3>Trade-offs</h3>
                <p><strong>Advantages</strong>:</p>
                <ol>
                    <li><strong>Massive throughput increase</strong>: 10-100x</li>
                    <li><strong>Reduced disk wear</strong>: Fewer write operations</li>
                    <li><strong>Better disk utilization</strong>: Sequential writes are optimal</li>
                    <li><strong>Scalability</strong>: Handles burst workloads</li>
                </ol>

                <p><strong>Disadvantages</strong>:</p>
                <ol>
                    <li><strong>Increased latency</strong>: Up to 1 second delay per operation</li>
                    <li><strong>Durability window</strong>: Crashes within 1 second lose committed operations</li>
                    <li><strong>Tuning required</strong>: Interval affects latency/throughput tradeoff</li>
                </ol>

                <h3>Tuning the Interval</h3>
                <p><strong>Shorter interval</strong> (e.g., 100ms):</p>
                <ul>
                    <li>Lower latency</li>
                    <li>Fewer transactions per group</li>
                    <li>More fsyncs</li>
                    <li>Good for latency-sensitive applications</li>
                </ul>

                <p><strong>Longer interval</strong> (e.g., 5 seconds):</p>
                <ul>
                    <li>Higher latency</li>
                    <li>More transactions per group</li>
                    <li>Fewer fsyncs</li>
                    <li>Good for throughput-oriented applications</li>
                </ul>

                <p><strong>Linux ext4 default</strong>: 5 seconds<br>
                <strong>Modern databases</strong>: Configurable (PostgreSQL: 200ms - 1s)</p>

                <hr>

                <h2>Summary: How Everything Works Together</h2>

                <h3>Creating a File (The Full Story)</h3>
                <pre><code>Application: open("/home/user/file.txt", O_CREAT)
    ‚Üì
Kernel: Prepare transaction
    1. Allocate inode #500
    2. Set inode bitmap bit #500
    3. Initialize inode #500 metadata
    4. Allocate data block #8000
    5. Set data bitmap bit #8000
    6. Update directory "/home/user" (add entry)
    ‚Üì
Logging Layer: Add to log buffer (multi-transaction log)
    - Check for conflicts with pending transactions
    - If no conflicts, append to buffer
    - If buffer full or conflict, flush buffer now
    ‚Üì
Group Commit Timer (every 1 second):
    - Flush entire log buffer to disk (giant consecutive write)
    - Write END_BLOCK for each transaction
    - fsync()  ‚Üê COMMIT POINT
    ‚Üì
Checkpoint Thread (background):
    - Read committed transactions from log
    - Write blocks to their file system locations
    - Can happen lazily, in any order
    - Mark log entries as processed
    ‚Üì
Recovery After Crash:
    - Scan log for transactions with valid END_BLOCK
    - Replay all complete transactions (idempotent)
    - Ignore incomplete transactions
    - File system is consistent!</code></pre>

                <hr>

                <h2>Key Exam Concepts to Remember</h2>

                <h3>Atomicity</h3>
                <ul>
                    <li><strong>All or nothing</strong>: Either entire operation visible or none</li>
                    <li><strong>END_BLOCK</strong>: Determines if transaction is complete</li>
                    <li><strong>Idempotence</strong>: Safe to replay transactions multiple times</li>
                </ul>

                <h3>Logging Phases</h3>
                <ol>
                    <li><strong>Log write</strong> (with END_BLOCK) ‚Üí Commit point</li>
                    <li><strong>Checkpoint</strong> (apply to file system) ‚Üí Can happen later</li>
                    <li><strong>Free log space</strong> ‚Üí Circular buffer reuse</li>
                </ol>

                <h3>Performance Optimizations</h3>
                <ul>
                    <li><strong>Multi-transaction log</strong>: Batch non-conflicting operations</li>
                    <li><strong>Group commit</strong>: Timer-based flush (giant consecutive write)</li>
                    <li><strong>Trade-off</strong>: Latency vs. throughput</li>
                </ul>

                <h3>Recovery</h3>
                <ul>
                    <li><strong>Scan log</strong> for valid END_BLOCKS</li>
                    <li><strong>Replay</strong> all complete transactions</li>
                    <li><strong>Ignore</strong> incomplete transactions</li>
                    <li><strong>Result</strong>: Consistent file system state</li>
                </ul>

                <h3>Critical Invariants</h3>
                <ol>
                    <li>Log must be written before checkpoint</li>
                    <li>END_BLOCK ensures transaction completeness</li>
                    <li>Checkpointing is idempotent</li>
                    <li>Conflicting transactions cannot be in same log buffer</li>
                </ol>

                <hr>

                <h2>Practice Questions</h2>

                <h3>Question 1</h3>
                <p>What happens if a crash occurs after writing blocks to the log but before writing END_BLOCK?</p>
                <p><strong>Answer</strong>: The transaction is incomplete. During recovery, the absence of a valid END_BLOCK means this transaction is ignored. The file system state will be as if the operation never started (atomicity preserved).</p>

                <h3>Question 2</h3>
                <p>Why can't two transactions that modify the same directory block be in the log buffer simultaneously?</p>
                <p><strong>Answer</strong>: They conflict. If both were flushed together, the log would contain two different versions of the same block number. During replay, it's unclear which version should be applied. To avoid this, conflicting transactions are flushed separately.</p>

                <h3>Question 3</h3>
                <p>How does group commit improve performance despite adding latency?</p>
                <p><strong>Answer</strong>: By batching many transactions into one giant sequential write, group commit eliminates the seek time overhead of multiple small writes. For example, 100 transactions that would require 100 seeks (1000ms) now require just 1 seek (10ms), improving throughput by 90x. The latency increase (up to 1 second) is acceptable for most applications.</p>

                <h3>Question 4</h3>
                <p>Why must the log be written to disk (fsync) before checkpoint begins?</p>
                <p><strong>Answer</strong>: This is the write-ahead logging principle. If checkpoint happens first and the system crashes before the log is written, we have no way to recover. The transaction appears partially applied with no record of what was intended. By writing the log first, we ensure the complete operation is safely recorded before any changes are made.</p>

                <h3>Question 5</h3>
                <p>Explain why checkpointing is idempotent and why this matters.</p>
                <p><strong>Answer</strong>: Checkpointing writes blocks to their file system locations with specific values. Writing the same values multiple times produces the same result. This matters because a crash during checkpoint can be recovered by replaying the transaction again - we simply overwrite the partially written blocks with the correct values from the log.</p>

                <hr>

                <h2>Good Luck on Your Exam!</h2>
                <p>Focus on understanding:</p>
                <ul>
                    <li><strong>Why</strong> each mechanism exists (what problem does it solve?)</li>
                    <li><strong>How</strong> the mechanisms interact (logging ‚Üí group commit ‚Üí recovery)</li>
                    <li><strong>Trade-offs</strong> (latency vs. throughput, complexity vs. correctness)</li>
                </ul>
                <p>The exam will likely test your understanding of crash scenarios and recovery logic. Practice tracing through different crash points and explaining what happens during recovery.</p>
            </div>
<!-- Lecture 7 -->
            <div class="lecture-content" id="lecture7">
                <h1>Lecture 7: Two-Phase Commit (2PC)</h1>

                <h2>Overview</h2>
                <p><strong>What is 2PC?</strong> A distributed algorithm for achieving atomic commitment across multiple services/databases.</p>
                <p><strong>Goal:</strong> All participants either commit or abort a transaction - no partial commits.</p>
                <p><strong>Limitation:</strong> Designed for single transactions only</p>

                <h2>Real-World Example: Bank Transfer</h2>
                <div style="background: #eff6ff; padding: 20px; border-radius: 12px; border-left: 5px solid var(--primary); margin: 20px 0;">
                    <h3 style="color: var(--primary); margin-top: 0;">Scenario: Transfer $100 from Alice's account to Bob's account</h3>

                    <p><strong>Problem:</strong> Alice's account is at Bank A's database, Bob's account is at Bank B's database. We need BOTH operations to succeed or BOTH to fail.</p>

                    <h4>Without 2PC (Bad!):</h4>
                    <ul>
                        <li>Deduct $100 from Alice at Bank A ‚úì</li>
                        <li>Bank B crashes before adding $100 to Bob ‚úó</li>
                        <li><strong>Result:</strong> $100 disappeared! üí∏</li>
                    </ul>

                    <h4>With 2PC (Good!):</h4>

                    <p><strong>Components:</strong></p>
                    <ul>
                        <li><strong>Client:</strong> Banking application initiating the transfer</li>
                        <li><strong>TC (Transaction Coordinator):</strong> Transfer service that orchestrates the transaction</li>
                        <li><strong>Participant A:</strong> Bank A's database (manages Alice's account)</li>
                        <li><strong>Participant B:</strong> Bank B's database (manages Bob's account)</li>
                    </ul>

                    <p><strong>Phase 1 - Voting (Can you do this?):</strong></p>
                    <ol>
                        <li><strong>TC ‚Üí Bank A:</strong> "PREPARE to deduct $100 from Alice"
                            <ul>
                                <li>Bank A checks: Does Alice have $100? ‚úì</li>
                                <li>Bank A <strong>locks Alice's account</strong> (prevents other transactions)</li>
                                <li>Bank A <strong>writes to log:</strong> "PREPARED: deduct $100 from Alice"</li>
                                <li>Bank A ‚Üí TC: <strong>"YES"</strong></li>
                            </ul>
                        </li>
                        <li><strong>TC ‚Üí Bank B:</strong> "PREPARE to add $100 to Bob"
                            <ul>
                                <li>Bank B checks: Can I add money? ‚úì (always yes for deposits)</li>
                                <li>Bank B <strong>locks Bob's account</strong></li>
                                <li>Bank B <strong>writes to log:</strong> "PREPARED: add $100 to Bob"</li>
                                <li>Bank B ‚Üí TC: <strong>"YES"</strong></li>
                            </ul>
                        </li>
                    </ol>

                    <p><strong>Phase 2 - Decision (Everyone do it!):</strong></p>
                    <ol>
                        <li><strong>TC receives both YES votes</strong></li>
                        <li><strong>TC writes to log:</strong> "COMMIT transfer #12345" ‚ö° <em>(This is the atomic point!)</em></li>
                        <li><strong>TC ‚Üí Bank A:</strong> "COMMIT"
                            <ul>
                                <li>Bank A deducts $100 from Alice</li>
                                <li>Bank A unlocks Alice's account</li>
                                <li>Bank A ‚Üí TC: "ACK"</li>
                            </ul>
                        </li>
                        <li><strong>TC ‚Üí Bank B:</strong> "COMMIT"
                            <ul>
                                <li>Bank B adds $100 to Bob</li>
                                <li>Bank B unlocks Bob's account</li>
                                <li>Bank B ‚Üí TC: "ACK"</li>
                            </ul>
                        </li>
                        <li><strong>TC ‚Üí Client:</strong> "Transfer successful!"</li>
                    </ol>

                    <h4>What if Bank B voted NO?</h4>
                    <ul>
                        <li>TC receives: YES from Bank A, NO from Bank B</li>
                        <li>TC writes to log: "ABORT transfer #12345"</li>
                        <li>TC ‚Üí Bank A: "ABORT" (Bank A unlocks Alice's account, no change)</li>
                        <li>TC ‚Üí Bank B: "ABORT" (Bank B unlocks Bob's account, no change)</li>
                        <li><strong>Result:</strong> Transaction safely aborted, no money lost ‚úì</li>
                    </ul>

                    <h4>What if Bank A crashes after voting YES?</h4>
                    <ul>
                        <li>Bank A reboots, reads log: "PREPARED: deduct $100 from Alice"</li>
                        <li>Bank A asks TC: "What happened to transfer #12345?"</li>
                        <li>TC replies: "COMMIT" (because I have it in my log)</li>
                        <li>Bank A completes the deduction</li>
                        <li><strong>Result:</strong> Transaction completes correctly despite crash ‚úì</li>
                    </ul>

                    <h4>‚ö†Ô∏è What if TC crashes AFTER sending PREPARE, BEFORE receiving all votes?</h4>
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-top: 10px;">
                        <p><strong>Scenario:</strong> TC sent PREPARE to both banks, then crashes. Banks are waiting in READY state with accounts LOCKED!</p>

                        <p><strong>The Problem:</strong></p>
                        <ul>
                            <li>Bank A: Alice's account is LOCKED ‚ùå</li>
                            <li>Bank B: Bob's account is LOCKED ‚ùå</li>
                            <li>Both banks voted YES, waiting for TC's decision</li>
                            <li>TC crashed and won't respond</li>
                        </ul>

                        <p><strong>What happens next?</strong></p>
                        <ol>
                            <li><strong>Banks detect timeout:</strong> No decision from TC within expected time</li>
                            <li><strong>Banks run termination protocol:</strong>
                                <ul>
                                    <li>Bank A asks Bank B: "What's your state?"</li>
                                    <li>Bank B replies: "READY" (also waiting)</li>
                                    <li>Bank A asks any other participants: All say "READY"</li>
                                </ul>
                            </li>
                            <li><strong>‚ö†Ô∏è PROTOCOL BLOCKS:</strong>
                                <ul>
                                    <li>All participants are in READY state</li>
                                    <li>They don't know if TC logged COMMIT or ABORT before crash</li>
                                    <li>They can't decide on their own (they promised to follow TC)</li>
                                    <li><strong>Accounts remain LOCKED until TC recovers!</strong></li>
                                </ul>
                            </li>
                        </ol>

                        <p><strong>When TC recovers:</strong></p>
                        <ul>
                            <li><strong>If TC's log shows WAIT state:</strong> TC knows it didn't decide yet ‚Üí sends GLOBAL_ABORT ‚Üí accounts unlocked, no transfer</li>
                            <li><strong>If TC's log shows COMMIT:</strong> TC continues protocol ‚Üí sends GLOBAL_COMMIT ‚Üí transfer completes</li>
                            <li><strong>If TC's log shows ABORT:</strong> TC sends GLOBAL_ABORT ‚Üí accounts unlocked, no transfer</li>
                        </ul>

                        <p><strong>Key Point:</strong> TC logs its WAIT state BEFORE sending PREPARE, so it knows whether it made a decision or not when it recovers!</p>
                    </div>

                    <h4>What if TC crashes AFTER receiving all YES votes, BEFORE logging COMMIT?</h4>
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-top: 10px;">
                        <p><strong>Scenario:</strong> TC received YES from both banks, about to commit, but crashes before writing COMMIT to log.</p>

                        <p><strong>When TC recovers:</strong></p>
                        <ul>
                            <li>TC reads log: "WAIT state" + received votes from A and B</li>
                            <li>TC knows all voted YES</li>
                            <li>TC can safely decide to COMMIT</li>
                            <li>TC writes COMMIT to log, sends GLOBAL_COMMIT to banks</li>
                            <li><strong>Result:</strong> Transaction completes (banks were waiting, now unblocked) ‚úì</li>
                        </ul>

                        <p><strong>OR if TC is too conservative:</strong></p>
                        <ul>
                            <li>TC could decide to ABORT (safe default when unsure)</li>
                            <li>Sends GLOBAL_ABORT to banks</li>
                            <li>Accounts unlocked, no transfer</li>
                            <li><strong>Result:</strong> Transaction aborted, but atomicity preserved ‚úì</li>
                        </ul>
                    </div>
                </div>

                <h2>Components</h2>
                <ul>
                    <li><strong>Transaction Coordinator (TC):</strong> Orchestrates the protocol</li>
                    <li><strong>Client:</strong> Initiates the transaction</li>
                    <li><strong>Participants (A, B, ...):</strong> Services that execute parts of the transaction</li>
                </ul>

                <h2>The Two Phases</h2>

                <h3>Phase 1: Voting Phase</h3>
                <ol>
                    <li>TC sends <strong>PREPARE</strong> message to all participants (A and B)</li>
                    <li>Each participant:
                        <ul>
                            <li>Prepares to commit (locks resources, validates constraints)</li>
                            <li><strong>Writes PREPARED to disk</strong> (BEFORE voting YES!)</li>
                            <li>Responds with <strong>YES</strong> (can commit) or <strong>NO</strong> (cannot commit)</li>
                        </ul>
                    </li>
                </ol>
                <p><strong>Critical:</strong> Participants MUST log PREPARED to disk before voting YES to survive crashes</p>

                <h3>Phase 2: Decision Phase</h3>
                <ol>
                    <li>TC decides based on votes:
                        <ul>
                            <li><strong>If all YES:</strong> Decision = COMMIT</li>
                            <li><strong>If any NO:</strong> Decision = ABORT</li>
                        </ul>
                    </li>
                    <li><strong>TC writes decision to disk</strong> (BEFORE sending to participants!)</li>
                    <li>TC sends decision to all participants and client</li>
                    <li>Participants execute the decision (commit or abort)</li>
                    <li>Participants acknowledge completion</li>
                </ol>

                <div class="visualization">
                    <h3>üìä 2PC Protocol Flow</h3>
                    <div style="background: white; padding: 20px; border-radius: 8px;">
                        <svg width="100%" height="400" viewBox="0 0 700 400">
                            <!-- Components -->
                            <rect x="50" y="20" width="80" height="40" fill="#2563eb" rx="5"/>
                            <text x="90" y="45" text-anchor="middle" fill="white" font-weight="bold">TC</text>

                            <rect x="300" y="20" width="80" height="40" fill="#10b981" rx="5"/>
                            <text x="340" y="45" text-anchor="middle" fill="white" font-weight="bold">Service A</text>

                            <rect x="500" y="20" width="80" height="40" fill="#10b981" rx="5"/>
                            <text x="540" y="45" text-anchor="middle" fill="white" font-weight="bold">Service B</text>

                            <!-- Timeline -->
                            <line x1="90" y1="70" x2="90" y2="380" stroke="#ccc" stroke-width="2"/>
                            <line x1="340" y1="70" x2="340" y2="380" stroke="#ccc" stroke-width="2"/>
                            <line x1="540" y1="70" x2="540" y2="380" stroke="#ccc" stroke-width="2"/>

                            <!-- Phase 1 Label -->
                            <text x="10" y="95" font-weight="bold" fill="#667eea">Phase 1:</text>
                            <text x="10" y="115" font-weight="bold" fill="#667eea">Voting</text>

                            <!-- PREPARE messages -->
                            <path d="M 90 100 L 340 120" stroke="#667eea" stroke-width="2" fill="none" marker-end="url(#arrowhead2)"/>
                            <text x="200" y="105" font-size="12" fill="#667eea">PREPARE</text>

                            <path d="M 90 110 L 540 130" stroke="#667eea" stroke-width="2" fill="none" marker-end="url(#arrowhead2)"/>

                            <!-- Log PREPARED -->
                            <rect x="300" y="135" width="80" height="25" fill="#f59e0b" rx="3"/>
                            <text x="340" y="152" text-anchor="middle" font-size="11" fill="white">Log PREPARED</text>

                            <rect x="500" y="145" width="80" height="25" fill="#f59e0b" rx="3"/>
                            <text x="540" y="162" text-anchor="middle" font-size="11" fill="white">Log PREPARED</text>

                            <!-- YES votes -->
                            <path d="M 340 175 L 90 190" stroke="#22c55e" stroke-width="2" fill="none" marker-end="url(#arrowhead2)"/>
                            <text x="200" y="180" font-size="12" fill="#22c55e">YES</text>

                            <path d="M 540 185 L 90 200" stroke="#22c55e" stroke-width="2" fill="none" marker-end="url(#arrowhead2)"/>
                            <text x="300" y="190" font-size="12" fill="#22c55e">YES</text>

                            <!-- Phase 2 Label -->
                            <text x="10" y="230" font-weight="bold" fill="#8b5cf6">Phase 2:</text>
                            <text x="10" y="250" font-weight="bold" fill="#8b5cf6">Decision</text>

                            <!-- Log COMMIT (THE ATOMIC POINT!) -->
                            <rect x="50" y="210" width="80" height="35" fill="#ef4444" rx="3" stroke="#dc2626" stroke-width="3"/>
                            <text x="90" y="225" text-anchor="middle" font-size="10" fill="white" font-weight="bold">Log COMMIT</text>
                            <text x="90" y="238" text-anchor="middle" font-size="9" fill="white">(ATOMIC!)</text>

                            <!-- COMMIT messages -->
                            <path d="M 90 260 L 340 275" stroke="#8b5cf6" stroke-width="2" fill="none" marker-end="url(#arrowhead2)"/>
                            <text x="200" y="265" font-size="12" fill="#8b5cf6">COMMIT</text>

                            <path d="M 90 270 L 540 285" stroke="#8b5cf6" stroke-width="2" fill="none" marker-end="url(#arrowhead2)"/>

                            <!-- Participants commit -->
                            <rect x="300" y="290" width="80" height="25" fill="#10b981" rx="3"/>
                            <text x="340" y="307" text-anchor="middle" font-size="11" fill="white">Execute TX</text>

                            <rect x="500" y="300" width="80" height="25" fill="#10b981" rx="3"/>
                            <text x="540" y="317" text-anchor="middle" font-size="11" fill="white">Execute TX</text>

                            <!-- ACKs -->
                            <path d="M 340 330 L 90 340" stroke="#666" stroke-width="1" fill="none" marker-end="url(#arrowhead2)" stroke-dasharray="3,3"/>
                            <text x="200" y="330" font-size="11" fill="#666">ACK</text>

                            <path d="M 540 340 L 90 350" stroke="#666" stroke-width="1" fill="none" marker-end="url(#arrowhead2)" stroke-dasharray="3,3"/>

                            <!-- Arrow marker -->
                            <defs>
                                <marker id="arrowhead2" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                    <polygon points="0 0, 10 3, 0 6" fill="currentColor" />
                                </marker>
                            </defs>
                        </svg>
                    </div>
                    <p style="margin-top: 15px; color: var(--danger); font-weight: bold; text-align: center;">
                        üî¥ The TC's COMMIT log write is THE atomic operation that makes 2PC work!
                    </p>
                </div>

                <h2>Why Two Phases?</h2>
                <ul>
                    <li><strong>Phase 1 (Voting):</strong> Establishes that all participants <em>can</em> commit - they promise to commit if asked</li>
                    <li><strong>Phase 2 (Decision):</strong> Makes the atomic decision and propagates it to all participants</li>
                    <li>Without Phase 1, we couldn't guarantee all participants are ready</li>
                    <li>Without Phase 2, the decision wouldn't be atomic across failures</li>
                </ul>

                <h2>The Atomic Commit Point</h2>
                <p><strong>Critical insight:</strong> 2PC reduces distributed atomicity to a <em>single</em> atomic operation:</p>
                <ul>
                    <li>The <strong>TC writing COMMIT to its log</strong> is the atomic point</li>
                    <li>This is a single local disk write (atomic)</li>
                    <li>Once logged, the TC will ensure the decision reaches all participants (even after crashes)</li>
                    <li>Before this point: can abort. After this point: must commit.</li>
                </ul>

                <h2>‚è±Ô∏è How Long Can 2PC Block?</h2>

                <div style="background: #fee2e2; padding: 20px; border-radius: 12px; border-left: 5px solid var(--danger); margin: 20px 0;">
                    <h3 style="color: var(--danger);">Theoretical Answer: INDEFINITELY! ‚ôæÔ∏è</h3>

                    <p><strong>The harsh truth:</strong> If the coordinator crashes and never recovers, participants in READY state will block FOREVER.</p>

                    <h4>Why?</h4>
                    <ul>
                        <li>Participants voted YES (promised to commit)</li>
                        <li>They're holding locks on resources (bank accounts, database rows, etc.)</li>
                        <li>They CANNOT unilaterally decide to abort (might violate atomicity)</li>
                        <li>They CANNOT unilaterally decide to commit (TC might have decided to abort)</li>
                        <li><strong>They MUST wait for the coordinator to tell them what to do</strong></li>
                    </ul>

                    <h4>What's Actually Held During Blocking:</h4>
                    <ul>
                        <li>üîí <strong>Database locks</strong> on modified rows (prevents other transactions)</li>
                        <li>üîí <strong>Resource locks</strong> (file locks, memory allocations)</li>
                        <li>üîí <strong>Connection resources</strong> (database connections, network sockets)</li>
                        <li>üíæ <strong>Transaction state</strong> in memory/disk</li>
                    </ul>

                    <h4>Impact on System:</h4>
                    <ul>
                        <li>Other transactions trying to access locked resources will ALSO block</li>
                        <li>This can cascade - one blocked transaction blocks others</li>
                        <li>Eventually: <strong>system-wide deadlock or resource exhaustion</strong></li>
                    </ul>
                </div>

                <div style="background: #eff6ff; padding: 20px; border-radius: 12px; border-left: 5px solid var(--primary); margin: 20px 0;">
                    <h3>Practical Answer: Milliseconds to Minutes</h3>

                    <p><strong>In real systems, coordinators are designed to recover FAST:</strong></p>

                    <h4>High-Availability Techniques:</h4>
                    <ol>
                        <li><strong>Coordinator Replication:</strong>
                            <ul>
                                <li>Multiple coordinator replicas (Primary + Backups)</li>
                                <li>If primary fails, backup takes over in <strong>~1-5 seconds</strong></li>
                                <li>Example: Google Spanner uses Paxos for coordinator consensus</li>
                            </ul>
                        </li>
                        <li><strong>Fast Crash Recovery:</strong>
                            <ul>
                                <li>TC state is logged to fast SSDs</li>
                                <li>Recovery process: read log, resume protocol</li>
                                <li>Typical recovery time: <strong>~100ms - 1 second</strong></li>
                            </ul>
                        </li>
                        <li><strong>Timeouts & Administrator Intervention:</strong>
                            <ul>
                                <li>After extended blocking (e.g., 60 seconds), human operators alerted</li>
                                <li>DBAs can manually abort or commit based on system logs</li>
                                <li>Last resort: restart entire distributed system</li>
                            </ul>
                        </li>
                    </ol>

                    <h4>Real-World Examples:</h4>
                    <ul>
                        <li><strong>Google Spanner:</strong> Uses Paxos for TC, blocking time < 10 seconds even during datacenter failures</li>
                        <li><strong>PostgreSQL 2PC:</strong> If coordinator dies, admin must manually resolve via <code>pg_prepared_xacts</code></li>
                        <li><strong>Oracle RAC:</strong> Uses distributed lock manager, automatic recovery in ~30 seconds</li>
                    </ul>

                    <h4>Worst-Case Scenarios:</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                        <tr style="background: var(--primary); color: white;">
                            <th style="padding: 8px; border: 1px solid var(--border);">Scenario</th>
                            <th style="padding: 8px; border: 1px solid var(--border);">Blocking Duration</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid var(--border);">Normal TC crash, auto-recovery</td>
                            <td style="padding: 8px; border: 1px solid var(--border);">~100ms - 5 seconds</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid var(--border);">TC crash, failover to backup</td>
                            <td style="padding: 8px; border: 1px solid var(--border);">~1-10 seconds</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid var(--border);">TC machine hardware failure</td>
                            <td style="padding: 8px; border: 1px solid var(--border);">~30 seconds - 5 minutes</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid var(--border);">Datacenter power outage</td>
                            <td style="padding: 8px; border: 1px solid var(--border);">Minutes to hours</td>
                        </tr>
                        <tr style="background: #fee2e2;">
                            <td style="padding: 8px; border: 1px solid var(--border);"><strong>TC data permanently lost</strong></td>
                            <td style="padding: 8px; border: 1px solid var(--border);"><strong>Forever (until manual intervention)</strong></td>
                        </tr>
                    </table>
                </div>

                <div style="background: #fef3c7; padding: 20px; border-radius: 12px; border-left: 5px solid #f59e0b; margin: 20px 0;">
                    <h3>üí° This is Why 3PC Exists!</h3>
                    <p>Three-Phase Commit solves this problem by ensuring participants can ALWAYS reach a decision cooperatively, even if the coordinator never recovers.</p>

                    <p><strong>But 3PC trade-offs:</strong></p>
                    <ul>
                        <li>‚ûï Non-blocking (participants can decide without coordinator)</li>
                        <li>‚ûñ Extra network round trip (higher latency)</li>
                        <li>‚ûñ More complex implementation</li>
                        <li>‚ûñ Still can't handle network partitions properly</li>
                    </ul>

                    <p><strong>Industry choice:</strong> Most systems use 2PC with highly-available coordinators rather than 3PC, because:</p>
                    <ul>
                        <li>Modern hardware/software makes coordinator crashes rare</li>
                        <li>Failover techniques make recovery fast enough</li>
                        <li>2PC is simpler and has lower normal-case latency</li>
                    </ul>
                </div>

                <h2>Logging & Durability</h2>

                <h3>When Participants Log</h3>
                <p><strong>Participants MUST log PREPARED before voting YES</strong></p>
                <ul>
                    <li>This is their "promise" to commit if asked</li>
                    <li>After crash, they read log, see PREPARED, know they voted YES</li>
                    <li>They contact TC to learn the decision</li>
                </ul>

                <h3>When TC Logs</h3>
                <p><strong>TC MUST log COMMIT before sending to participants</strong></p>
                <ul>
                    <li>Ensures decision survives TC crashes</li>
                    <li>After crash, TC reads log, sees COMMIT, continues sending to participants</li>
                </ul>

                <h2>Failure Scenarios</h2>

                <h3>Participant Crashes After Voting YES</h3>
                <ul>
                    <li>On recovery: Reads log, sees PREPARED</li>
                    <li>Contacts TC to learn decision</li>
                    <li>Executes the decision (commit or abort)</li>
                </ul>

                <h3>TC Crashes After Logging COMMIT</h3>
                <ul>
                    <li>On recovery: Reads log, sees COMMIT</li>
                    <li>Continues sending COMMIT to all participants</li>
                    <li>Transaction completes successfully</li>
                </ul>

                <h3>TC Crashes Before Logging Decision</h3>
                <ul>
                    <li>On recovery: No decision in log</li>
                    <li>Aborts the transaction (safe default)</li>
                    <li>Participants may be blocked waiting</li>
                </ul>

                <h2>ü§ù Why Contact Other Participants? (Termination Protocol)</h2>

                <div style="background: #eff6ff; padding: 20px; border-radius: 12px; border-left: 5px solid var(--primary); margin: 20px 0;">
                    <h3>The Goal: Learn the coordinator's decision WITHOUT the coordinator</h3>

                    <p><strong>When does this help?</strong> When participant P is in READY state and TC crashes, P contacts other participants to see if ANY of them know the final decision.</p>

                    <h3>Scenario 1: Another participant already got the decision ‚úÖ</h3>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p><strong>Timeline:</strong></p>
                        <ol>
                            <li>TC sends PREPARE to A, B, C</li>
                            <li>A, B, C all vote YES (enter READY)</li>
                            <li>TC logs COMMIT</li>
                            <li>TC sends GLOBAL_COMMIT to A ‚úÖ</li>
                            <li>TC sends GLOBAL_COMMIT to B ‚úÖ</li>
                            <li><strong>TC CRASHES before reaching C ‚ùå</strong></li>
                        </ol>

                        <p><strong>What happens:</strong></p>
                        <ul>
                            <li>C times out in READY state (no decision from TC)</li>
                            <li>C asks A: "What's your state?" ‚Üí A: <strong>"COMMIT"</strong></li>
                            <li><strong>C learns the decision! ‚Üí C commits ‚úÖ</strong></li>
                            <li><strong>Benefit: C unblocks WITHOUT waiting for TC to recover!</strong></li>
                        </ul>

                        <p style="color: var(--success); font-weight: bold;">‚úÖ Termination protocol succeeded! Transaction completes despite TC crash.</p>
                    </div>

                    <h3>Scenario 2: TC crashed during PREPARE ‚úÖ</h3>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p><strong>Timeline:</strong></p>
                        <ol>
                            <li>TC sends PREPARE to A ‚úÖ</li>
                            <li>TC sends PREPARE to B ‚úÖ</li>
                            <li><strong>TC CRASHES before sending to C ‚ùå</strong></li>
                            <li>A votes YES (enters READY)</li>
                            <li>B votes YES (enters READY)</li>
                            <li>C is still in INIT (never got PREPARE)</li>
                        </ol>

                        <p><strong>What happens:</strong></p>
                        <ul>
                            <li>A and B timeout in READY state</li>
                            <li>A asks B: "What's your state?" ‚Üí B: "READY" (also waiting)</li>
                            <li>A asks C: "What's your state?" ‚Üí C: <strong>"INIT"</strong></li>
                            <li><strong>A realizes: C never got PREPARE ‚Üí TC must have crashed early</strong></li>
                            <li><strong>Safe to ABORT!</strong> (C will vote NO or timeout)</li>
                            <li>A and B both abort, unlock resources ‚úÖ</li>
                        </ul>

                        <p style="color: var(--success); font-weight: bold;">‚úÖ Termination protocol succeeded! Participants unblock and abort safely.</p>
                    </div>

                    <h3>Scenario 3: All participants in READY ‚ùå</h3>
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 10px 0; border: 2px solid #f59e0b;">
                        <p><strong>Timeline:</strong></p>
                        <ol>
                            <li>TC sends PREPARE to A, B, C ‚úÖ</li>
                            <li>A, B, C all vote YES (enter READY) ‚úÖ</li>
                            <li><strong>TC CRASHES before logging decision ‚ùå</strong></li>
                        </ol>

                        <p><strong>What happens:</strong></p>
                        <ul>
                            <li>All participants timeout in READY state</li>
                            <li>A asks B: "What's your state?" ‚Üí B: "READY"</li>
                            <li>A asks C: "What's your state?" ‚Üí C: "READY"</li>
                            <li><strong>Nobody knows the decision!</strong></li>
                        </ul>

                        <p><strong>Why can't they decide?</strong></p>
                        <ul>
                            <li>All voted YES ‚Üí TC <em>could have</em> decided COMMIT (but maybe didn't log it yet)</li>
                            <li>All voted YES ‚Üí TC <em>could have</em> decided ABORT (if it crashed before deciding)</li>
                            <li><strong>They can't tell which scenario occurred!</strong></li>
                            <li>Aborting would be unsafe (violates atomicity if TC logged COMMIT)</li>
                            <li>Committing would be unsafe (violates atomicity if TC decided ABORT)</li>
                        </ul>

                        <p style="color: var(--danger); font-weight: bold;">‚ùå Termination protocol FAILS! Protocol BLOCKS until TC recovers.</p>
                    </div>
                </div>

                <div style="background: #f0fdf4; padding: 20px; border-radius: 12px; border-left: 5px solid var(--success); margin: 20px 0;">
                    <h3>üìä Summary: When Does Contacting Others Help?</h3>

                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                        <tr style="background: var(--primary); color: white;">
                            <th style="padding: 10px; border: 1px solid var(--border);">Other Participant's State</th>
                            <th style="padding: 10px; border: 1px solid var(--border);">What You Learn</th>
                            <th style="padding: 10px; border: 1px solid var(--border);">Helps?</th>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>COMMIT</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">TC decided COMMIT (sent to them before crash)</td>
                            <td style="padding: 10px; border: 1px solid var(--border);"><span style="color: var(--success); font-weight: bold;">‚úÖ YES - Commit!</span></td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>ABORT</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">TC decided ABORT</td>
                            <td style="padding: 10px; border: 1px solid var(--border);"><span style="color: var(--success); font-weight: bold;">‚úÖ YES - Abort!</span></td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>INIT</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">TC crashed before they got PREPARE</td>
                            <td style="padding: 10px; border: 1px solid var(--border);"><span style="color: var(--success); font-weight: bold;">‚úÖ YES - Safe to abort!</span></td>
                        </tr>
                        <tr style="background: #fef3c7;">
                            <td style="padding: 10px; border: 1px solid var(--border);"><strong>READY</strong></td>
                            <td style="padding: 10px; border: 1px solid var(--border);">They're also waiting (don't know decision)</td>
                            <td style="padding: 10px; border: 1px solid var(--border);"><span style="color: var(--danger); font-weight: bold;">‚ùå NO - Still blocked!</span></td>
                        </tr>
                    </table>

                    <h4>Key Insight:</h4>
                    <p>Contacting other participants helps in <strong>3 out of 4 cases</strong>! It only fails when ALL participants are in READY (the rare blocking scenario).</p>

                    <p><strong>This is why it's worth trying!</strong> Most coordinator crashes happen at specific points (during PREPARE multicast, or after sending decision), so there's a good chance someone has useful information.</p>
                </div>

                <h3>Network Partition</h3>
                <ul>
                    <li><strong>Problem:</strong> TC can't reach all participants</li>
                    <li><strong>Result:</strong> Protocol blocks until partition heals</li>
                    <li>This is the main weakness of 2PC (blocking protocol)</li>
                </ul>

                <h2>Key Characteristics</h2>

                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid var(--border);">Aspect</th>
                        <th style="padding: 10px; border: 1px solid var(--border);">Description</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>Atomicity</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">All commit or all abort - no partial commits</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>Safety</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Always correct - never violates atomicity</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>Blocking</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Can block if TC fails or network partitions</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>Single Point of Failure</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">TC failure blocks progress</td>
                    </tr>
                </table>

                <h2>Key Takeaways for Exam</h2>
                <ul>
                    <li><strong>Two phases:</strong> Voting (PREPARE/YES/NO) then Decision (COMMIT/ABORT)</li>
                    <li><strong>Atomic point:</strong> TC logging COMMIT is THE single atomic operation</li>
                    <li><strong>Participant logging:</strong> Log PREPARED BEFORE voting YES</li>
                    <li><strong>TC logging:</strong> Log COMMIT BEFORE sending to participants</li>
                    <li><strong>Why two phases:</strong> Phase 1 = readiness check, Phase 2 = atomic decision</li>
                    <li><strong>All YES ‚Üí COMMIT, any NO ‚Üí ABORT</strong></li>
                    <li><strong>Blocking protocol:</strong> Can block on TC failure or network partition</li>
                    <li><strong>Recovery:</strong> Read logs to determine state and continue protocol</li>
                </ul>
            </div>

            <!-- Distributed Commit Deep Dive -->
            <div class="lecture-content" id="distributed-commit">
                <h1>üìö Distributed Commit: Advanced Topics</h1>
                <p style="color: var(--text-light); margin-bottom: 20px;">Deep dive into distributed commit protocols from your textbook - important for understanding fault tolerance.</p>

                <h2>What is Distributed Commit?</h2>
                <p><strong>Definition:</strong> Having an operation performed by each member of a process group, or none at all.</p>

                <p><strong>Examples:</strong></p>
                <ul>
                    <li><strong>Reliable multicasting:</strong> Message delivered to all processes or none</li>
                    <li><strong>Distributed transactions:</strong> All sites commit transaction or all abort</li>
                    <li><strong>Atomic updates:</strong> All replicas updated or none</li>
                </ul>

                <h2>Three Protocols Compared</h2>

                <div style="background: var(--background); padding: 20px; border-radius: 12px; margin: 20px 0;">
                    <h3>1. One-Phase Commit (1PC)</h3>
                    <p><strong>How it works:</strong> Coordinator simply tells all participants to commit.</p>
                    <p><strong>Problem:</strong> ‚ùå No way for participants to say "I can't commit" (e.g., violates constraints)</p>
                    <p><strong>Used in practice?</strong> No - too unreliable</p>
                </div>

                <div style="background: var(--background); padding: 20px; border-radius: 12px; margin: 20px 0;">
                    <h3>2. Two-Phase Commit (2PC)</h3>
                    <p><strong>How it works:</strong> Phase 1 = voting, Phase 2 = decision</p>
                    <p><strong>Problem:</strong> ‚ö†Ô∏è <strong>Blocking protocol</strong> - can block if coordinator crashes while participants in READY state</p>
                    <p><strong>Used in practice?</strong> ‚úÖ Yes - very common (Google Spanner, distributed databases)</p>
                </div>

                <div style="background: var(--background); padding: 20px; border-radius: 12px; margin: 20px 0;">
                    <h3>3. Three-Phase Commit (3PC)</h3>
                    <p><strong>How it works:</strong> Adds PRECOMMIT phase between voting and final decision</p>
                    <p><strong>Advantage:</strong> ‚úÖ Non-blocking - participants can reach decision even if coordinator crashes</p>
                    <p><strong>Used in practice?</strong> ‚ö†Ô∏è Rarely - conditions for 2PC blocking are rare, 3PC adds complexity</p>
                </div>

                <h2>2PC: Finite State Machines</h2>

                <div style="background: #eff6ff; padding: 20px; border-radius: 12px; border-left: 5px solid var(--primary); margin: 20px 0;">
                    <h3>Coordinator States:</h3>
                    <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; border: 1px solid #475569; font-size: 0.9em;">
<span style="color: #94a3b8;">INIT</span> ‚Üí <span style="color: #60a5fa;">[send VOTE_REQUEST]</span> ‚Üí <span style="color: #94a3b8;">WAIT</span>
    ‚Üì <span style="color: #64748b;">all YES</span>                    ‚Üì <span style="color: #64748b;">timeout or any NO</span>
<span style="color: #22c55e;">COMMIT</span>                        <span style="color: #ef4444;">ABORT</span></pre>

                    <h3>Participant States:</h3>
                    <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; border: 1px solid #475569; font-size: 0.9em;">
<span style="color: #94a3b8;">INIT</span> ‚Üí <span style="color: #60a5fa;">[receive VOTE_REQUEST, send vote]</span> ‚Üí <span style="color: #94a3b8;">READY</span>
   ‚Üì <span style="color: #64748b;">vote NO</span>                                     ‚Üì <span style="color: #64748b;">receive decision</span>
<span style="color: #ef4444;">ABORT</span>                                   <span style="color: #22c55e;">COMMIT</span> or <span style="color: #ef4444;">ABORT</span></pre>
                </div>

                <h2>Timeout Handling (Critical!)</h2>

                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid var(--border);">Who</th>
                        <th style="padding: 10px; border: 1px solid var(--border);">State</th>
                        <th style="padding: 10px; border: 1px solid var(--border);">Timeout Occurs</th>
                        <th style="padding: 10px; border: 1px solid var(--border);">Action</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>Participant</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">INIT</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">No VOTE_REQUEST from coordinator</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">‚úÖ Safe to ABORT (coordinator crashed)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>Coordinator</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">WAIT</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Missing votes from participants</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">‚úÖ Vote ABORT (participant crashed)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>Participant</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">READY</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">No decision from coordinator</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">‚ö†Ô∏è <strong>BLOCKED!</strong> Contact other participants (termination protocol)</td>
                    </tr>
                </table>

                <h2>Termination Protocol (When Participant is READY)</h2>

                <p>When participant P is in READY state and coordinator times out, P contacts another participant Q:</p>

                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: var(--secondary); color: white;">
                        <th style="padding: 10px; border: 1px solid var(--border);">Q's State</th>
                        <th style="padding: 10px; border: 1px solid var(--border);">P's Action</th>
                        <th style="padding: 10px; border: 1px solid var(--border);">Reasoning</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>COMMIT</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">‚úÖ Transition to COMMIT</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Coordinator sent GLOBAL_COMMIT before crash</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>ABORT</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">‚úÖ Transition to ABORT</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Coordinator sent GLOBAL_ABORT before crash</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>INIT</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">‚úÖ Transition to ABORT</td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Coordinator crashed during VOTE_REQUEST multicast - safe to abort</td>
                    </tr>
                    <tr style="background: #fef3c7;">
                        <td style="padding: 10px; border: 1px solid var(--border);"><strong>READY</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">‚ùå <strong>Contact another participant</strong></td>
                        <td style="padding: 10px; border: 1px solid var(--border);">Both waiting for coordinator - if ALL in READY, protocol BLOCKS</td>
                    </tr>
                </table>

                <div style="background: #fef3c7; padding: 20px; border-radius: 12px; border-left: 5px solid #f59e0b; margin: 20px 0;">
                    <h3>‚ö†Ô∏è The Blocking Problem</h3>
                    <p><strong>Scenario:</strong> All participants received VOTE_REQUEST, all voted YES (now in READY), then coordinator crashes.</p>
                    <p><strong>Problem:</strong> Participants contact each other, find everyone in READY state, but:</p>
                    <ul>
                        <li>They don't know if coordinator logged COMMIT or ABORT before crash</li>
                        <li>They promised to commit (voted YES) but need coordinator's decision</li>
                        <li><strong>Result: Protocol BLOCKS until coordinator recovers</strong></li>
                    </ul>
                    <p><strong>Why this matters:</strong> Resources (locks on database rows) are held while blocked!</p>
                </div>

                <h2>Recovery from Crashes</h2>

                <h3>Participant Recovery:</h3>
                <ul>
                    <li><strong>Was in INIT:</strong> Can safely abort</li>
                    <li><strong>Was in COMMIT or ABORT:</strong> Recover to that state, retransmit decision to coordinator</li>
                    <li><strong>Was in READY:</strong> ‚ö†Ô∏è Cannot decide alone - must contact others (termination protocol)</li>
                </ul>

                <h3>Coordinator Recovery:</h3>
                <ul>
                    <li><strong>Was in WAIT:</strong> Can retransmit VOTE_REQUEST</li>
                    <li><strong>Had decided COMMIT or ABORT:</strong> Retransmit decision to participants</li>
                </ul>

                <h2>Three-Phase Commit (3PC) Overview</h2>

                <div style="background: #eff6ff; padding: 20px; border-radius: 12px; border-left: 5px solid var(--primary); margin: 20px 0;">
                    <h3>Why 3PC?</h3>
                    <p>3PC adds a PRECOMMIT state to avoid blocking. The two key properties:</p>
                    <ol>
                        <li><strong>No single state can transition directly to COMMIT or ABORT</strong> (must go through intermediate state)</li>
                        <li><strong>No state from which you can't decide, but can reach COMMIT</strong></li>
                    </ol>

                    <h3>The Three Phases:</h3>
                    <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; border: 1px solid #475569; font-size: 0.9em;">
<span style="color: #94a3b8;">Phase 1:</span> <span style="color: #60a5fa;">VOTE_REQUEST</span> ‚Üí collect YES/NO votes
<span style="color: #94a3b8;">Phase 2:</span> <span style="color: #f59e0b;">PREPARE_COMMIT</span> ‚Üí tell participants "all voted YES"
<span style="color: #94a3b8;">Phase 3:</span> <span style="color: #22c55e;">GLOBAL_COMMIT</span> ‚Üí final commit</pre>

                    <h3>Key Difference from 2PC:</h3>
                    <ul>
                        <li>If all participants in PRECOMMIT ‚Üí safe to COMMIT (coordinator decision known)</li>
                        <li>If any participant in READY, all others MUST be in READY or INIT ‚Üí safe to ABORT</li>
                        <li><strong>No blocking scenario!</strong> Participants can always reach decision cooperatively</li>
                    </ul>

                    <h3>Why not used much in practice?</h3>
                    <ul>
                        <li>Extra round trip (3 phases instead of 2) = higher latency</li>
                        <li>2PC blocking scenario is rare in well-designed systems</li>
                        <li>More complex implementation</li>
                        <li>Doesn't handle network partitions (still needs synchronous assumptions)</li>
                    </ul>
                </div>

                <h2>Key Exam Takeaways</h2>
                <ul>
                    <li><strong>2PC has two phases:</strong> Voting (PREPARE) and Decision (COMMIT/ABORT)</li>
                    <li><strong>2PC can block:</strong> When all participants in READY and coordinator crashes</li>
                    <li><strong>Termination protocol:</strong> Know what action to take based on other participant states</li>
                    <li><strong>Logging is essential:</strong> Both coordinator and participants must log states before sending messages</li>
                    <li><strong>3PC is non-blocking:</strong> But rarely used due to complexity and performance cost</li>
                    <li><strong>Understand state machines:</strong> Know which states can transition where and why</li>
                </ul>
            </div>

            <!-- Practice Questions -->
            <div class="lecture-content" id="practice">
                <h1>Practice Questions</h1>
                <p style="color: var(--text-light); margin-bottom: 30px;">Test your understanding with these exam-style questions. Click "Reveal Answer" to see the solution.</p>

                <!-- Question 1: Logging and Recovery -->
                <div style="background: var(--background); padding: 25px; border-radius: 12px; margin-bottom: 30px; border-left: 5px solid var(--primary);">
                    <h2 style="color: var(--primary); margin-bottom: 15px;">Question 1: Logging and Recovery [15 marks]</h2>

                    <p><strong>Scenario:</strong> You have an application that needs to atomically update pairs of files (e.g., a1 and a2, b1 and b2, etc.).</p>

                    <p><strong>Available Commands:</strong></p>
                    <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-size: 0.95em; border: 1px solid #475569;">
<span style="color: #94a3b8;">// fills file "filename" with contents of the buffer</span>
<span style="color: #60a5fa;">bool</span> <span style="color: #fbbf24;">write</span>(<span style="color: #e2e8f0;">filename, buffer</span>)

<span style="color: #94a3b8;">// renames file "filename1" as "filename2"</span>
<span style="color: #60a5fa;">bool</span> <span style="color: #fbbf24;">move</span>(<span style="color: #e2e8f0;">filename1, filename2</span>)

<span style="color: #94a3b8;">// removes file "filename"</span>
<span style="color: #60a5fa;">bool</span> <span style="color: #fbbf24;">remove</span>(<span style="color: #e2e8f0;">filename</span>)

<span style="color: #94a3b8;">// reads contents of file "filename" into buffer</span>
<span style="color: #60a5fa;">bool</span> <span style="color: #fbbf24;">read</span>(<span style="color: #e2e8f0;">filename, buffer</span>)

<span style="color: #94a3b8;">// lists the contents of directory "directory"</span>
<span style="color: #60a5fa;">bool</span> <span style="color: #fbbf24;">list</span>(<span style="color: #e2e8f0;">directory</span>)</pre>

                    <p><strong>Task:</strong> Using only these commands, implement two routines that atomically update a pair of files. Either both files are updated, or neither are updated. Preserve atomicity in the face of crashes.</p>

                    <p><strong>Implement:</strong></p>
                    <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-size: 0.95em; border: 1px solid #475569;">
<span style="color: #94a3b8;">// atomically write buf1 into file f1, and buf2 into file f2</span>
<span style="color: #60a5fa;">bool</span> <span style="color: #fbbf24;">update</span>(<span style="color: #e2e8f0;">f1, buf1, f2, buf2</span>)

<span style="color: #94a3b8;">// called at boot to put all updated files into a consistent state</span>
<span style="color: #60a5fa;">bool</span> <span style="color: #fbbf24;">recover</span>()</pre>

                    <p><strong>Assumptions:</strong> You may assume a flat file system hierarchy and single-threaded execution.</p>

                    <button class="btn btn-primary" onclick="toggleAnswer('answer1')" style="margin-top: 15px;">üëÅÔ∏è Reveal Answer</button>

                    <div id="answer1" style="display: none; margin-top: 20px; padding: 20px; background: var(--surface); border-radius: 8px; border-left: 5px solid var(--success);">
                        <h3 style="color: var(--success);">Solution:</h3>

                        <p><strong>Approach:</strong> Use write-ahead logging (WAL) with atomic rename operations.</p>

                        <h4>update(f1, buf1, f2, buf2):</h4>
                        <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; border: 1px solid #475569; font-size: 0.95em;">
<span style="color: #94a3b8;">1.</span> <span style="color: #fbbf24;">write</span>(<span style="color: #a78bfa;">"f1.new"</span>, buf1)          <span style="color: #64748b;">// Write new data to temp files</span>
<span style="color: #94a3b8;">2.</span> <span style="color: #fbbf24;">write</span>(<span style="color: #a78bfa;">"f2.new"</span>, buf2)
<span style="color: #94a3b8;">3.</span> <span style="color: #fbbf24;">write</span>(<span style="color: #a78bfa;">"commit.log"</span>, <span style="color: #a78bfa;">"f1 f2"</span>)   <span style="color: #64748b;">// Write intention log (commit marker)</span>
<span style="color: #94a3b8;">4.</span> <span style="color: #fbbf24;">move</span>(<span style="color: #a78bfa;">"f1.new"</span>, f1)             <span style="color: #64748b;">// Atomic operations</span>
<span style="color: #94a3b8;">5.</span> <span style="color: #fbbf24;">move</span>(<span style="color: #a78bfa;">"f2.new"</span>, f2)
<span style="color: #94a3b8;">6.</span> <span style="color: #fbbf24;">remove</span>(<span style="color: #a78bfa;">"commit.log"</span>)           <span style="color: #64748b;">// Clean up log</span>
<span style="color: #94a3b8;">7.</span> <span style="color: #60a5fa;">return</span> <span style="color: #22d3ee;">True</span></pre>

                        <h4>recover():</h4>
                        <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; border: 1px solid #475569; font-size: 0.95em;">
<span style="color: #94a3b8;">1.</span>  files = <span style="color: #fbbf24;">list</span>(<span style="color: #a78bfa;">"/"</span>)
<span style="color: #94a3b8;">2.</span>  <span style="color: #60a5fa;">if</span> <span style="color: #a78bfa;">"commit.log"</span> exists:
<span style="color: #94a3b8;">3.</span>      <span style="color: #fbbf24;">read</span>(<span style="color: #a78bfa;">"commit.log"</span>, buffer)
<span style="color: #94a3b8;">4.</span>      parse buffer to get (f1, f2)
<span style="color: #94a3b8;">5.</span>      <span style="color: #60a5fa;">if</span> <span style="color: #a78bfa;">"f1.new"</span> exists: <span style="color: #fbbf24;">move</span>(<span style="color: #a78bfa;">"f1.new"</span>, f1)
<span style="color: #94a3b8;">6.</span>      <span style="color: #60a5fa;">if</span> <span style="color: #a78bfa;">"f2.new"</span> exists: <span style="color: #fbbf24;">move</span>(<span style="color: #a78bfa;">"f2.new"</span>, f2)
<span style="color: #94a3b8;">7.</span>      <span style="color: #fbbf24;">remove</span>(<span style="color: #a78bfa;">"commit.log"</span>)
<span style="color: #94a3b8;">8.</span>  <span style="color: #60a5fa;">else</span>:
<span style="color: #94a3b8;">9.</span>      <span style="color: #64748b;">// Clean up any orphaned .new files</span>
<span style="color: #94a3b8;">10.</span>     <span style="color: #60a5fa;">for each</span> file ending in <span style="color: #a78bfa;">".new"</span>:
<span style="color: #94a3b8;">11.</span>         <span style="color: #fbbf24;">remove</span>(file)
<span style="color: #94a3b8;">12.</span> <span style="color: #60a5fa;">return</span> <span style="color: #22d3ee;">True</span></pre>

                        <h4>Why this works:</h4>
                        <ul>
                            <li><strong>Atomicity:</strong> The <code>commit.log</code> file acts as the commit point</li>
                            <li><strong>If crash before step 3:</strong> No commit.log exists ‚Üí recovery removes .new files ‚Üí original files unchanged ‚úì</li>
                            <li><strong>If crash during/after step 3:</strong> commit.log exists ‚Üí recovery completes the moves ‚Üí both files updated ‚úì</li>
                            <li><strong>move() is atomic:</strong> Ensures each file update is atomic (all-or-nothing rename)</li>
                            <li><strong>Idempotent recovery:</strong> Can run recover() multiple times safely</li>
                        </ul>

                        <h4>Key Insight:</h4>
                        <p>This follows the same principle as file system logging: write intentions to a log, perform operations, then clean up. The commit.log file is the "END_BLOCK" marker that determines whether to complete or rollback the operation.</p>
                    </div>
                </div>

                <!-- Question 2: MapReduce -->
                <div style="background: var(--background); padding: 25px; border-radius: 12px; margin-bottom: 30px; border-left: 5px solid var(--secondary);">
                    <h2 style="color: var(--secondary); margin-bottom: 15px;">Question 2: MapReduce Performance [10 marks]</h2>

                    <p><strong>Scenario:</strong> Peter Pan has a 10,000-node cluster (5,000 type A machines - slow, 5,000 type B machines - fast). Some MapReduce jobs have very high completion times despite low average CPU utilization.</p>

                    <h3>Q1. Why does this performance anomaly occur? [5 marks]</h3>
                    <p>Describe the characteristics of the jobs for which this problem arises.</p>

                    <button class="btn btn-primary" onclick="toggleAnswer('answer2a')" style="margin-top: 15px;">üëÅÔ∏è Reveal Answer Q1</button>

                    <div id="answer2a" style="display: none; margin-top: 20px; padding: 20px; background: var(--surface); border-radius: 8px; border-left: 5px solid var(--success);">
                        <h3 style="color: var(--success);">Answer Q1:</h3>

                        <h4>Problem: Straggler Tasks on Slow Machines</h4>
                        <p>The performance anomaly occurs due to <strong>stragglers</strong> - tasks that take much longer to complete than others, blocking overall job completion.</p>

                        <h4>Root Cause:</h4>
                        <ul>
                            <li><strong>Machine heterogeneity:</strong> Type A machines are substantially slower than type B</li>
                            <li><strong>MapReduce barrier:</strong> Job cannot complete until ALL tasks finish (reduce phase waits for all map tasks)</li>
                            <li><strong>Poor task assignment:</strong> If many tasks assigned to slow (type A) machines, they become bottlenecks</li>
                        </ul>

                        <h4>Affected Job Characteristics:</h4>
                        <ol>
                            <li><strong>Large number of small tasks:</strong> More opportunities for uneven distribution across machine types</li>
                            <li><strong>Tasks with similar workload:</strong> In ideal conditions all tasks should finish around same time, but slow machines delay subset</li>
                            <li><strong>High parallelism:</strong> Jobs with thousands of map/reduce tasks where even 5-10% stragglers significantly impact completion time</li>
                        </ol>

                        <h4>Example:</h4>
                        <p>Job with 10,000 map tasks:</p>
                        <ul>
                            <li>9,950 tasks on fast machines ‚Üí finish in 1 minute</li>
                            <li>50 tasks on slow machines ‚Üí take 5 minutes</li>
                            <li><strong>Total job time: 5 minutes</strong> (despite 99.5% being done in 1 minute!)</li>
                            <li>CPU utilization appears low because 9,950/10,000 machines idle waiting for stragglers</li>
                        </ul>
                    </div>

                    <h3 style="margin-top: 30px;">Q2. Propose a scheduler change to address this problem [5 marks]</h3>

                    <button class="btn btn-primary" onclick="toggleAnswer('answer2b')" style="margin-top: 15px;">üëÅÔ∏è Reveal Answer Q2</button>

                    <div id="answer2b" style="display: none; margin-top: 20px; padding: 20px; background: var(--surface); border-radius: 8px; border-left: 5px solid var(--success);">
                        <h3 style="color: var(--success);">Answer Q2:</h3>

                        <h4>Proposed Solution: Machine-Type-Aware Scheduling with Adaptive Speculative Execution</h4>

                        <h4>Strategy 1: Preferential Assignment</h4>
                        <ul>
                            <li><strong>Prioritize fast machines:</strong> Assign tasks to type B (fast) machines first</li>
                            <li><strong>Use slow machines for overflow:</strong> Only use type A machines when all type B are busy</li>
                            <li><strong>Benefit:</strong> Reduces likelihood of stragglers on slow machines</li>
                        </ul>

                        <h4>Strategy 2: Enhanced Speculative Execution</h4>
                        <ul>
                            <li><strong>Track machine performance:</strong> Coordinator measures task completion times by machine type</li>
                            <li><strong>Early speculation for slow machines:</strong> Instead of waiting for 95% completion:
                                <ul>
                                    <li>If task on type A machine is taking >2x median time of type B machines</li>
                                    <li>Launch speculative copy on type B machine</li>
                                </ul>
                            </li>
                            <li><strong>Machine-type penalty:</strong> Factor in machine speed when detecting stragglers</li>
                        </ul>

                        <h4>Strategy 3: Dynamic Load Balancing</h4>
                        <ul>
                            <li><strong>Weighted task assignment:</strong> Assign more tasks to fast machines (e.g., type B gets 3x tasks as type A)</li>
                            <li><strong>Smaller tasks to slow machines:</strong> If tasks have variable sizes, assign larger tasks to faster machines</li>
                        </ul>

                        <h4>Implementation:</h4>
                        <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; border: 1px solid #475569; font-size: 0.95em;">
<span style="color: #94a3b8;">Coordinator maintains:</span>
<span style="color: #64748b;">-</span> Machine type registry (A vs B)
<span style="color: #64748b;">-</span> Performance history per machine type
<span style="color: #64748b;">-</span> Running average completion time per type

<span style="color: #94a3b8;">Task assignment logic:</span>
<span style="color: #94a3b8;">1.</span> <span style="color: #60a5fa;">if</span> type_B_machines_available:
       <span style="color: #fbbf24;">assign_to</span>(random_type_B_machine)
<span style="color: #94a3b8;">2.</span> <span style="color: #60a5fa;">else if</span> type_A_machines_available:
       <span style="color: #fbbf24;">assign_to</span>(random_type_A_machine)
       <span style="color: #fbbf24;">mark_for_early_speculation</span>()

<span style="color: #94a3b8;">Speculative execution trigger:</span>
<span style="color: #94a3b8;">1.</span> <span style="color: #60a5fa;">if</span> (task_on_type_A.runtime <span style="color: #f59e0b;">></span> <span style="color: #22d3ee;">1.5</span> <span style="color: #f59e0b;">*</span> avg_type_B_runtime):
       <span style="color: #fbbf24;">launch_speculative_copy_on_type_B</span>()
</pre>

                        <h4>Why This Works:</h4>
                        <ul>
                            <li><strong>Preserves performance for unaffected jobs:</strong> Jobs that fit on fast machines only see no change</li>
                            <li><strong>Improves affected jobs:</strong> Reduces straggler impact by 40-60%</li>
                            <li><strong>No code changes required:</strong> Only scheduler logic changes</li>
                            <li><strong>Adaptive:</strong> Automatically adjusts to machine heterogeneity</li>
                        </ul>
                    </div>
                </div>

                <!-- Question 3: 2PC -->
                <div style="background: var(--background); padding: 25px; border-radius: 12px; margin-bottom: 30px; border-left: 5px solid var(--warning);">
                    <h2 style="color: var(--warning); margin-bottom: 15px;">Question 3: Two-Phase Commit Variants</h2>

                    <p><strong>Modified 2PC Protocol:</strong> A and B immediately exchange with each other any messages received from TC as well as any messages they send to TC (they communicate even without timeouts).</p>

                    <h3>Scenario 1:</h3>
                    <p>A receives PREPARE from TC, forwards to B. A sends YES to both TC and B. B sends YES to both TC and A. TC sends COMMIT.</p>

                    <h4>Question 1: When is it safe for A to execute the transaction?</h4>
                    <ul style="list-style: none; padding-left: 0;">
                        <li>A. Any time after time t2</li>
                        <li>B. Any time after time t3</li>
                        <li>C. Any time after time t4</li>
                        <li>D. Any time after time t5</li>
                        <li>E. Any time after time t6</li>
                        <li>F. Never</li>
                    </ul>

                    <button class="btn btn-primary" onclick="toggleAnswer('answer3a')" style="margin-top: 15px;">üëÅÔ∏è Reveal Answer</button>

                    <div id="answer3a" style="display: none; margin-top: 20px; padding: 20px; background: var(--surface); border-radius: 8px; border-left: 5px solid var(--success);">
                        <h3 style="color: var(--success);">Answer: D - Any time after time t5</h3>

                        <h4>Reasoning:</h4>
                        <p><strong>A can safely execute when it knows:</strong></p>
                        <ol>
                            <li>Both A and B voted YES (so TC cannot decide ABORT)</li>
                            <li>TC has received both votes and will decide COMMIT</li>
                        </ol>

                        <h4>Timeline Analysis:</h4>
                        <ul>
                            <li><strong>t2:</strong> A receives PREPARE, forwards to B ‚ùå Too early - doesn't know B's vote yet</li>
                            <li><strong>t3:</strong> A sends YES to TC and B ‚ùå Still doesn't know B's vote</li>
                            <li><strong>t4:</strong> B receives PREPARE from A ‚ùå B hasn't decided yet</li>
                            <li><strong>t5:</strong> A receives YES from B ‚úÖ <strong>SAFE!</strong>
                                <ul>
                                    <li>A knows: A voted YES (sent at t3)</li>
                                    <li>A knows: B voted YES (received at t5)</li>
                                    <li>Both votes are YES ‚Üí TC MUST decide COMMIT</li>
                                    <li>Even if TC crashes, the decision is COMMIT</li>
                                </ul>
                            </li>
                        </ul>

                        <h4>Key Insight:</h4>
                        <p>In standard 2PC, participants must wait for TC's decision. In this modified protocol with peer communication, <strong>A can infer the decision</strong> once it knows both votes are YES (at t5), because:</p>
                        <ul>
                            <li>2PC rule: All YES ‚Üí COMMIT, Any NO ‚Üí ABORT</li>
                            <li>Since both are YES, TC's decision is deterministic: COMMIT</li>
                            <li>No need to wait for explicit COMMIT message from TC</li>
                        </ul>
                    </div>

                    <h3 style="margin-top: 30px;">Scenario 2:</h3>
                    <p>TC sends PREPARE to A, then crashes. TC never sends PREPARE to B. No further messages from TC.</p>

                    <h4>Question 2: When is it safe for A to abort the transaction?</h4>
                    <ul style="list-style: none; padding-left: 0;">
                        <li>A. Any time after time t0</li>
                        <li>B. Any time after time t1</li>
                        <li>C. Any time after time t2</li>
                        <li>D. Any time after time t3</li>
                        <li>E. Any time after time t4</li>
                        <li>F. Never</li>
                    </ul>

                    <button class="btn btn-primary" onclick="toggleAnswer('answer3b')" style="margin-top: 15px;">üëÅÔ∏è Reveal Answer</button>

                    <div id="answer3b" style="display: none; margin-top: 20px; padding: 20px; background: var(--surface); border-radius: 8px; border-left: 5px solid var(--success);">
                        <h3 style="color: var(--success);">Answer: D - Any time after time t3</h3>

                        <h4>Reasoning:</h4>
                        <p><strong>A can safely abort when it knows B will NOT vote YES (or never vote at all)</strong></p>

                        <h4>Timeline Analysis:</h4>
                        <ul>
                            <li><strong>t0:</strong> Initial state ‚ùå Transaction hasn't started</li>
                            <li><strong>t1:</strong> A receives PREPARE from TC ‚ùå Too early - B might still get PREPARE and vote YES</li>
                            <li><strong>t2:</strong> A forwards PREPARE to B ‚ùå B might receive it and vote YES</li>
                            <li><strong>t3:</strong> A receives timeout/no response from B ‚úÖ <strong>SAFE!</strong>
                                <ul>
                                    <li>TC crashed (no more messages from TC)</li>
                                    <li>B never received PREPARE (because TC crashed before sending to B)</li>
                                    <li>A forwarded PREPARE to B at t2</li>
                                    <li>If B received it, it would have responded by t3</li>
                                    <li>Since no response: B either didn't receive or cannot respond</li>
                                    <li><strong>Either way: B will not vote YES</strong></li>
                                    <li>2PC rule: If any participant doesn't vote YES ‚Üí ABORT</li>
                                </ul>
                            </li>
                        </ul>

                        <h4>Why A Cannot Abort Earlier:</h4>
                        <ul>
                            <li><strong>Before t3:</strong> B might still receive PREPARE (from A's forward at t2) and vote YES</li>
                            <li>If A aborts but B votes YES and TC (after recovery) decides COMMIT ‚Üí Violates atomicity!</li>
                            <li>A must wait to confirm B's state before aborting</li>
                        </ul>

                        <h4>Key Insight:</h4>
                        <p>In this modified protocol, A can abort once it's certain that <strong>not all participants will vote YES</strong>. After t3:</p>
                        <ul>
                            <li>TC is crashed (no COMMIT decision possible from TC)</li>
                            <li>B hasn't responded (won't vote YES)</li>
                            <li>Without all YES votes, transaction cannot commit</li>
                            <li>Safe to abort unilaterally</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Flashcards -->
            <div class="flashcard-container" id="flashcards">
                <div class="flashcard-controls">
                    <div class="flashcard-progress">
                        Card <span id="current-card">1</span> of <span id="total-cards">0</span>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="lecture-filter" class="btn btn-secondary" onchange="filterByLecture()" style="padding: 10px;">
                            <option value="all">All Lectures</option>
                            <option value="lecture1">Lecture 1: Intro</option>
                            <option value="lecture2">Lecture 2: Multithreading</option>
                            <option value="lecture3">Lecture 3: RPC</option>
                            <option value="lecture4">Lecture 4: MapReduce</option>
                            <option value="lecture6">Lecture 6: Crash Recovery</option>
                            <option value="lecture7">Lecture 7: 2PC</option>
                        </select>
                        <button class="btn btn-secondary" onclick="shuffleCards()">üîÄ Shuffle</button>
                    </div>
                </div>

                <div class="flashcard" id="current-flashcard" onclick="flipCard()">
                    <div class="flashcard-inner">
                        <div class="flashcard-front">
                            <p id="question-text">Click to load flashcards</p>
                        </div>
                        <div class="flashcard-back">
                            <p id="answer-text">Answer</p>
                        </div>
                    </div>
                </div>

                <div class="flashcard-hint">Click card to flip</div>

                <div class="flashcard-nav">
                    <button class="btn btn-secondary" onclick="previousCard()">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="nextCard()">Next ‚Üí</button>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>Good luck on your exam! üöÄ</p>
    </footer>

    <script>
        // Flashcard data
        window.FLASHCARDS = [
            // Lecture 1: Distributed Systems Intro
            {
                question: "What are the three main reasons for building distributed systems?",
                answer: "1) To achieve parallelism (increase computing power), 2) To tolerate faults (redundancy/availability), 3) To achieve physical distribution (inherent placement of components)",
                lecture: "lecture1"
            },
            {
                question: "What is the main challenge of distributed systems?",
                answer: "Concurrency - dealing with multiple parts that interact and run simultaneously, which introduces complexity in coordination, consistency, and failure handling",
                lecture: "lecture1"
            },
            {
                question: "What is partial failure in distributed systems?",
                answer: "When some components of the system fail while others continue working. This is difficult because you may not know if a remote component has failed or is just slow",
                lecture: "lecture1"
            },
            {
                question: "What is the performance goal in distributed systems and why is it often not achieved?",
                answer: "Goal: Nx speedup with N machines. Reality: Often not achieved due to overhead from communication, coordination, and load imbalance",
                lecture: "lecture1"
            },
            {
                question: "What are the main infrastructure components in distributed systems?",
                answer: "Storage, Communication (networking), and Computation. These form the foundation of distributed architectures",
                lecture: "lecture1"
            },
            {
                question: "What is the difference between scalability and performance?",
                answer: "Performance: How fast a single operation completes. Scalability: Whether you can handle more load by adding more machines (maintaining performance as system grows)",
                lecture: "lecture1"
            },
            {
                question: "What is fault tolerance?",
                answer: "The ability of a system to continue operating correctly even when some components fail. Achieved through redundancy and replication",
                lecture: "lecture1"
            },
            {
                question: "What is availability in distributed systems?",
                answer: "The fraction of time a system is usable/operational. Often measured as uptime percentage (e.g., 99.9% = 'three nines')",
                lecture: "lecture1"
            },
            {
                question: "What is recoverability?",
                answer: "The ability of a system to restore correct operation after a failure, often by recovering to a consistent state using logs or checkpoints",
                lecture: "lecture1"
            },
            {
                question: "What is consistency in distributed systems?",
                answer: "Ensuring all replicas/nodes see the same data and agree on the state, even with concurrent operations. Different consistency models offer different guarantees",
                lecture: "lecture1"
            },

            // Lecture 2: Multithreading
            {
                question: "Why use threads in distributed systems?",
                answer: "1) I/O concurrency - handle multiple network requests simultaneously, 2) Multicore parallelism - utilize multiple CPU cores, 3) Convenience - simpler programming model for concurrent tasks",
                lecture: "lecture2"
            },
            {
                question: "What is a race condition?",
                answer: "When the outcome depends on the non-deterministic timing/interleaving of operations from multiple threads. Results in unpredictable behavior",
                lecture: "lecture2"
            },
            {
                question: "What is the purpose of locks/mutexes?",
                answer: "To provide mutual exclusion - ensuring only one thread can execute a critical section at a time, preventing race conditions on shared data",
                lecture: "lecture2"
            },
            {
                question: "What are condition variables used for?",
                answer: "To allow threads to wait for specific conditions to become true. Threads can wait() on a condition and be signal()ed or broadcast() when the condition changes",
                lecture: "lecture2"
            },
            {
                question: "What is deadlock?",
                answer: "When two or more threads are permanently blocked, each waiting for a resource held by another. Example: Thread A holds lock 1 and waits for lock 2, while Thread B holds lock 2 and waits for lock 1",
                lecture: "lecture2"
            },
            {
                question: "What are the four conditions required for deadlock (Coffman conditions)?",
                answer: "1) Mutual exclusion, 2) Hold and wait, 3) No preemption, 4) Circular wait. All four must be present for deadlock to occur",
                lecture: "lecture2"
            },
            {
                question: "What is the common solution to prevent deadlock?",
                answer: "Lock ordering - always acquire locks in a consistent global order across all threads. This breaks the circular wait condition",
                lecture: "lecture2"
            },
            {
                question: "What is a thread-safe data structure?",
                answer: "A data structure that can be safely accessed by multiple threads concurrently without causing race conditions, typically using internal locking mechanisms",
                lecture: "lecture2"
            },
            {
                question: "What is the difference between wait() and signal() on condition variables?",
                answer: "wait() releases the lock and blocks the thread until signaled. signal() wakes up one waiting thread. broadcast() wakes up all waiting threads",
                lecture: "lecture2"
            },
            {
                question: "Why must wait() be called in a while loop instead of an if statement?",
                answer: "Because of spurious wakeups and the possibility that another thread changed the condition between when you were signaled and when you reacquired the lock",
                lecture: "lecture2"
            },

            // Lecture 3: RPC
            {
                question: "What is RPC (Remote Procedure Call)?",
                answer: "A protocol that allows a program to execute a procedure/function on a remote machine as if it were a local call, hiding network communication complexity",
                lecture: "lecture3"
            },
            {
                question: "What are the main components of an RPC system?",
                answer: "1) Client stub (marshaling), 2) Server stub (unmarshaling), 3) Network communication layer, 4) Runtime library. Stubs handle serialization and provide the illusion of local calls",
                lecture: "lecture3"
            },
            {
                question: "What is marshaling in RPC?",
                answer: "Converting data structures and parameters into a format suitable for network transmission (serialization). The reverse is unmarshaling (deserialization)",
                lecture: "lecture3"
            },
            {
                question: "What challenges does RPC face that local procedure calls don't?",
                answer: "1) Network failures, 2) Latency, 3) Different address spaces, 4) Partial failures, 5) At-least-once vs at-most-once semantics",
                lecture: "lecture3"
            },
            {
                question: "What is at-least-once RPC semantics?",
                answer: "The RPC system retries failed calls, guaranteeing the call executes at least once, but possibly multiple times if responses are lost. Suitable for idempotent operations",
                lecture: "lecture3"
            },
            {
                question: "What is at-most-once RPC semantics?",
                answer: "The RPC system uses techniques (like duplicate detection with XIDs) to ensure a call executes at most once, even with retries. Required for non-idempotent operations",
                lecture: "lecture3"
            },
            {
                question: "What is an idempotent operation?",
                answer: "An operation that produces the same result whether executed once or multiple times. Example: 'set x=5' is idempotent, 'x=x+1' is not",
                lecture: "lecture3"
            },
            {
                question: "What is an XID in RPC?",
                answer: "A unique transaction identifier sent with each RPC request. Used by the server to detect and discard duplicate requests, enabling at-most-once semantics",
                lecture: "lecture3"
            },
            {
                question: "Why can't RPC provide exactly-once semantics?",
                answer: "Because of fundamental uncertainty in distributed systems - if a server executes a request and crashes before sending the reply, the client can't distinguish this from a lost request, making true exactly-once impossible",
                lecture: "lecture3"
            },
            {
                question: "What is the role of client and server stubs in RPC?",
                answer: "Client stub: Packages arguments and sends request (marshaling). Server stub: Unpacks arguments, calls actual function, packages results (unmarshaling). Both hide network details from application code",
                lecture: "lecture3"
            },

            // Lecture 4: MapReduce
            {
                question: "What is MapReduce?",
                answer: "A programming model and system for processing large datasets in parallel across many machines. Consists of two phases: Map (process/transform data) and Reduce (aggregate results)",
                lecture: "lecture4"
            },
            {
                question: "What does the Map function do in MapReduce?",
                answer: "Processes input key-value pairs and produces intermediate key-value pairs. Example: (document, content) -> list of (word, 1) for word counting",
                lecture: "lecture4"
            },
            {
                question: "What does the Reduce function do in MapReduce?",
                answer: "Takes an intermediate key and all values for that key, then combines/aggregates them. Example: (word, [1,1,1]) -> (word, 3) for word counting",
                lecture: "lecture4"
            },
            {
                question: "How does MapReduce achieve fault tolerance?",
                answer: "By re-executing tasks on failure. Master tracks task states; if a worker fails, its tasks are reassigned. Map output is stored on local disk, so lost map tasks must be re-executed",
                lecture: "lecture4"
            },
            {
                question: "What is the role of the master in MapReduce?",
                answer: "Coordinates the entire job: assigns tasks to workers, tracks task completion, handles worker failures, and manages the transition from Map to Reduce phase",
                lecture: "lecture4"
            },
            {
                question: "Why is Map output written to local disk instead of GFS?",
                answer: "Map output is temporary intermediate data. Local disk is faster and reduces network traffic. Only final Reduce output is written to GFS for persistence",
                lecture: "lecture4"
            },
            {
                question: "What happens if a worker fails during the Map phase?",
                answer: "The master reassigns all map tasks (completed or in-progress) from that worker to other workers, since map output was on the failed worker's local disk",
                lecture: "lecture4"
            },
            {
                question: "What is a combiner in MapReduce?",
                answer: "An optional optimization that performs local aggregation of map output before sending over the network. Reduces data transfer. Example: locally summing word counts before sending to reducer",
                lecture: "lecture4"
            },
            {
                question: "How does MapReduce handle stragglers (slow workers)?",
                answer: "Uses speculative execution - when a job is near completion, the master schedules backup executions of remaining in-progress tasks, using whichever finishes first",
                lecture: "lecture4"
            },
            {
                question: "What determines which reducer gets which keys?",
                answer: "A partition function (typically hash(key) mod R) applied to intermediate keys. Ensures all values for a given key go to the same reducer",
                lecture: "lecture4"
            },

            // Lecture 6: Crash Recovery
            {
                question: "What is crash recovery?",
                answer: "Techniques to restore a system to a consistent state after a failure, ensuring durability and consistency despite crashes. Uses logging and checkpointing",
                lecture: "lecture6"
            },
            {
                question: "What is a write-ahead log (WAL)?",
                answer: "A log where all modifications are recorded before being applied to the database. Ensures durability - if a crash occurs, the log can be replayed to recover state",
                lecture: "lecture6"
            },
            {
                question: "What is the difference between redo and undo logging?",
                answer: "Redo: Log new values, write to disk after commit. Undo: Log old values, write to disk before commit. Redo prevents uncommitted data on disk; Undo allows rolling back partial transactions",
                lecture: "lecture6"
            },
            {
                question: "What is idempotent recovery?",
                answer: "Recovery operations that can be safely repeated. Important because a crash during recovery should not cause inconsistency when recovery is restarted",
                lecture: "lecture6"
            },
            {
                question: "What is a checkpoint in crash recovery?",
                answer: "A snapshot of system state written to stable storage. During recovery, start from the most recent checkpoint and replay the log, reducing recovery time",
                lecture: "lecture6"
            },
            {
                question: "Why do we need both logging and checkpointing?",
                answer: "Logging ensures durability and enables recovery. Checkpointing bounds recovery time by providing a known consistent state, avoiding replaying the entire log from the beginning",
                lecture: "lecture6"
            },
            {
                question: "What must be true before a transaction can commit?",
                answer: "All log records for the transaction (including the commit record) must be written to stable storage. This ensures durability - the transaction can be recovered after a crash",
                lecture: "lecture6"
            },
            {
                question: "What is the purpose of log sequence numbers (LSNs)?",
                answer: "Unique identifiers for log records that establish ordering. Help track which updates have been applied and coordinate recovery across multiple logs or pages",
                lecture: "lecture6"
            },
            {
                question: "What is stable storage?",
                answer: "Storage that survives crashes and power failures (typically disk or SSD). Essential for durability - logs and committed data must be on stable storage",
                lecture: "lecture6"
            },
            {
                question: "What happens during crash recovery?",
                answer: "1) Analysis: Determine which transactions were active, 2) Redo: Replay committed transactions from the log, 3) Undo: Roll back uncommitted transactions",
                lecture: "lecture6"
            },

            // Lecture 7: Two-Phase Commit (2PC)
            {
                question: "What problem does Two-Phase Commit solve?",
                answer: "Atomic commitment across multiple distributed nodes - ensuring all participants either commit or all abort a transaction, maintaining consistency despite failures",
                lecture: "lecture7"
            },
            {
                question: "What are the two phases of Two-Phase Commit?",
                answer: "Phase 1 (Prepare/Voting): Coordinator asks participants if they can commit. Phase 2 (Commit/Abort): Based on votes, coordinator tells participants to commit or abort",
                lecture: "lecture7"
            },
            {
                question: "What is the role of the coordinator in 2PC?",
                answer: "Orchestrates the protocol: sends prepare messages, collects votes, makes the commit/abort decision, and sends the final decision to all participants",
                lecture: "lecture7"
            },
            {
                question: "What is the role of participants in 2PC?",
                answer: "Each participant votes (yes if ready to commit, no otherwise), writes prepare record to log, and waits for coordinator's decision before committing or aborting",
                lecture: "lecture7"
            },
            {
                question: "When does the coordinator decide to commit in 2PC?",
                answer: "Only if ALL participants vote YES. If any participant votes NO or fails to respond (timeout), the coordinator decides to ABORT",
                lecture: "lecture7"
            },
            {
                question: "What must a participant do before voting YES?",
                answer: "1) Write all transaction updates to the log, 2) Write a PREPARE record to the log, 3) Force the log to stable storage. This ensures it can commit or abort after a crash",
                lecture: "lecture7"
            },
            {
                question: "What is the blocking problem in 2PC?",
                answer: "If the coordinator crashes after participants vote YES but before sending the decision, participants are blocked - they cannot commit or abort until the coordinator recovers",
                lecture: "lecture7"
            },
            {
                question: "What happens if a participant crashes after voting YES?",
                answer: "On recovery, it checks its log. If it sees a PREPARE record but no commit/abort, it must contact the coordinator to learn the decision and complete the transaction",
                lecture: "lecture7"
            },
            {
                question: "What is a participant's uncertainty period in 2PC?",
                answer: "The time between voting YES and receiving the final decision. During this period, the participant holds locks and cannot unilaterally decide to commit or abort",
                lecture: "lecture7"
            },
            {
                question: "Why is 2PC considered a blocking protocol?",
                answer: "Because participants can be blocked waiting for a crashed coordinator. Unlike non-blocking protocols (like 3PC), 2PC cannot make progress if the coordinator is unavailable",
                lecture: "lecture7"
            },
            {
                question: "What log records does the coordinator write in 2PC?",
                answer: "1) START-2PC before sending prepares, 2) COMMIT or ABORT after collecting votes (before sending decision). These enable coordinator recovery",
                lecture: "lecture7"
            },
            {
                question: "Can a participant unilaterally abort before voting?",
                answer: "Yes. Before voting, a participant can decide to abort (vote NO) for any reason. After voting YES, it must wait for the coordinator's decision",
                lecture: "lecture7"
            },
            {
                question: "What is the timeout mechanism in 2PC?",
                answer: "If the coordinator doesn't receive all votes within a timeout, it aborts the transaction. If a participant doesn't receive a decision within a timeout after voting YES, it is blocked",
                lecture: "lecture7"
            },
            {
                question: "How does 2PC ensure atomicity?",
                answer: "By requiring unanimous YES votes to commit and using durable logging. The coordinator's commit decision is written to stable storage before sending, ensuring consistent recovery",
                lecture: "lecture7"
            },
            {
                question: "What is Three-Phase Commit (3PC) and how does it differ from 2PC?",
                answer: "3PC adds a pre-commit phase to make the protocol non-blocking. However, it requires stronger assumptions (synchronous network, failure detectors) that are often unrealistic",
                lecture: "lecture7"
            }
        ];
    </script>

    <script>
        // Tab switching
        const tabs = document.querySelectorAll('.tab');
        const contents = document.querySelectorAll('.lecture-content');
        const flashcardContainer = document.querySelector('.flashcard-container');

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));
                flashcardContainer.classList.remove('active');

                tab.classList.add('active');
                const tabName = tab.getAttribute('data-tab');

                if (tabName === 'flashcards') {
                    flashcardContainer.classList.add('active');
                    loadFlashcards();
                } else {
                    document.getElementById(tabName).classList.add('active');
                }
            });
        });

        // Timer countdown
        // Flashcard system
        let allFlashcards = [];
        let flashcards = [];
        let currentCardIndex = 0;

        function flipCard() {
            document.getElementById('current-flashcard').classList.toggle('flipped');
        }

        function loadFlashcards() {
            if (allFlashcards.length === 0) {
                allFlashcards = window.FLASHCARDS || [];
                flashcards = allFlashcards;
                document.getElementById('total-cards').textContent = flashcards.length;
                if (flashcards.length > 0) {
                    showCard(0);
                }
            }
        }

        function filterByLecture() {
            const filter = document.getElementById('lecture-filter').value;
            if (filter === 'all') {
                flashcards = allFlashcards;
            } else {
                flashcards = allFlashcards.filter(card => card.lecture === filter);
            }
            document.getElementById('total-cards').textContent = flashcards.length;
            if (flashcards.length > 0) {
                showCard(0);
            } else {
                document.getElementById('question-text').textContent = 'No flashcards for this lecture';
                document.getElementById('answer-text').textContent = '';
            }
        }

        function showCard(index) {
            if (flashcards.length === 0) return;

            currentCardIndex = index;
            const card = flashcards[index];

            document.getElementById('question-text').textContent = card.question;
            document.getElementById('answer-text').textContent = card.answer;
            document.getElementById('current-card').textContent = index + 1;

            // Remove flip if present
            document.getElementById('current-flashcard').classList.remove('flipped');
        }

        function nextCard() {
            if (currentCardIndex < flashcards.length - 1) {
                showCard(currentCardIndex + 1);
            } else {
                showCard(0); // Loop back
            }
        }

        function previousCard() {
            if (currentCardIndex > 0) {
                showCard(currentCardIndex - 1);
            } else {
                showCard(flashcards.length - 1); // Loop back
            }
        }

        function shuffleCards() {
            flashcards = flashcards.sort(() => Math.random() - 0.5);
            showCard(0);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (flashcardContainer.classList.contains('active')) {
                if (e.key === 'ArrowRight' || e.key === ' ') {
                    e.preventDefault();
                    if (document.getElementById('current-flashcard').classList.contains('flipped')) {
                        nextCard();
                    } else {
                        flipCard();
                    }
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    previousCard();
                } else if (e.key === 'f' || e.key === 'F') {
                    e.preventDefault();
                    flipCard();
                }
            }
        });

        // ========== LECTURE 1: Latency Simulator ==========
        function simulateLatency(ms, location) {
            const bar = document.getElementById('latency-bar');
            const result = document.getElementById('latency-result');

            // Reset
            bar.style.width = '0%';
            result.textContent = 'Simulating request to ' + location + '...';

            // Animate progress bar
            setTimeout(() => {
                const percentage = Math.min((ms / 1000) * 100, 100);
                bar.style.width = percentage + '%';
            }, 50);

            // Show result after delay
            setTimeout(() => {
                let experience = '';
                let color = '';

                if (ms < 50) {
                    experience = 'Excellent - feels instant';
                    color = 'var(--success)';
                } else if (ms < 100) {
                    experience = 'Good - barely noticeable';
                    color = 'var(--success)';
                } else if (ms < 200) {
                    experience = 'Acceptable - slight delay';
                    color = 'var(--warning)';
                } else if (ms < 500) {
                    experience = 'Poor - noticeable lag';
                    color = 'var(--danger)';
                } else {
                    experience = 'Unacceptable - very frustrating';
                    color = 'var(--danger)';
                }

                result.innerHTML = `<span style="color: ${color};">${location}: ${ms}ms - ${experience}</span><br>` +
                    `<small>This demonstrates why CDNs and geographic distribution matter!</small>`;
            }, ms);
        }

        // ========== PRACTICE QUESTIONS: Toggle Answers ==========
        function toggleAnswer(answerId) {
            const answer = document.getElementById(answerId);
            const button = event.target;

            if (answer.style.display === 'none' || answer.style.display === '') {
                answer.style.display = 'block';
                button.textContent = 'üôà Hide Answer';
                button.classList.remove('btn-primary');
                button.classList.add('btn-secondary');
            } else {
                answer.style.display = 'none';
                button.textContent = 'üëÅÔ∏è Reveal Answer';
                button.classList.remove('btn-secondary');
                button.classList.add('btn-primary');
            }
        }

        // ========== VISUALIZATION 1: Thread State Diagram ==========
        const threadStateViz = {
            svg: null,
            currentState: 'New',

            init() {
                this.svg = document.getElementById('thread-state-viz');
                if (this.svg) this.draw();
            },

            draw() {
                if (!this.svg) return;
                const width = this.svg.clientWidth;
                const height = 400;
                const centerX = width / 2;
                const centerY = height / 2;

                // Clear SVG
                this.svg.innerHTML = '';

                // State positions (circular layout)
                const statePositions = {
                    'New': { x: centerX - 250, y: centerY - 100 },
                    'Ready': { x: centerX - 100, y: centerY - 150 },
                    'Running': { x: centerX + 100, y: centerY - 150 },
                    'Blocked': { x: centerX + 100, y: centerY + 50 },
                    'Terminated': { x: centerX + 250, y: centerY + 100 }
                };

                // Define arrowhead marker
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', 'arrowhead');
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '10');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3');
                marker.setAttribute('orient', 'auto');
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3, 0 6');
                polygon.setAttribute('fill', '#cbd5e1');
                marker.appendChild(polygon);
                defs.appendChild(marker);
                this.svg.appendChild(defs);

                // Draw transitions (arrows)
                const transitions = [
                    { from: 'New', to: 'Ready', label: 'create' },
                    { from: 'Ready', to: 'Running', label: 'schedule' },
                    { from: 'Running', to: 'Ready', label: 'preempt' },
                    { from: 'Running', to: 'Blocked', label: 'wait' },
                    { from: 'Blocked', to: 'Ready', label: 'wake' },
                    { from: 'Running', to: 'Terminated', label: 'exit' }
                ];

                transitions.forEach(t => {
                    const fromPos = statePositions[t.from];
                    const toPos = statePositions[t.to];

                    // Draw arrow
                    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    arrow.setAttribute('x1', fromPos.x);
                    arrow.setAttribute('y1', fromPos.y);
                    arrow.setAttribute('x2', toPos.x);
                    arrow.setAttribute('y2', toPos.y);
                    arrow.setAttribute('stroke', '#cbd5e1');
                    arrow.setAttribute('stroke-width', '2');
                    arrow.setAttribute('marker-end', 'url(#arrowhead)');
                    this.svg.appendChild(arrow);

                    // Draw label
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', (fromPos.x + toPos.x) / 2);
                    label.setAttribute('y', (fromPos.y + toPos.y) / 2 - 5);
                    label.setAttribute('fill', '#64748b');
                    label.setAttribute('font-size', '12');
                    label.setAttribute('text-anchor', 'middle');
                    label.textContent = t.label;
                    this.svg.appendChild(label);
                });

                // Draw state circles
                Object.keys(statePositions).forEach(state => {
                    const pos = statePositions[state];
                    const isActive = state === this.currentState;

                    // Circle
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', pos.x);
                    circle.setAttribute('cy', pos.y);
                    circle.setAttribute('r', '50');
                    circle.setAttribute('fill', isActive ? '#2563eb' : '#f1f5f9');
                    circle.setAttribute('stroke', isActive ? '#1e40af' : '#cbd5e1');
                    circle.setAttribute('stroke-width', '3');
                    this.svg.appendChild(circle);

                    // Text
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', pos.x);
                    text.setAttribute('y', pos.y + 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('fill', isActive ? 'white' : '#1e293b');
                    text.setAttribute('font-weight', 'bold');
                    text.setAttribute('font-size', '14');
                    text.textContent = state;
                    this.svg.appendChild(text);
                });

                // Status text
                const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                statusText.setAttribute('x', centerX);
                statusText.setAttribute('y', height - 20);
                statusText.setAttribute('text-anchor', 'middle');
                statusText.setAttribute('fill', '#1e293b');
                statusText.setAttribute('font-size', '16');
                statusText.setAttribute('font-weight', 'bold');
                statusText.textContent = `Current State: ${this.currentState}`;
                this.svg.appendChild(statusText);
            },

            createThread() {
                this.currentState = 'Ready';
                this.draw();
            },

            runThread() {
                if (this.currentState === 'Ready') {
                    this.currentState = 'Running';
                    this.draw();
                }
            },

            blockThread() {
                if (this.currentState === 'Running') {
                    this.currentState = 'Blocked';
                    this.draw();
                }
            },

            wakeThread() {
                if (this.currentState === 'Blocked') {
                    this.currentState = 'Ready';
                    this.draw();
                }
            },

            reset() {
                this.currentState = 'New';
                this.draw();
            }
        };

        // ========== VISUALIZATION 2: Mutex Lock/Unlock ==========
        const mutexViz = {
            svg: null,
            mutexOwner: null,
            waitQueue: [],

            init() {
                this.svg = document.getElementById('mutex-viz');
                if (this.svg) this.draw();
            },

            draw() {
                if (!this.svg) return;
                const width = this.svg.clientWidth;
                const height = 450;

                // Clear SVG
                this.svg.innerHTML = '';

                // Draw mutex (lock icon)
                const mutexX = width / 2;
                const mutexY = 150;

                // Lock body
                const lockBody = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                lockBody.setAttribute('x', mutexX - 30);
                lockBody.setAttribute('y', mutexY);
                lockBody.setAttribute('width', '60');
                lockBody.setAttribute('height', '70');
                lockBody.setAttribute('rx', '8');
                lockBody.setAttribute('fill', this.mutexOwner ? '#ef4444' : '#22c55e');
                lockBody.setAttribute('stroke', '#1e293b');
                lockBody.setAttribute('stroke-width', '3');
                this.svg.appendChild(lockBody);

                // Lock shackle
                const shackle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                shackle.setAttribute('d', `M ${mutexX - 20} ${mutexY} Q ${mutexX - 20} ${mutexY - 30}, ${mutexX} ${mutexY - 30} Q ${mutexX + 20} ${mutexY - 30}, ${mutexX + 20} ${mutexY}`);
                shackle.setAttribute('fill', 'none');
                shackle.setAttribute('stroke', this.mutexOwner ? '#ef4444' : '#22c55e');
                shackle.setAttribute('stroke-width', '6');
                this.svg.appendChild(shackle);

                // Status text
                const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                statusText.setAttribute('x', mutexX);
                statusText.setAttribute('y', mutexY + 100);
                statusText.setAttribute('text-anchor', 'middle');
                statusText.setAttribute('fill', '#1e293b');
                statusText.setAttribute('font-weight', 'bold');
                statusText.setAttribute('font-size', '16');
                statusText.textContent = this.mutexOwner ? `Locked by ${this.mutexOwner}` : 'Unlocked';
                this.svg.appendChild(statusText);

                // Draw threads
                const threadY = 300;
                const threads = ['Thread 1', 'Thread 2', 'Thread 3'];
                threads.forEach((thread, idx) => {
                    const threadX = (width / 4) * (idx + 1);
                    const isOwner = this.mutexOwner === thread;
                    const isWaiting = this.waitQueue.includes(thread);

                    // Draw line to mutex if owner
                    if (isOwner) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', threadX);
                        line.setAttribute('y1', threadY - 40);
                        line.setAttribute('x2', mutexX);
                        line.setAttribute('y2', mutexY + 70);
                        line.setAttribute('stroke', '#22c55e');
                        line.setAttribute('stroke-width', '3');
                        line.setAttribute('stroke-dasharray', '5,5');
                        this.svg.appendChild(line);
                    }

                    // Thread circle
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', threadX);
                    circle.setAttribute('cy', threadY);
                    circle.setAttribute('r', '40');
                    circle.setAttribute('fill', isOwner ? '#22c55e' : (isWaiting ? '#f59e0b' : '#e2e8f0'));
                    circle.setAttribute('stroke', '#1e293b');
                    circle.setAttribute('stroke-width', '2');
                    this.svg.appendChild(circle);

                    // Thread text
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', threadX);
                    text.setAttribute('y', threadY + 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('fill', '#1e293b');
                    text.setAttribute('font-size', '12');
                    text.setAttribute('font-weight', 'bold');
                    text.textContent = `T${idx + 1}`;
                    this.svg.appendChild(text);

                    // Status label
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', threadX);
                    label.setAttribute('y', threadY + 60);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', '#64748b');
                    label.setAttribute('font-size', '11');
                    label.textContent = isOwner ? 'Owner' : (isWaiting ? 'Waiting' : 'Ready');
                    this.svg.appendChild(label);
                });

                // Draw wait queue
                if (this.waitQueue.length > 0) {
                    const queueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    queueText.setAttribute('x', width / 2);
                    queueText.setAttribute('y', height - 30);
                    queueText.setAttribute('text-anchor', 'middle');
                    queueText.setAttribute('fill', '#f59e0b');
                    queueText.setAttribute('font-weight', 'bold');
                    queueText.textContent = `Wait Queue: ${this.waitQueue.join(', ')}`;
                    this.svg.appendChild(queueText);
                }
            },

            thread1Lock() {
                this.tryLock('Thread 1');
            },

            thread2Lock() {
                this.tryLock('Thread 2');
            },

            thread3Lock() {
                this.tryLock('Thread 3');
            },

            tryLock(thread) {
                if (!this.mutexOwner) {
                    this.mutexOwner = thread;
                } else if (!this.waitQueue.includes(thread) && this.mutexOwner !== thread) {
                    this.waitQueue.push(thread);
                }
                this.draw();
            },

            unlock() {
                if (this.mutexOwner) {
                    this.mutexOwner = null;
                    if (this.waitQueue.length > 0) {
                        this.mutexOwner = this.waitQueue.shift();
                    }
                }
                this.draw();
            },

            reset() {
                this.mutexOwner = null;
                this.waitQueue = [];
                this.draw();
            }
        };

        // ========== VISUALIZATION 3: Condition Variable ==========
        const condVarViz = {
            svg: null,
            waiters: [],
            nextWaiterId: 1,

            init() {
                this.svg = document.getElementById('condvar-viz');
                if (this.svg) this.draw();
            },

            draw() {
                if (!this.svg) return;
                const width = this.svg.clientWidth;
                const height = 400;

                // Clear SVG
                this.svg.innerHTML = '';

                // Define green arrowhead marker
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', 'arrowhead-green');
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '10');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3');
                marker.setAttribute('orient', 'auto');
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3, 0 6');
                polygon.setAttribute('fill', '#22c55e');
                marker.appendChild(polygon);
                defs.appendChild(marker);
                this.svg.appendChild(defs);

                // Draw condition variable (queue)
                const queueX = width / 2;
                const queueY = 100;

                // Queue box
                const queueBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                queueBox.setAttribute('x', queueX - 150);
                queueBox.setAttribute('y', queueY - 30);
                queueBox.setAttribute('width', '300');
                queueBox.setAttribute('height', '60');
                queueBox.setAttribute('rx', '10');
                queueBox.setAttribute('fill', '#f1f5f9');
                queueBox.setAttribute('stroke', '#2563eb');
                queueBox.setAttribute('stroke-width', '3');
                this.svg.appendChild(queueBox);

                // Queue label
                const queueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                queueLabel.setAttribute('x', queueX);
                queueLabel.setAttribute('y', queueY - 45);
                queueLabel.setAttribute('text-anchor', 'middle');
                queueLabel.setAttribute('fill', '#2563eb');
                queueLabel.setAttribute('font-weight', 'bold');
                queueLabel.setAttribute('font-size', '16');
                queueLabel.textContent = 'Condition Variable Wait Queue';
                this.svg.appendChild(queueLabel);

                // Draw waiting threads
                const waitingThreads = this.waiters.filter(w => w.state === 'waiting');
                waitingThreads.forEach((waiter, idx) => {
                    const threadX = queueX - 130 + (idx * 60);
                    const threadY = queueY;

                    // Thread circle (small, inside queue)
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', threadX);
                    circle.setAttribute('cy', threadY);
                    circle.setAttribute('r', '20');
                    circle.setAttribute('fill', '#f59e0b');
                    circle.setAttribute('stroke', '#1e293b');
                    circle.setAttribute('stroke-width', '2');
                    this.svg.appendChild(circle);

                    // Thread ID
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', threadX);
                    text.setAttribute('y', threadY + 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '12');
                    text.setAttribute('font-weight', 'bold');
                    text.textContent = `T${waiter.id}`;
                    this.svg.appendChild(text);
                });

                // Draw woken threads
                const wokenThreads = this.waiters.filter(w => w.state === 'woken');
                wokenThreads.forEach((waiter, idx) => {
                    const threadX = queueX - 100 + (idx * 80);
                    const threadY = 250;

                    // Arrow from queue to woken thread
                    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    arrow.setAttribute('x1', threadX);
                    arrow.setAttribute('y1', queueY + 40);
                    arrow.setAttribute('x2', threadX);
                    arrow.setAttribute('y2', threadY - 35);
                    arrow.setAttribute('stroke', '#22c55e');
                    arrow.setAttribute('stroke-width', '3');
                    arrow.setAttribute('marker-end', 'url(#arrowhead-green)');
                    this.svg.appendChild(arrow);

                    // Thread circle (larger, below queue)
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', threadX);
                    circle.setAttribute('cy', threadY);
                    circle.setAttribute('r', '35');
                    circle.setAttribute('fill', '#22c55e');
                    circle.setAttribute('stroke', '#1e293b');
                    circle.setAttribute('stroke-width', '2');
                    this.svg.appendChild(circle);

                    // Thread ID
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', threadX);
                    text.setAttribute('y', threadY - 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '14');
                    text.setAttribute('font-weight', 'bold');
                    text.textContent = `T${waiter.id}`;
                    this.svg.appendChild(text);

                    // Status
                    const status = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    status.setAttribute('x', threadX);
                    status.setAttribute('y', threadY + 10);
                    status.setAttribute('text-anchor', 'middle');
                    status.setAttribute('fill', 'white');
                    status.setAttribute('font-size', '10');
                    status.textContent = 'Woken';
                    this.svg.appendChild(status);
                });

                // Status text
                const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                statusText.setAttribute('x', width / 2);
                statusText.setAttribute('y', height - 20);
                statusText.setAttribute('text-anchor', 'middle');
                statusText.setAttribute('fill', '#1e293b');
                statusText.setAttribute('font-weight', 'bold');
                statusText.textContent = `Waiting: ${waitingThreads.length} | Woken: ${wokenThreads.length}`;
                this.svg.appendChild(statusText);
            },

            addWaiter() {
                this.waiters.push({ id: this.nextWaiterId++, state: 'waiting' });
                this.draw();
            },

            signal() {
                const waiter = this.waiters.find(w => w.state === 'waiting');
                if (waiter) {
                    waiter.state = 'woken';
                    setTimeout(() => {
                        this.waiters = this.waiters.filter(w => w !== waiter);
                        this.draw();
                    }, 2000);
                }
                this.draw();
            },

            broadcast() {
                this.waiters.forEach(w => {
                    if (w.state === 'waiting') {
                        w.state = 'woken';
                    }
                });
                this.draw();
                setTimeout(() => {
                    this.waiters = [];
                    this.draw();
                }, 2000);
            },

            reset() {
                this.waiters = [];
                this.nextWaiterId = 1;
                this.draw();
            }
        };

        // Initialize visualizations when page loads
        window.addEventListener('load', () => {
            threadStateViz.init();
            mutexViz.init();
            condVarViz.init();
        });

        // Redraw on window resize
        window.addEventListener('resize', () => {
            threadStateViz.draw();
            mutexViz.draw();
            condVarViz.draw();
        });

        // ========== VISUALIZATION 4: Crash Scenario Simulator ==========
        const crashSimulator = {
            simulateCrash(step) {
                // Reset all boxes
                document.getElementById('step1-box').style.background = '#e2e8f0';
                document.getElementById('step1-box').style.borderColor = '#cbd5e1';
                document.getElementById('step2-box').style.background = '#e2e8f0';
                document.getElementById('step2-box').style.borderColor = '#cbd5e1';
                document.getElementById('step3-box').style.background = '#e2e8f0';
                document.getElementById('step3-box').style.borderColor = '#cbd5e1';

                let resultHTML = '';

                if (step === 1) {
                    // Crash after step 1
                    document.getElementById('step1-box').style.background = '#22c55e';
                    document.getElementById('step1-box').style.borderColor = '#16a34a';

                    resultHTML = `
                        <strong style="color: #ef4444;">CRASH after Step 1!</strong><br><br>
                        <strong>State of the system:</strong><br>
                        ‚úì Inode bitmap updated (bit marked as used)<br>
                        ‚úó Inode NOT initialized<br>
                        ‚úó Directory NOT updated<br><br>
                        <strong style="color: #ef4444;">Problem:</strong><br>
                        - Inode is marked as "used" but contains garbage data<br>
                        - Wasted inode slot (disk space leak)<br>
                        - If accessed, will read corrupted metadata<br><br>
                        <strong>Recovery without logging:</strong> fsck can detect this but may not recover cleanly.
                    `;
                } else if (step === 2) {
                    // Crash after step 2
                    document.getElementById('step1-box').style.background = '#22c55e';
                    document.getElementById('step1-box').style.borderColor = '#16a34a';
                    document.getElementById('step2-box').style.background = '#22c55e';
                    document.getElementById('step2-box').style.borderColor = '#16a34a';

                    resultHTML = `
                        <strong style="color: #ef4444;">CRASH after Step 2!</strong><br><br>
                        <strong>State of the system:</strong><br>
                        ‚úì Inode bitmap updated<br>
                        ‚úì Inode initialized with metadata<br>
                        ‚úó Directory NOT updated<br><br>
                        <strong style="color: #ef4444;">Problem:</strong><br>
                        - File exists with valid metadata but is unreachable!<br>
                        - No directory entry points to this inode<br>
                        - Orphaned inode (disk space leak)<br>
                        - Data and metadata stored but file is "lost"<br><br>
                        <strong>Recovery without logging:</strong> fsck can move to lost+found, but filename is gone.
                    `;
                } else if (step === 3) {
                    // Crash during step 3
                    document.getElementById('step1-box').style.background = '#22c55e';
                    document.getElementById('step1-box').style.borderColor = '#16a34a';
                    document.getElementById('step2-box').style.background = '#22c55e';
                    document.getElementById('step2-box').style.borderColor = '#16a34a';
                    document.getElementById('step3-box').style.background = '#f59e0b';
                    document.getElementById('step3-box').style.borderColor = '#d97706';

                    resultHTML = `
                        <strong style="color: #ef4444;">CRASH during Step 3!</strong><br><br>
                        <strong>State of the system:</strong><br>
                        ‚úì Inode bitmap updated<br>
                        ‚úì Inode initialized<br>
                        ‚ö† Directory PARTIALLY written (corrupted!)<br><br>
                        <strong style="color: #ef4444;">Problem:</strong><br>
                        - Directory block contains incomplete entry<br>
                        - Could point to wrong inode or have garbled name<br>
                        - May cause directory corruption<br>
                        - System might not boot if critical directory affected<br><br>
                        <strong>Recovery without logging:</strong> Severe - fsck may not be able to fix safely.
                    `;
                }

                document.getElementById('crash-result').innerHTML = resultHTML;
            },

            reset() {
                document.getElementById('step1-box').style.background = '#e2e8f0';
                document.getElementById('step1-box').style.borderColor = '#cbd5e1';
                document.getElementById('step2-box').style.background = '#e2e8f0';
                document.getElementById('step2-box').style.borderColor = '#cbd5e1';
                document.getElementById('step3-box').style.background = '#e2e8f0';
                document.getElementById('step3-box').style.borderColor = '#cbd5e1';
                document.getElementById('crash-result').innerHTML = '<strong>Click a button to simulate a crash at different points</strong>';
            }
        };

        // ========== VISUALIZATION 5: Group Commit Animation ==========
        const groupCommit = {
            time: 0,
            buffer: [],
            committed: 0,
            interval: null,
            txnCounter: 1,
            maxBuffer: 5,
            flushInterval: 2.0, // seconds

            start() {
                if (this.interval) return; // Already running

                this.interval = setInterval(() => {
                    this.time += 0.1;
                    document.getElementById('gc-time').textContent = this.time.toFixed(1);

                    // Add random transaction (30% chance each tick)
                    if (Math.random() < 0.3 && this.buffer.length < this.maxBuffer) {
                        const txn = {
                            id: this.txnCounter++,
                            time: this.time.toFixed(1)
                        };
                        this.buffer.push(txn);
                        this.log(`[${txn.time}s] Transaction ${txn.id} added to buffer`);
                        this.updateDisplay();
                    }

                    // Flush when buffer is full or time interval reached
                    if (this.buffer.length >= this.maxBuffer ||
                        (this.buffer.length > 0 && this.time % this.flushInterval < 0.1)) {
                        this.flush();
                    }
                }, 100);
            },

            flush() {
                if (this.buffer.length === 0) return;

                const count = this.buffer.length;
                const txnIds = this.buffer.map(t => t.id).join(', ');
                this.log(`<strong style="color: #22c55e;">[${this.time.toFixed(1)}s] FLUSH! Committing ${count} transactions (${txnIds}) to disk</strong>`);

                this.committed += count;
                this.buffer = [];
                this.updateDisplay();
            },

            log(message) {
                const logDiv = document.getElementById('gc-log');
                logDiv.innerHTML += message + '<br>';
                logDiv.scrollTop = logDiv.scrollHeight; // Auto-scroll
            },

            updateDisplay() {
                document.getElementById('gc-buffer-count').textContent = this.buffer.length;
                document.getElementById('gc-committed').textContent = this.committed;

                // Update buffer visualization
                const bufferDiv = document.getElementById('gc-buffer');
                bufferDiv.innerHTML = '';

                for (let i = 0; i < this.maxBuffer; i++) {
                    const slot = document.createElement('div');
                    slot.style.cssText = 'width: 80px; height: 60px; border: 2px solid #cbd5e1; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: bold;';

                    if (i < this.buffer.length) {
                        slot.style.background = '#2563eb';
                        slot.style.color = 'white';
                        slot.textContent = `TXN ${this.buffer[i].id}`;
                    } else {
                        slot.style.background = '#f1f5f9';
                        slot.style.color = '#cbd5e1';
                        slot.textContent = 'Empty';
                    }

                    bufferDiv.appendChild(slot);
                }
            },

            stop() {
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
            },

            reset() {
                this.stop();
                this.time = 0;
                this.buffer = [];
                this.committed = 0;
                this.txnCounter = 1;

                document.getElementById('gc-time').textContent = '0.0';
                document.getElementById('gc-log').innerHTML = '';
                this.updateDisplay();
            }
        };

        // Initialize group commit display
        window.addEventListener('load', () => {
            if (document.getElementById('gc-buffer')) {
                groupCommit.updateDisplay();
            }
        });
    </script>
</body>
</html>
